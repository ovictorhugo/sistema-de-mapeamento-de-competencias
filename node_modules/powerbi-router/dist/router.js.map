{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d1432e331266a64c329f","webpack:///./src/router.ts","webpack:///./~/route-recognizer/dist/route-recognizer.js","webpack:///(webpack)/buildin/module.js","webpack:///(webpack)/buildin/amd-define.js"],"names":[],"mappings":"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A,kCAAiC,yDAAyD;AAC1F,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA,qDAAoD,kBAAkB;AACtE;AACA;AACA,kCAAiC,wDAAwD;AACzF,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,0BAAyB,WAAW,EAAE;AACtC,6BAA4B,WAAW;AACvC;;AAEA;AACA;AACA;AACA,qCAAoC,yBAAyB;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,qBAAqB;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA,0CAAyC,cAAc;;AAEvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,qBAAqB;AAC1C;;AAEA;;AAEA;AACA,4CAA2C,sBAAsB;AACjE,YAAW;AACX,4CAA2C,sBAAsB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA,qCAAoC,KAAK;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,mBAAmB;AACtC;;AAEA,sBAAqB,gBAAgB;AACrC;AACA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,eAAe;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6BAA4B;AAC5B;;AAEA;;AAEA,sBAAqB,iBAAiB;AACtC;;AAEA;;AAEA;;AAEA,wBAAuB,mBAAmB;AAC1C;;AAEA,yEAAwE,UAAU;;AAElF;;AAEA;AACA,8CAA6C,0DAA0D;AACvG;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA,4CAA2C,0DAA0D;AACrG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA,sBAAqB,oDAAoD;;AAEzE;;AAEA,sBAAqB,yBAAyB;AAC9C;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,sBAAqB,oDAAoD;;AAEzE;;AAEA,sBAAqB,mBAAmB;AACxC;;AAEA,uEAAsE,UAAU;;AAEhF;AACA;AACA;;AAEA,wCAAuC,uBAAuB;;AAE9D;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA,kCAAiC,WAAW;;AAE5C;AACA,QAAO;;AAEP;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAqC,mBAAmB;;AAExD;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,eAAe;AAChC;AACA,gCAA+B,OAAO;AACtC;;AAEA;AACA,kBAAiB,iBAAiB;AAClC,oCAAmC,2BAA2B;AAC9D;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,qDAA6C,oCAAoC,EAAE;AACnF,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;;AAED,6C;;;;;;;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA,8BAA6B,mDAAmD","file":"router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"powerbi-router\"] = factory();\n\telse\n\t\troot[\"powerbi-router\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d1432e331266a64c329f\n **/","import RouteRecognizer = require('route-recognizer');\n\nexport interface IAddHandler {\n  addHandler(handler: any): void;\n}\n\nexport interface IRouterHandler {\n  (request: IExtendedRequest, response: Response): void | Promise<void>;\n}\n\nexport class Router {\n  private handlers: IAddHandler;\n  private getRouteRecognizer: RouteRecognizer<any>;\n  private patchRouteRecognizer: RouteRecognizer<any>;\n  private postRouteRecognizer: RouteRecognizer<any>;\n  private putRouteRecognizer: RouteRecognizer<any>;\n  private deleteRouteRecognizer: RouteRecognizer<any>;\n\n  constructor(handlers: IAddHandler) {\n    this.handlers = handlers;\n\n    /**\n     * TODO: look at generating the router dynamically based on list of supported http methods\n     * instead of hardcoding the creation of these and the methods.\n     */\n    this.getRouteRecognizer = new RouteRecognizer();\n    this.patchRouteRecognizer = new RouteRecognizer();\n    this.postRouteRecognizer = new RouteRecognizer();\n    this.putRouteRecognizer = new RouteRecognizer();\n    this.deleteRouteRecognizer = new RouteRecognizer();\n  }\n\n  get(url: string, handler: IRouterHandler): this {\n    this.registerHandler(this.getRouteRecognizer, \"GET\", url, handler);\n    return this;\n  }\n\n  patch(url: string, handler: IRouterHandler): this {\n    this.registerHandler(this.patchRouteRecognizer, \"PATCH\", url, handler);\n    return this;\n  }\n\n  post(url: string, handler: IRouterHandler): this {\n    this.registerHandler(this.postRouteRecognizer, \"POST\", url, handler);\n    return this;\n  }\n\n  put(url: string, handler: IRouterHandler): this {\n    this.registerHandler(this.putRouteRecognizer, \"PUT\", url, handler);\n    return this;\n  }\n\n  delete(url: string, handler: IRouterHandler): this {\n    this.registerHandler(this.deleteRouteRecognizer, \"DELETE\", url, handler);\n    return this;\n  }\n\n  /**\n   * TODO: This method could use some refactoring.  There is conflict of interest between keeping clean separation of test and handle method\n   * Test method only returns boolean indicating if request can be handled, and handle method has opportunity to modify response and return promise of it.\n   * In the case of the router with route-recognizer where handlers are associated with routes, this already guarantees that only one handler is selected and makes the test method feel complicated\n   * Will leave as is an investigate cleaner ways at later time.\n   */\n  private registerHandler(routeRecognizer: RouteRecognizer<any>, method: string, url: string, handler: IRouterHandler) {\n    const routeRecognizerHandler = (request: IExtendedRequest): Promise<IResponse> => {\n      const response = new Response();\n      return Promise.resolve(handler(request, response))\n        .then(x => response);\n    };\n\n    routeRecognizer.add([\n      { path: url, handler: routeRecognizerHandler }\n    ]);\n\n    const internalHandler = {\n      test(request: IRequest): boolean {\n        if (request.method !== method) {\n          return false;\n        }\n\n        const matchingRoutes = routeRecognizer.recognize(request.url);\n        if (matchingRoutes === undefined) {\n          return false;\n        }\n\n        /**\n         * Copy parameters from recognized route to the request so they can be used within the handler function\n         * This isn't ideal because it is side affect which modifies the request instead of strictly testing for true or false\n         * but I don't see a better place to put this.  If we move it between the call to test and the handle it becomes part of the window post message proxy\n         * even though it's responsibility is related to routing.\n         */\n        const route = matchingRoutes[0];\n        (<IExtendedRequest>request).params = route.params;\n        (<IExtendedRequest>request).queryParams = (<any>matchingRoutes).queryParams;\n        (<IExtendedRequest>request).handler = route.handler;\n\n        return true;\n      },\n      handle(request: IExtendedRequest): Promise<IResponse> {\n        return request.handler(request);\n      }\n    };\n\n    this.handlers.addHandler(internalHandler);\n  }\n}\n\nexport interface IExtendedRequest extends IRequest {\n  params: any;\n  queryParams: any;\n  handler: any;\n}\n\nexport interface IRequest {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n  url: string;\n  headers: { [key: string]: string };\n  body: any;\n}\n\nexport interface IResponse {\n  statusCode: number;\n  headers?: { [key: string]: string };\n  body: any;\n}\n\nexport class Response implements IResponse {\n  statusCode: number;\n  headers: any;\n  body: any;\n\n  constructor() {\n    this.statusCode = 200;\n    this.headers = {};\n    this.body = null;\n  }\n\n  send(statusCode: number, body?: any) {\n    this.statusCode = statusCode;\n    this.body = body;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/router.ts\n **/","(function() {\n    \"use strict\";\n    function $$route$recognizer$dsl$$Target(path, matcher, delegate) {\n      this.path = path;\n      this.matcher = matcher;\n      this.delegate = delegate;\n    }\n\n    $$route$recognizer$dsl$$Target.prototype = {\n      to: function(target, callback) {\n        var delegate = this.delegate;\n\n        if (delegate && delegate.willAddRoute) {\n          target = delegate.willAddRoute(this.matcher.target, target);\n        }\n\n        this.matcher.add(this.path, target);\n\n        if (callback) {\n          if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n          this.matcher.addChild(this.path, target, callback, this.delegate);\n        }\n        return this;\n      }\n    };\n\n    function $$route$recognizer$dsl$$Matcher(target) {\n      this.routes = {};\n      this.children = {};\n      this.target = target;\n    }\n\n    $$route$recognizer$dsl$$Matcher.prototype = {\n      add: function(path, handler) {\n        this.routes[path] = handler;\n      },\n\n      addChild: function(path, target, callback, delegate) {\n        var matcher = new $$route$recognizer$dsl$$Matcher(target);\n        this.children[path] = matcher;\n\n        var match = $$route$recognizer$dsl$$generateMatch(path, matcher, delegate);\n\n        if (delegate && delegate.contextEntered) {\n          delegate.contextEntered(target, match);\n        }\n\n        callback(match);\n      }\n    };\n\n    function $$route$recognizer$dsl$$generateMatch(startingPath, matcher, delegate) {\n      return function(path, nestedCallback) {\n        var fullPath = startingPath + path;\n\n        if (nestedCallback) {\n          nestedCallback($$route$recognizer$dsl$$generateMatch(fullPath, matcher, delegate));\n        } else {\n          return new $$route$recognizer$dsl$$Target(startingPath + path, matcher, delegate);\n        }\n      };\n    }\n\n    function $$route$recognizer$dsl$$addRoute(routeArray, path, handler) {\n      var len = 0;\n      for (var i=0; i<routeArray.length; i++) {\n        len += routeArray[i].path.length;\n      }\n\n      path = path.substr(len);\n      var route = { path: path, handler: handler };\n      routeArray.push(route);\n    }\n\n    function $$route$recognizer$dsl$$eachRoute(baseRoute, matcher, callback, binding) {\n      var routes = matcher.routes;\n\n      for (var path in routes) {\n        if (routes.hasOwnProperty(path)) {\n          var routeArray = baseRoute.slice();\n          $$route$recognizer$dsl$$addRoute(routeArray, path, routes[path]);\n\n          if (matcher.children[path]) {\n            $$route$recognizer$dsl$$eachRoute(routeArray, matcher.children[path], callback, binding);\n          } else {\n            callback.call(binding, routeArray);\n          }\n        }\n      }\n    }\n\n    var $$route$recognizer$dsl$$default = function(callback, addRouteCallback) {\n      var matcher = new $$route$recognizer$dsl$$Matcher();\n\n      callback($$route$recognizer$dsl$$generateMatch(\"\", matcher, this.delegate));\n\n      $$route$recognizer$dsl$$eachRoute([], matcher, function(route) {\n        if (addRouteCallback) { addRouteCallback(this, route); }\n        else { this.add(route); }\n      }, this);\n    };\n\n    var $$route$recognizer$$specials = [\n      '/', '.', '*', '+', '?', '|',\n      '(', ')', '[', ']', '{', '}', '\\\\'\n    ];\n\n    var $$route$recognizer$$escapeRegex = new RegExp('(\\\\' + $$route$recognizer$$specials.join('|\\\\') + ')', 'g');\n\n    function $$route$recognizer$$isArray(test) {\n      return Object.prototype.toString.call(test) === \"[object Array]\";\n    }\n\n    // A Segment represents a segment in the original route description.\n    // Each Segment type provides an `eachChar` and `regex` method.\n    //\n    // The `eachChar` method invokes the callback with one or more character\n    // specifications. A character specification consumes one or more input\n    // characters.\n    //\n    // The `regex` method returns a regex fragment for the segment. If the\n    // segment is a dynamic of star segment, the regex fragment also includes\n    // a capture.\n    //\n    // A character specification contains:\n    //\n    // * `validChars`: a String with a list of all valid characters, or\n    // * `invalidChars`: a String with a list of all invalid characters\n    // * `repeat`: true if the character specification can repeat\n\n    function $$route$recognizer$$StaticSegment(string) { this.string = string; }\n    $$route$recognizer$$StaticSegment.prototype = {\n      eachChar: function(currentState) {\n        var string = this.string, ch;\n\n        for (var i=0; i<string.length; i++) {\n          ch = string.charAt(i);\n          currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: ch });\n        }\n\n        return currentState;\n      },\n\n      regex: function() {\n        return this.string.replace($$route$recognizer$$escapeRegex, '\\\\$1');\n      },\n\n      generate: function() {\n        return this.string;\n      }\n    };\n\n    function $$route$recognizer$$DynamicSegment(name) { this.name = name; }\n    $$route$recognizer$$DynamicSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState.put({ invalidChars: \"/\", repeat: true, validChars: undefined });\n      },\n\n      regex: function() {\n        return \"([^/]+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$StarSegment(name) { this.name = name; }\n    $$route$recognizer$$StarSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState.put({ invalidChars: \"\", repeat: true, validChars: undefined });\n      },\n\n      regex: function() {\n        return \"(.+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$EpsilonSegment() {}\n    $$route$recognizer$$EpsilonSegment.prototype = {\n      eachChar: function(currentState) {\n        return currentState;\n      },\n      regex: function() { return \"\"; },\n      generate: function() { return \"\"; }\n    };\n\n    function $$route$recognizer$$parse(route, names, specificity) {\n      // normalize route as not starting with a \"/\". Recognition will\n      // also normalize.\n      if (route.charAt(0) === \"/\") { route = route.substr(1); }\n\n      var segments = route.split(\"/\");\n      var results = new Array(segments.length);\n\n      // A routes has specificity determined by the order that its different segments\n      // appear in. This system mirrors how the magnitude of numbers written as strings\n      // works.\n      // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n      // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n      // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n      // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n      // leading symbol, \"1\".\n      // The rule is that symbols to the left carry more weight than symbols to the right\n      // when a number is written out as a string. In the above strings, the leading digit\n      // represents how many 100's are in the number, and it carries more weight than the middle\n      // number which represents how many 10's are in the number.\n      // This system of number magnitude works well for route specificity, too. A route written as\n      // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n      // `x`, irrespective of the other parts.\n      // Because of this similarity, we assign each type of segment a number value written as a\n      // string. We can find the specificity of compound routes by concatenating these strings\n      // together, from left to right. After we have looped through all of the segments,\n      // we convert the string to a number.\n      specificity.val = '';\n\n      for (var i=0; i<segments.length; i++) {\n        var segment = segments[i], match;\n\n        if (match = segment.match(/^:([^\\/]+)$/)) {\n          results[i] = new $$route$recognizer$$DynamicSegment(match[1]);\n          names.push(match[1]);\n          specificity.val += '3';\n        } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n          results[i] = new $$route$recognizer$$StarSegment(match[1]);\n          specificity.val += '1';\n          names.push(match[1]);\n        } else if(segment === \"\") {\n          results[i] = new $$route$recognizer$$EpsilonSegment();\n          specificity.val += '2';\n        } else {\n          results[i] = new $$route$recognizer$$StaticSegment(segment);\n          specificity.val += '4';\n        }\n      }\n\n      specificity.val = +specificity.val;\n\n      return results;\n    }\n\n    // A State has a character specification and (`charSpec`) and a list of possible\n    // subsequent states (`nextStates`).\n    //\n    // If a State is an accepting state, it will also have several additional\n    // properties:\n    //\n    // * `regex`: A regular expression that is used to extract parameters from paths\n    //   that reached this accepting state.\n    // * `handlers`: Information on how to convert the list of captures into calls\n    //   to registered handlers with the specified parameters\n    // * `types`: How many static, dynamic or star segments in this route. Used to\n    //   decide which route to use if multiple registered routes match a path.\n    //\n    // Currently, State is implemented naively by looping over `nextStates` and\n    // comparing a character specification against a character. A more efficient\n    // implementation would use a hash of keys pointing at one or more next states.\n\n    function $$route$recognizer$$State(charSpec) {\n      this.charSpec = charSpec;\n      this.nextStates = [];\n      this.charSpecs = {};\n      this.regex = undefined;\n      this.handlers = undefined;\n      this.specificity = undefined;\n    }\n\n    $$route$recognizer$$State.prototype = {\n      get: function(charSpec) {\n        if (this.charSpecs[charSpec.validChars]) {\n          return this.charSpecs[charSpec.validChars];\n        }\n\n        var nextStates = this.nextStates;\n\n        for (var i=0; i<nextStates.length; i++) {\n          var child = nextStates[i];\n\n          var isEqual = child.charSpec.validChars === charSpec.validChars;\n          isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n          if (isEqual) {\n            this.charSpecs[charSpec.validChars] = child;\n            return child;\n          }\n        }\n      },\n\n      put: function(charSpec) {\n        var state;\n\n        // If the character specification already exists in a child of the current\n        // state, just return that state.\n        if (state = this.get(charSpec)) { return state; }\n\n        // Make a new state for the character spec\n        state = new $$route$recognizer$$State(charSpec);\n\n        // Insert the new state as a child of the current state\n        this.nextStates.push(state);\n\n        // If this character specification repeats, insert the new state as a child\n        // of itself. Note that this will not trigger an infinite loop because each\n        // transition during recognition consumes a character.\n        if (charSpec.repeat) {\n          state.nextStates.push(state);\n        }\n\n        // Return the new state\n        return state;\n      },\n\n      // Find a list of child states matching the next character\n      match: function(ch) {\n        var nextStates = this.nextStates,\n            child, charSpec, chars;\n\n        var returned = [];\n\n        for (var i=0; i<nextStates.length; i++) {\n          child = nextStates[i];\n\n          charSpec = child.charSpec;\n\n          if (typeof (chars = charSpec.validChars) !== 'undefined') {\n            if (chars.indexOf(ch) !== -1) { returned.push(child); }\n          } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n            if (chars.indexOf(ch) === -1) { returned.push(child); }\n          }\n        }\n\n        return returned;\n      }\n    };\n\n    // Sort the routes by specificity\n    function $$route$recognizer$$sortSolutions(states) {\n      return states.sort(function(a, b) {\n        return b.specificity.val - a.specificity.val;\n      });\n    }\n\n    function $$route$recognizer$$recognizeChar(states, ch) {\n      var nextStates = [];\n\n      for (var i=0, l=states.length; i<l; i++) {\n        var state = states[i];\n\n        nextStates = nextStates.concat(state.match(ch));\n      }\n\n      return nextStates;\n    }\n\n    var $$route$recognizer$$oCreate = Object.create || function(proto) {\n      function F() {}\n      F.prototype = proto;\n      return new F();\n    };\n\n    function $$route$recognizer$$RecognizeResults(queryParams) {\n      this.queryParams = queryParams || {};\n    }\n    $$route$recognizer$$RecognizeResults.prototype = $$route$recognizer$$oCreate({\n      splice: Array.prototype.splice,\n      slice:  Array.prototype.slice,\n      push:   Array.prototype.push,\n      length: 0,\n      queryParams: null\n    });\n\n    function $$route$recognizer$$findHandler(state, path, queryParams) {\n      var handlers = state.handlers, regex = state.regex;\n      var captures = path.match(regex), currentCapture = 1;\n      var result = new $$route$recognizer$$RecognizeResults(queryParams);\n\n      result.length = handlers.length;\n\n      for (var i=0; i<handlers.length; i++) {\n        var handler = handlers[i], names = handler.names, params = {};\n\n        for (var j=0; j<names.length; j++) {\n          params[names[j]] = captures[currentCapture++];\n        }\n\n        result[i] = { handler: handler.handler, params: params, isDynamic: !!names.length };\n      }\n\n      return result;\n    }\n\n    function $$route$recognizer$$decodeQueryParamPart(part) {\n      // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n      part = part.replace(/\\+/gm, '%20');\n      var result;\n      try {\n        result = decodeURIComponent(part);\n      } catch(error) {result = '';}\n      return result;\n    }\n\n    // The main interface\n\n    var $$route$recognizer$$RouteRecognizer = function() {\n      this.rootState = new $$route$recognizer$$State();\n      this.names = {};\n    };\n\n\n    $$route$recognizer$$RouteRecognizer.prototype = {\n      add: function(routes, options) {\n        var currentState = this.rootState, regex = \"^\",\n            specificity = {},\n            handlers = new Array(routes.length), allSegments = [], name;\n\n        var isEmpty = true;\n\n        for (var i=0; i<routes.length; i++) {\n          var route = routes[i], names = [];\n\n          var segments = $$route$recognizer$$parse(route.path, names, specificity);\n\n          allSegments = allSegments.concat(segments);\n\n          for (var j=0; j<segments.length; j++) {\n            var segment = segments[j];\n\n            if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n            isEmpty = false;\n\n            // Add a \"/\" for the new segment\n            currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: \"/\" });\n            regex += \"/\";\n\n            // Add a representation of the segment to the NFA and regex\n            currentState = segment.eachChar(currentState);\n            regex += segment.regex();\n          }\n          var handler = { handler: route.handler, names: names };\n          handlers[i] = handler;\n        }\n\n        if (isEmpty) {\n          currentState = currentState.put({ invalidChars: undefined, repeat: false, validChars: \"/\" });\n          regex += \"/\";\n        }\n\n        currentState.handlers = handlers;\n        currentState.regex = new RegExp(regex + \"$\");\n        currentState.specificity = specificity;\n\n        if (name = options && options.as) {\n          this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n          };\n        }\n      },\n\n      handlersFor: function(name) {\n        var route = this.names[name];\n\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        var result = new Array(route.handlers.length);\n\n        for (var i=0; i<route.handlers.length; i++) {\n          result[i] = route.handlers[i];\n        }\n\n        return result;\n      },\n\n      hasRoute: function(name) {\n        return !!this.names[name];\n      },\n\n      generate: function(name, params) {\n        var route = this.names[name], output = \"\";\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        var segments = route.segments;\n\n        for (var i=0; i<segments.length; i++) {\n          var segment = segments[i];\n\n          if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n          output += \"/\";\n          output += segment.generate(params);\n        }\n\n        if (output.charAt(0) !== '/') { output = '/' + output; }\n\n        if (params && params.queryParams) {\n          output += this.generateQueryString(params.queryParams, route.handlers);\n        }\n\n        return output;\n      },\n\n      generateQueryString: function(params, handlers) {\n        var pairs = [];\n        var keys = [];\n        for(var key in params) {\n          if (params.hasOwnProperty(key)) {\n            keys.push(key);\n          }\n        }\n        keys.sort();\n        for (var i = 0; i < keys.length; i++) {\n          key = keys[i];\n          var value = params[key];\n          if (value == null) {\n            continue;\n          }\n          var pair = encodeURIComponent(key);\n          if ($$route$recognizer$$isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n              var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n              pairs.push(arrayPair);\n            }\n          } else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n          }\n        }\n\n        if (pairs.length === 0) { return ''; }\n\n        return \"?\" + pairs.join(\"&\");\n      },\n\n      parseQueryString: function(queryString) {\n        var pairs = queryString.split(\"&\"), queryParams = {};\n        for(var i=0; i < pairs.length; i++) {\n          var pair      = pairs[i].split('='),\n              key       = $$route$recognizer$$decodeQueryParamPart(pair[0]),\n              keyLength = key.length,\n              isArray = false,\n              value;\n          if (pair.length === 1) {\n            value = 'true';\n          } else {\n            //Handle arrays\n            if (keyLength > 2 && key.slice(keyLength -2) === '[]') {\n              isArray = true;\n              key = key.slice(0, keyLength - 2);\n              if(!queryParams[key]) {\n                queryParams[key] = [];\n              }\n            }\n            value = pair[1] ? $$route$recognizer$$decodeQueryParamPart(pair[1]) : '';\n          }\n          if (isArray) {\n            queryParams[key].push(value);\n          } else {\n            queryParams[key] = value;\n          }\n        }\n        return queryParams;\n      },\n\n      recognize: function(path) {\n        var states = [ this.rootState ],\n            pathLen, i, l, queryStart, queryParams = {},\n            isSlashDropped = false;\n\n        queryStart = path.indexOf('?');\n        if (queryStart !== -1) {\n          var queryString = path.substr(queryStart + 1, path.length);\n          path = path.substr(0, queryStart);\n          queryParams = this.parseQueryString(queryString);\n        }\n\n        path = decodeURI(path);\n\n        if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n\n        pathLen = path.length;\n        if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n          path = path.substr(0, pathLen - 1);\n          isSlashDropped = true;\n        }\n\n        for (i=0; i<path.length; i++) {\n          states = $$route$recognizer$$recognizeChar(states, path.charAt(i));\n          if (!states.length) { break; }\n        }\n\n        var solutions = [];\n        for (i=0; i<states.length; i++) {\n          if (states[i].handlers) { solutions.push(states[i]); }\n        }\n\n        states = $$route$recognizer$$sortSolutions(solutions);\n\n        var state = solutions[0];\n\n        if (state && state.handlers) {\n          // if a trailing slash was dropped and a star segment is the last segment\n          // specified, put the trailing slash back\n          if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n            path = path + \"/\";\n          }\n          return $$route$recognizer$$findHandler(state, path, queryParams);\n        }\n      }\n    };\n\n    $$route$recognizer$$RouteRecognizer.prototype.map = $$route$recognizer$dsl$$default;\n\n    $$route$recognizer$$RouteRecognizer.VERSION = '0.1.11';\n\n    var $$route$recognizer$$default = $$route$recognizer$$RouteRecognizer;\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define('route-recognizer', function() { return $$route$recognizer$$default; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = $$route$recognizer$$default;\n    } else if (typeof this !== 'undefined') {\n      this['RouteRecognizer'] = $$route$recognizer$$default;\n    }\n}).call(this);\n\n//# sourceMappingURL=route-recognizer.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/route-recognizer/dist/route-recognizer.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}