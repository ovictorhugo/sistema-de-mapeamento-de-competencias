import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/modules/drilldown.js
var require_drilldown = __commonJS({
  "node_modules/highcharts/modules/drilldown.js"(exports, module) {
    (function(a) {
      "object" === typeof module && module.exports ? (a["default"] = a, module.exports = a) : "function" === typeof define && define.amd ? define("highcharts/modules/drilldown", ["highcharts"], function(l) {
        a(l);
        a.Highcharts = l;
        return a;
      }) : a("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(a) {
      function l(a2, k, p, l2) {
        a2.hasOwnProperty(k) || (a2[k] = l2.apply(null, p), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: k, module: a2[k] } })));
      }
      a = a ? a._modules : {};
      l(a, "Extensions/Breadcrumbs/BreadcrumbsDefaults.js", [], function() {
        return { lang: { mainBreadcrumb: "Main" }, options: { buttonTheme: { fill: "none", height: 18, padding: 2, "stroke-width": 0, zIndex: 7, states: { select: { fill: "none" } }, style: { color: "#334eff" } }, buttonSpacing: 5, floating: false, format: void 0, relativeTo: "plotBox", rtl: false, position: { align: "left", verticalAlign: "top", x: 0, y: void 0 }, separator: { text: "/", style: { color: "#666666", fontSize: "0.8em" } }, showFullPath: true, style: {}, useHTML: false, zIndex: 7 } };
      });
      l(
        a,
        "Extensions/Breadcrumbs/Breadcrumbs.js",
        [a["Extensions/Breadcrumbs/BreadcrumbsDefaults.js"], a["Core/Chart/Chart.js"], a["Core/Templating.js"], a["Core/Utilities.js"]],
        function(a2, k, p, l2) {
          function t() {
            if (this.breadcrumbs) {
              const f = this.resetZoomButton && this.resetZoomButton.getBBox(), d = this.breadcrumbs.options;
              f && "right" === d.position.align && "plotBox" === d.relativeTo && this.breadcrumbs.alignBreadcrumbsGroup(-f.width - d.buttonSpacing);
            }
          }
          function G() {
            this.breadcrumbs && (this.breadcrumbs.destroy(), this.breadcrumbs = void 0);
          }
          function H() {
            const f = this.breadcrumbs;
            if (f && !f.options.floating && f.level) {
              var d = f.options, g = d.buttonTheme;
              g = (g.height || 0) + 2 * (g.padding || 0) + d.buttonSpacing;
              d = d.position.verticalAlign;
              "bottom" === d ? (this.marginBottom = (this.marginBottom || 0) + g, f.yOffset = g) : "middle" !== d ? (this.plotTop += g, f.yOffset = -g) : f.yOffset = void 0;
            }
          }
          function w() {
            this.breadcrumbs && this.breadcrumbs.redraw();
          }
          function D(f) {
            true === f.resetSelection && this.breadcrumbs && this.breadcrumbs.alignBreadcrumbsGroup();
          }
          const { format: I } = p, {
            addEvent: x,
            defined: E,
            extend: y,
            fireEvent: F,
            isString: R,
            merge: r,
            objectEach: L,
            pick: u
          } = l2, h = [];
          class C {
            static compose(f, d) {
              l2.pushUnique(h, f) && (x(k, "destroy", G), x(k, "afterShowResetZoom", t), x(k, "getMargins", H), x(k, "redraw", w), x(k, "selection", D));
              l2.pushUnique(h, d) && y(d.lang, a2.lang);
            }
            constructor(f, d) {
              this.elementList = {};
              this.isDirty = true;
              this.level = 0;
              this.list = [];
              d = r(f.options.drilldown && f.options.drilldown.drillUpButton, C.defaultOptions, f.options.navigation && f.options.navigation.breadcrumbs, d);
              this.chart = f;
              this.options = d || {};
            }
            updateProperties(f) {
              this.setList(f);
              this.setLevel();
              this.isDirty = true;
            }
            setList(f) {
              this.list = f;
            }
            setLevel() {
              this.level = this.list.length && this.list.length - 1;
            }
            getLevel() {
              return this.level;
            }
            getButtonText(f) {
              const d = this.chart, g = this.options;
              var a3 = d.options.lang;
              const h2 = u(g.format, g.showFullPath ? "{level.name}" : "← {level.name}");
              a3 = a3 && u(a3.drillUpText, a3.mainBreadcrumb);
              f = g.formatter && g.formatter(f) || I(h2, { level: f.levelOptions }, d) || "";
              (R(f) && !f.length || "← " === f) && E(a3) && (f = g.showFullPath ? a3 : "← " + a3);
              return f;
            }
            redraw() {
              this.isDirty && this.render();
              this.group && this.group.align();
              this.isDirty = false;
            }
            render() {
              const f = this.chart, d = this.options;
              !this.group && d && (this.group = f.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({ zIndex: d.zIndex }).add());
              d.showFullPath ? this.renderFullPathButtons() : this.renderSingleButton();
              this.alignBreadcrumbsGroup();
            }
            renderFullPathButtons() {
              this.destroySingleButton();
              this.resetElementListState();
              this.updateListElements();
              this.destroyListElements();
            }
            renderSingleButton() {
              const f = this.chart;
              var d = this.list;
              const g = this.options.buttonSpacing;
              this.destroyListElements();
              const a3 = this.group ? this.group.getBBox().width : g;
              d = d[d.length - 2];
              !f.drillUpButton && 0 < this.level ? f.drillUpButton = this.renderButton(d, a3, g) : f.drillUpButton && (0 < this.level ? this.updateSingleButton() : this.destroySingleButton());
            }
            alignBreadcrumbsGroup(f) {
              if (this.group) {
                var d = this.options;
                const a3 = d.buttonTheme, h2 = d.position, q = "chart" === d.relativeTo || "spacingBox" === d.relativeTo ? void 0 : "scrollablePlotBox";
                var g = this.group.getBBox();
                d = 2 * (a3.padding || 0) + d.buttonSpacing;
                h2.width = g.width + d;
                h2.height = g.height + d;
                g = r(h2);
                f && (g.x += f);
                this.options.rtl && (g.x += h2.width);
                g.y = u(g.y, this.yOffset, 0);
                this.group.align(g, true, q);
              }
            }
            renderButton(f, d, g) {
              const a3 = this, h2 = this.chart, q = a3.options, k2 = r(q.buttonTheme);
              d = h2.renderer.button(a3.getButtonText(f), d, g, function(d2) {
                const g2 = q.events && q.events.click;
                let h3;
                g2 && (h3 = g2.call(a3, d2, f));
                false !== h3 && (d2.newLevel = q.showFullPath ? f.level : a3.level - 1, F(a3, "up", d2));
              }, k2).addClass("highcharts-breadcrumbs-button").add(a3.group);
              h2.styledMode || d.attr(q.style);
              return d;
            }
            renderSeparator(f, d) {
              const a3 = this.chart, h2 = this.options.separator;
              f = a3.renderer.label(h2.text, f, d, void 0, void 0, void 0, false).addClass("highcharts-breadcrumbs-separator").add(this.group);
              a3.styledMode || f.css(h2.style);
              return f;
            }
            update(f) {
              r(true, this.options, f);
              this.destroy();
              this.isDirty = true;
            }
            updateSingleButton() {
              const f = this.chart, d = this.list[this.level - 1];
              f.drillUpButton && f.drillUpButton.attr({ text: this.getButtonText(d) });
            }
            destroy() {
              this.destroySingleButton();
              this.destroyListElements(true);
              this.group && this.group.destroy();
              this.group = void 0;
            }
            destroyListElements(f) {
              const d = this.elementList;
              L(d, (a3, h2) => {
                if (f || !d[h2].updated)
                  a3 = d[h2], a3.button && a3.button.destroy(), a3.separator && a3.separator.destroy(), delete a3.button, delete a3.separator, delete d[h2];
              });
              f && (this.elementList = {});
            }
            destroySingleButton() {
              this.chart.drillUpButton && (this.chart.drillUpButton.destroy(), this.chart.drillUpButton = void 0);
            }
            resetElementListState() {
              L(this.elementList, (a3) => {
                a3.updated = false;
              });
            }
            updateListElements() {
              const a3 = this.elementList, d = this.options.buttonSpacing, g = this.list, h2 = this.options.rtl, k2 = h2 ? -1 : 1, q = function(a4, d2) {
                return k2 * a4.getBBox().width + k2 * d2;
              }, p2 = function(a4, d2, c) {
                a4.translate(d2 - a4.getBBox().width, c);
              };
              let l3 = this.group ? q(this.group, d) : d, t2, r2;
              for (let f = 0, u2 = g.length; f < u2; ++f) {
                const c = f === u2 - 1;
                let b, e;
                r2 = g[f];
                a3[r2.level] ? (t2 = a3[r2.level], b = t2.button, t2.separator || c ? t2.separator && c && (t2.separator.destroy(), delete t2.separator) : (l3 += k2 * d, t2.separator = this.renderSeparator(l3, d), h2 && p2(t2.separator, l3, d), l3 += q(t2.separator, d)), a3[r2.level].updated = true) : (b = this.renderButton(
                  r2,
                  l3,
                  d
                ), h2 && p2(b, l3, d), l3 += q(b, d), c || (e = this.renderSeparator(l3, d), h2 && p2(e, l3, d), l3 += q(e, d)), a3[r2.level] = { button: b, separator: e, updated: true });
                b && b.setState(c ? 2 : 0);
              }
            }
          }
          C.defaultOptions = a2.options;
          "";
          return C;
        }
      );
      l(a, "Extensions/Drilldown.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Chart/Chart.js"],
        a["Core/Color/Color.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Core/Globals.js"],
        a["Core/Defaults.js"],
        a["Core/Series/Point.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Axis/Tick.js"],
        a["Core/Utilities.js"],
        a["Extensions/Breadcrumbs/Breadcrumbs.js"]
      ], function(a2, l2, p, Q, B, G, H, w, D, I, x, E, y, F) {
        function k(c) {
          const b = r(this.chart.options.drilldown.animation);
          c && (c.hide(), M(function() {
            c && c.added && c.fadeIn();
          }, Math.max(b.duration - 50, 0)));
        }
        const { animObject: r } = a2, { noop: t } = G, { defaultOptions: u } = H;
        ({ seriesTypes: a2 } = I);
        const { addEvent: h, defined: C, diffObjects: f, extend: d, fireEvent: g, merge: z, objectEach: S, pick: q, removeEvent: T, syncTimeout: M } = y;
        y = a2.pie;
        a2 = a2.map;
        let N = 1;
        d(u.lang, {});
        u.drilldown = { activeAxisLabelStyle: { cursor: "pointer", color: "#0022ff", fontWeight: "bold", textDecoration: "underline" }, activeDataLabelStyle: { cursor: "pointer", color: "#0022ff", fontWeight: "bold", textDecoration: "underline" }, animation: { duration: 500 }, drillUpButton: { position: { align: "right", x: -10, y: 10 } }, mapZooming: true };
        x.prototype.Element.prototype.fadeIn = function(c) {
          this.attr({ opacity: 0.1, visibility: "inherit" }).animate({ opacity: q(this.newOpacity, 1) }, c || { duration: 250 });
        };
        p.prototype.addSeriesAsDrilldown = function(c, b) {
          const e = this;
          if (e.mapView) {
            c.series.isDrilling = true;
            e.series.forEach((b2) => {
              var c2;
              b2.options.inactiveOtherPoints = true;
              null === (c2 = b2.dataLabelsGroup) || void 0 === c2 ? void 0 : c2.destroy();
              delete b2.dataLabelsGroup;
            });
            if (e.options.drilldown && !e.mapView.projection.hasGeoProjection && u.drilldown) {
              var a3 = f(e.options.drilldown, u.drilldown);
              C(a3.mapZooming) || (e.options.drilldown.mapZooming = false);
            }
            if (e.options.drilldown && e.options.drilldown.animation && e.options.drilldown.mapZooming) {
              e.mapView.allowTransformAnimation = true;
              a3 = r(e.options.drilldown.animation);
              if ("boolean" !== typeof a3) {
                const d2 = a3.complete, n = function(a4) {
                  a4 && a4.applyDrilldown && e.mapView && (e.addSingleSeriesAsDrilldown(c, b), e.applyDrilldown(), e.mapView.allowTransformAnimation = false);
                };
                a3.complete = function() {
                  d2 && d2.apply(this, arguments);
                  n.apply(this, arguments);
                };
              }
              c.zoomTo(a3);
            } else
              e.addSingleSeriesAsDrilldown(c, b), e.applyDrilldown();
          } else
            e.addSingleSeriesAsDrilldown(c, b), e.applyDrilldown();
        };
        p.prototype.addSingleSeriesAsDrilldown = function(c, b) {
          let e = c.series, a3 = e.xAxis, A = e.yAxis, f2, g2 = [], h2 = [], v, m, l3;
          l3 = this.styledMode ? { colorIndex: q(c.colorIndex, e.colorIndex) } : { color: c.color || e.color };
          this.drilldownLevels || (this.drilldownLevels = []);
          v = e.options._levelNumber || 0;
          (m = this.drilldownLevels[this.drilldownLevels.length - 1]) && m.levelNumber !== v && (m = void 0);
          b = d(d({ _ddSeriesId: N++ }, l3), b);
          f2 = e.points.indexOf(c);
          e.chart.series.forEach(function(b2) {
            b2.xAxis === a3 && (b2.options._ddSeriesId = b2.options._ddSeriesId || N++, b2.options.colorIndex = b2.colorIndex, b2.options._levelNumber = b2.options._levelNumber || v, m ? (g2 = m.levelSeries, h2 = m.levelSeriesOptions) : (g2.push(b2), b2.purgedOptions = z({ _ddSeriesId: b2.options._ddSeriesId, _levelNumber: b2.options._levelNumber, selected: b2.options.selected }, b2.userOptions), h2.push(b2.purgedOptions)));
          });
          c = d({
            levelNumber: v,
            seriesOptions: e.options,
            seriesPurgedOptions: e.purgedOptions,
            levelSeriesOptions: h2,
            levelSeries: g2,
            shapeArgs: c.shapeArgs,
            bBox: c.graphic ? c.graphic.getBBox() : {},
            color: c.isNull ? Q.parse(l3.color).setOpacity(0).get() : l3.color,
            lowerSeriesOptions: b,
            pointOptions: e.options.data[f2],
            pointIndex: f2,
            oldExtremes: { xMin: a3 && a3.userMin, xMax: a3 && a3.userMax, yMin: A && A.userMin, yMax: A && A.userMax },
            resetZoomButton: m && m.levelNumber === v ? void 0 : this.resetZoomButton
          }, l3);
          this.drilldownLevels.push(c);
          a3 && a3.names && (a3.names.length = 0);
          b = c.lowerSeries = this.addSeries(b, false);
          b.options._levelNumber = v + 1;
          a3 && (a3.oldPos = a3.pos, a3.userMin = a3.userMax = null, A.userMin = A.userMax = null);
          b.isDrilling = true;
          e.type === b.type && (b.animate = b.animateDrilldown || t, b.options.animation = true);
        };
        p.prototype.applyDrilldown = function() {
          const c = this, b = this.drilldownLevels;
          let e;
          b && 0 < b.length && (e = b[b.length - 1].levelNumber, this.drilldownLevels.forEach(function(b2) {
            c.mapView && c.options.drilldown && c.options.drilldown.mapZooming && (c.redraw(), b2.lowerSeries.isDrilling = false, c.mapView.fitToBounds(b2.lowerSeries.bounds), b2.lowerSeries.isDrilling = true);
            b2.levelNumber === e && b2.levelSeries.forEach(function(a3, d2) {
              c.mapView ? a3.options && a3.options._levelNumber === e && a3.group && (d2 = {}, c.options.drilldown && (d2 = c.options.drilldown.animation), a3.group.animate({ opacity: 0 }, d2, function() {
                a3.remove(false);
                b2.levelSeries.filter((b3) => Object.keys(b3).length).length || (c.resetZoomButton && (c.resetZoomButton.hide(), delete c.resetZoomButton), c.pointer.reset(), g(c, "afterDrilldown"), c.mapView && (c.series.forEach((b3) => {
                  b3.isDirtyData = true;
                  b3.isDrilling = false;
                }), c.mapView.fitToBounds(void 0, void 0)), g(c, "afterApplyDrilldown"));
              })) : a3.options && a3.options._levelNumber === e && a3.remove(false);
            });
          }));
          c.mapView || (this.resetZoomButton && (this.resetZoomButton.hide(), delete this.resetZoomButton), this.pointer.reset(), g(this, "afterDrilldown"), this.redraw(), g(this, "afterApplyDrilldown"));
        };
        const O = function(c) {
          const b = [];
          (c = c.drilldownLevels) && c.length && (b[0] || b.push({ level: 0, levelOptions: c[0].seriesOptions }), c.forEach(function(c2, a3) {
            c2.levelNumber + 1 > b[b.length - 1].level && b.push({ level: c2.levelNumber + 1, levelOptions: z({ name: c2.lowerSeries.name }, c2.pointOptions) });
          }));
          return b;
        };
        p.prototype.drillUp = function(c) {
          if (this.drilldownLevels && 0 !== this.drilldownLevels.length) {
            g(this, "beforeDrillUp");
            for (var b = this, a3 = b.drilldownLevels, d2 = a3[a3.length - 1].levelNumber, f2 = b.series, h2 = b.drilldownLevels.length, l3 = function(c2, a4) {
              let e;
              f2.forEach(function(b2) {
                b2.options._ddSeriesId === c2._ddSeriesId && (e = b2);
              });
              e = e || b.addSeries(c2, false);
              e.type === a4.type && e.animateDrillupTo && (e.animate = e.animateDrillupTo);
              if (c2 === k2.seriesPurgedOptions)
                return e;
            }, K = (c2) => {
              c2.remove(false);
              b.series.forEach((b2) => {
                b2.colorAxis && (b2.isDirtyData = true);
                b2.options.inactiveOtherPoints = false;
              });
              b.redraw();
            }, v = a3.length, m, k2; v--; ) {
              let e, n;
              k2 = a3[v];
              if (k2.levelNumber === d2) {
                a3.pop();
                e = k2.lowerSeries;
                if (!e.chart) {
                  for (m = f2.length; m--; )
                    if (f2[m].options.id === k2.lowerSeriesOptions.id && f2[m].options._levelNumber === d2 + 1) {
                      e = f2[m];
                      break;
                    }
                }
                e.xData = [];
                e.xAxis && e.xAxis.names && (0 === h2 || v === h2) && (e.xAxis.names.length = 0);
                k2.levelSeriesOptions.forEach((b2) => {
                  (b2 = l3(b2, e)) && (n = b2);
                });
                g(b, "drillup", { seriesOptions: k2.seriesPurgedOptions || k2.seriesOptions });
                n && (n.type === e.type && (n.drilldownLevel = k2, n.options.animation = b.options.drilldown.animation, e.animateDrillupFrom && e.chart && e.animateDrillupFrom(k2)), n.options._levelNumber = d2);
                m = e;
                b.mapView || m.remove(false);
                n && n.xAxis && (m = k2.oldExtremes, n.xAxis.setExtremes(
                  m.xMin,
                  m.xMax,
                  false
                ), n.yAxis.setExtremes(m.yMin, m.yMax, false));
                k2.resetZoomButton && (b.resetZoomButton = k2.resetZoomButton);
                this.mapView ? (m = b.options.drilldown && b.options.drilldown.animation && b.options.drilldown.mapZooming, k2.levelNumber === d2 && c ? e.remove(false) : (e.dataLabelsGroup && (e.dataLabelsGroup.destroy(), delete e.dataLabelsGroup), b.mapView && n && (m && (e.isDrilling = true, n.isDrilling = true, b.redraw(false), b.mapView.fitToBounds(e.bounds, void 0, true, false)), b.mapView.allowTransformAnimation = true, g(b, "afterDrillUp", { seriesOptions: n ? n.userOptions : void 0 }), m ? b.mapView.setView(void 0, 1, true, { complete: function() {
                  Object.prototype.hasOwnProperty.call(this, "complete") && K(e);
                } }) : (b.mapView.allowTransformAnimation = false, e.group ? e.group.animate({ opacity: 0 }, b.options.drilldown.animation, function() {
                  K(e);
                  b.mapView && (b.mapView.allowTransformAnimation = true);
                }) : (K(e), b.mapView.allowTransformAnimation = true)), n.isDrilling = false, b.ddDupes && (b.ddDupes.length = 0), g(b, "drillupall")))) : (g(b, "afterDrillUp"), this.redraw(), this.ddDupes && (this.ddDupes.length = 0), g(b, "drillupall"));
              }
            }
          }
        };
        h(p, "afterInit", function() {
          const c = this;
          c.drilldown = { chart: c, fadeInGroup: k, update: function(b, e) {
            z(true, c.options.drilldown, b);
            q(e, true) && c.redraw();
          } };
        });
        h(p, "render", function() {
          (this.xAxis || []).forEach(function(c) {
            c.ddPoints = {};
            c.series.forEach(function(b) {
              let e, a3 = b.xData || [], d2 = b.points;
              for (e = 0; e < a3.length; e++) {
                var f2 = b.options.data[e];
                "number" !== typeof f2 && (f2 = b.pointClass.prototype.optionsToObject.call({ series: b }, f2), f2.drilldown && (c.ddPoints[a3[e]] || (c.ddPoints[a3[e]] = []), f2 = e - (b.cropStart || 0), c.ddPoints[a3[e]].push(d2 && 0 <= f2 && f2 < d2.length ? d2[f2] : true)));
              }
            });
            S(c.ticks, E.prototype.drillable);
          });
        });
        h(F, "up", function(c) {
          const b = this.chart;
          c = this.getLevel() - c.newLevel;
          let e = 1 < c;
          for (let a3 = 0; a3 < c; a3++)
            a3 === c - 1 && (e = false), b.drillUp(e);
        });
        h(p, "afterDrilldown", function() {
          var c = this.options.drilldown;
          c = c && c.breadcrumbs;
          this.breadcrumbs || (this.breadcrumbs = new F(this, c));
          this.breadcrumbs.updateProperties(O(this));
        });
        h(p, "afterDrillUp", function() {
          this.breadcrumbs && this.breadcrumbs.updateProperties(O(this));
        });
        h(p, "update", function(c) {
          const b = this.breadcrumbs, a3 = c.options.drilldown && c.options.drilldown.breadcrumbs;
          b && a3 && b.update(c.options.drilldown.breadcrumbs);
        });
        B.prototype.animateDrillupTo = function(c) {
          if (!c) {
            const b = this, c2 = b.drilldownLevel;
            this.points.forEach(function(b2) {
              const c3 = b2.dataLabel;
              b2.graphic && b2.graphic.hide();
              c3 && (c3.hidden = "hidden" === c3.attr("visibility"), c3.hidden || (c3.hide(), b2.connector && b2.connector.hide()));
            });
            M(function() {
              if (b.points) {
                let a3 = [];
                b.data.forEach(function(b2) {
                  a3.push(b2);
                });
                b.nodes && (a3 = a3.concat(b.nodes));
                a3.forEach(function(b2, a4) {
                  a4 = a4 === (c2 && c2.pointIndex) ? "show" : "fadeIn";
                  const e = "show" === a4 ? true : void 0, d2 = b2.dataLabel;
                  if (b2.graphic && b2.visible)
                    b2.graphic[a4](e);
                  d2 && !d2.hidden && (d2.fadeIn(), b2.connector && b2.connector.fadeIn());
                });
              }
            }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));
            delete this.animate;
          }
        };
        B.prototype.animateDrilldown = function(c) {
          let b = this, a3 = this.chart, f2 = a3.drilldownLevels, g2, h2 = r(a3.options.drilldown.animation), k2 = this.xAxis, l3 = a3.styledMode;
          c || (f2.forEach(function(a4) {
            b.options._ddSeriesId === a4.lowerSeriesOptions._ddSeriesId && (g2 = a4.shapeArgs, l3 || (g2.fill = a4.color));
          }), g2.x += q(k2.oldPos, k2.pos) - k2.pos, this.points.forEach(function(a4) {
            const c2 = a4.shapeArgs;
            l3 || (c2.fill = a4.color);
            a4.graphic && a4.graphic.attr(g2).animate(d(a4.shapeArgs, { fill: a4.color || b.color }), h2);
          }), a3.drilldown && a3.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate);
        };
        B.prototype.animateDrillupFrom = function(a3) {
          let b = r(this.chart.options.drilldown.animation), c = this.group, d2 = c !== this.chart.columnGroup, f2 = this;
          f2.trackerGroups.forEach(function(b2) {
            if (f2[b2])
              f2[b2].on("mouseover");
          });
          d2 && delete this.group;
          this.points.forEach(function(e) {
            const g2 = e.graphic, h2 = a3.shapeArgs, n = function() {
              g2.destroy();
              c && d2 && (c = c.destroy());
            };
            g2 && h2 && (delete e.graphic, f2.chart.styledMode || (h2.fill = a3.color), b.duration ? g2.animate(h2, z(b, { complete: n })) : (g2.attr(h2), n()));
          });
        };
        y && d(y.prototype, { animateDrillupTo: B.prototype.animateDrillupTo, animateDrillupFrom: B.prototype.animateDrillupFrom, animateDrilldown: function(a3) {
          const b = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], c = this.chart.options.drilldown.animation;
          this.is("item") && (c.duration = 0);
          if (this.center) {
            const e = b.shapeArgs, d2 = e.start, f2 = (e.end - d2) / this.points.length, g2 = this.chart.styledMode;
            a3 || (this.points.forEach(function(a4, h2) {
              const n = a4.shapeArgs;
              g2 || (e.fill = b.color, n.fill = a4.color);
              if (a4.graphic)
                a4.graphic.attr(z(e, { start: d2 + h2 * f2, end: d2 + (h2 + 1) * f2 }))[c ? "animate" : "attr"](n, c);
            }), this.chart.drilldown && this.chart.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate);
          }
        } });
        a2 && d(a2.prototype, { animateDrilldown(a3) {
          const b = this, c = this.chart, d2 = this.group;
          c && d2 && b.options && (a3 && c.mapView ? (d2.attr({ opacity: 0.01 }), c.mapView.allowTransformAnimation = false, b.options.inactiveOtherPoints = true, b.options.enableMouseTracking = false) : (d2.animate({ opacity: 1 }, c.options.drilldown.animation, function() {
            b.options && (b.options.inactiveOtherPoints = false, b.options.enableMouseTracking = q(b.userOptions && b.userOptions.enableMouseTracking, true), b.isDirty = true, c.redraw());
          }), c.drilldown && c.drilldown.fadeInGroup(this.dataLabelsGroup)));
        }, animateDrillupFrom() {
          const a3 = this.chart;
          a3 && a3.mapView && (a3.mapView.allowTransformAnimation = false);
          this.options && (this.options.inactiveOtherPoints = true);
        }, animateDrillupTo(a3) {
          const b = this.chart, c = this.group;
          b && c && (a3 ? (c.attr({ opacity: 0.01 }), this.options && (this.options.inactiveOtherPoints = true)) : (c.animate({ opacity: 1 }, b.options.drilldown.animation), b.drilldown && b.drilldown.fadeInGroup(this.dataLabelsGroup)));
        } });
        w.prototype.doDrilldown = function() {
          this.runDrilldown();
        };
        w.prototype.runDrilldown = function(a3, b, e) {
          const c = this.series.chart, d2 = c.options.drilldown;
          let f2 = (d2.series || []).length, h2;
          c.ddDupes || (c.ddDupes = []);
          for (; f2-- && !h2; )
            d2.series[f2].id === this.drilldown && -1 === c.ddDupes.indexOf(this.drilldown) && (h2 = d2.series[f2], c.ddDupes.push(this.drilldown));
          g(c, "drilldown", { point: this, seriesOptions: h2, category: b, originalEvent: e, points: "undefined" !== typeof b && this.series.xAxis.getDDPoints(b).slice(0) }, function(b2) {
            const c2 = b2.point.series && b2.point.series.chart, e2 = b2.seriesOptions;
            c2 && e2 && (a3 ? c2.addSingleSeriesAsDrilldown(b2.point, e2) : c2.addSeriesAsDrilldown(b2.point, e2));
          });
        };
        l2.prototype.drilldownCategory = function(a3, b) {
          this.getDDPoints(a3).forEach(function(c) {
            c && c.series && c.series.visible && c.runDrilldown && c.runDrilldown(true, a3, b);
          });
          this.chart.applyDrilldown();
        };
        l2.prototype.getDDPoints = function(a3) {
          return this.ddPoints && this.ddPoints[a3] || [];
        };
        E.prototype.drillable = function() {
          const a3 = this.pos, b = this.label, e = this.axis, d2 = "xAxis" === e.coll && e.getDDPoints, f2 = d2 && e.getDDPoints(a3), g2 = e.chart.styledMode;
          d2 && (b && f2 && f2.length ? (b.drillable = true, b.basicStyles || g2 || (b.basicStyles = z(b.styles)), b.addClass("highcharts-drilldown-axis-label"), b.removeOnDrillableClick && T(b.element, "click"), b.removeOnDrillableClick = h(b.element, "click", function(b2) {
            b2.preventDefault();
            e.drilldownCategory(a3, b2);
          }), g2 || b.css(e.chart.options.drilldown.activeAxisLabelStyle)) : b && b.drillable && b.removeOnDrillableClick && (g2 || (b.styles = {}, b.element.removeAttribute("style"), b.css(b.basicStyles)), b.removeOnDrillableClick(), b.removeClass("highcharts-drilldown-axis-label")));
        };
        h(w, "afterInit", function() {
          this.drilldown && !this.unbindDrilldownClick && (this.unbindDrilldownClick = h(this, "click", P));
          return this;
        });
        h(w, "update", function(a3) {
          a3 = a3.options || {};
          a3.drilldown && !this.unbindDrilldownClick ? this.unbindDrilldownClick = h(this, "click", P) : !a3.drilldown && void 0 !== a3.drilldown && this.unbindDrilldownClick && (this.unbindDrilldownClick = this.unbindDrilldownClick());
        });
        const P = function(a3) {
          const b = this.series;
          b.xAxis && false === b.chart.options.drilldown.allowPointDrilldown ? b.xAxis.drilldownCategory(this.x, a3) : this.runDrilldown(void 0, void 0, a3);
        };
        h(D, "afterDrawDataLabels", function() {
          const a3 = this.chart.options.drilldown.activeDataLabelStyle, b = this.chart.renderer, d2 = this.chart.styledMode;
          this.points.forEach(function(c) {
            const e = c.options.dataLabels, f2 = q(c.dlOptions, e && e.style, {});
            c.drilldown && c.dataLabel && ("contrast" !== a3.color || d2 || (f2.color = b.getContrast(c.color || this.color)), e && e.color && (f2.color = e.color), c.dataLabel.addClass("highcharts-drilldown-data-label"), d2 || c.dataLabel.css(a3).css(f2));
          }, this);
        });
        const J = function(a3, b, d2, f2) {
          a3[d2 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
          f2 || a3.css({ cursor: b });
        };
        h(D, "afterDrawTracker", function() {
          const a3 = this.chart.styledMode;
          this.points.forEach(function(b) {
            b.drilldown && b.graphic && J(b.graphic, "pointer", true, a3);
          });
        });
        h(w, "afterSetState", function() {
          const a3 = this.series.chart.styledMode;
          this.drilldown && this.series.halo && "hover" === this.state ? J(this.series.halo, "pointer", true, a3) : this.series.halo && J(this.series.halo, "auto", false, a3);
        });
        h(p, "drillup", function() {
          this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy());
        });
        h(p, "drillupall", function() {
          this.resetZoomButton && this.showResetZoom();
        });
      });
      l(
        a,
        "masters/modules/drilldown.src.js",
        [a["Core/Globals.js"], a["Extensions/Breadcrumbs/Breadcrumbs.js"]],
        function(a2, k) {
          a2.Breadcrumbs = k;
          k.compose(a2.Chart, a2.defaultOptions);
        }
      );
    });
  }
});
export default require_drilldown();
//# sourceMappingURL=highcharts_modules_drilldown.js.map
