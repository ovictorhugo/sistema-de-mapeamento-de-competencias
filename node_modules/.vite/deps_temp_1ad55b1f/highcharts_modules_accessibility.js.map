{
  "version": 3,
  "sources": ["../../highcharts/modules/accessibility.src.js"],
  "sourcesContent": ["/**\n * @license Highcharts JS v11.1.0 (2023-06-05)\n *\n * Accessibility module\n *\n * (c) 2010-2021 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/accessibility', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Accessibility/Utils/HTMLUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Utility functions for accessibility module.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, win } = H;\n        const { css } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const simulatedEventTarget = win.EventTarget && new win.EventTarget() || 'none';\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         * @param {Highcharts.HTMLDOMElement} el\n         * @param {string} className\n         * @return {void}\n         */\n        function addClass(el, className) {\n            if (el.classList) {\n                el.classList.add(className);\n            }\n            else if (el.className.indexOf(className) < 0) {\n                // Note: Dumb check for class name exists, should be fine for practical\n                // use cases, but will return false positives if the element has a class\n                // that contains the className.\n                el.className += ' ' + className;\n            }\n        }\n        /**\n         * @private\n         * @param {Highcharts.HTMLDOMElement} el\n         * @param {string} className\n         * @return {void}\n         */\n        function removeClass(el, className) {\n            if (el.classList) {\n                el.classList.remove(className);\n            }\n            else {\n                // Note: Dumb logic that will break if the element has a class name that\n                // consists of className plus something else.\n                el.className = el.className.replace(new RegExp(className, 'g'), '');\n            }\n        }\n        /**\n         * Utility function to clone a mouse event for re-dispatching.\n         * @private\n         */\n        function cloneMouseEvent(e) {\n            if (typeof win.MouseEvent === 'function') {\n                return new win.MouseEvent(e.type, e);\n            }\n            // No MouseEvent support, try using initMouseEvent\n            if (doc.createEvent) {\n                const evt = doc.createEvent('MouseEvent');\n                if (evt.initMouseEvent) {\n                    evt.initMouseEvent(e.type, e.bubbles, // #10561, #12161\n                    e.cancelable, e.view || win, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n                    return evt;\n                }\n            }\n            return getFakeMouseEvent(e.type);\n        }\n        /**\n         * Utility function to clone a touch event for re-dispatching.\n         * @private\n         */\n        function cloneTouchEvent(e) {\n            const touchListToTouchArray = (l) => {\n                const touchArray = [];\n                for (let i = 0; i < l.length; ++i) {\n                    const item = l.item(i);\n                    if (item) {\n                        touchArray.push(item);\n                    }\n                }\n                return touchArray;\n            };\n            if (typeof win.TouchEvent === 'function') {\n                const newEvent = new win.TouchEvent(e.type, {\n                    touches: touchListToTouchArray(e.touches),\n                    targetTouches: touchListToTouchArray(e.targetTouches),\n                    changedTouches: touchListToTouchArray(e.changedTouches),\n                    ctrlKey: e.ctrlKey,\n                    shiftKey: e.shiftKey,\n                    altKey: e.altKey,\n                    metaKey: e.metaKey,\n                    bubbles: e.bubbles,\n                    cancelable: e.cancelable,\n                    composed: e.composed,\n                    detail: e.detail,\n                    view: e.view\n                });\n                if (e.defaultPrevented) {\n                    newEvent.preventDefault();\n                }\n                return newEvent;\n            }\n            const fakeEvt = cloneMouseEvent(e);\n            fakeEvt.touches = e.touches;\n            fakeEvt.changedTouches = e.changedTouches;\n            fakeEvt.targetTouches = e.targetTouches;\n            return fakeEvt;\n        }\n        /**\n         * @private\n         */\n        function escapeStringForHTML(str) {\n            return str\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n                .replace(/\"/g, '&quot;')\n                .replace(/'/g, '&#x27;')\n                .replace(/\\//g, '&#x2F;');\n        }\n        /**\n         * Get an element by ID\n         * @private\n         */\n        function getElement(id) {\n            return doc.getElementById(id);\n        }\n        /**\n         * Get a fake mouse event of a given type. If relatedTarget is not given,\n         * it will point to simulatedEventTarget, as an indicator that the event\n         * is fake.\n         * @private\n         */\n        function getFakeMouseEvent(type, position, relatedTarget) {\n            const pos = position || {\n                x: 0,\n                y: 0\n            };\n            if (typeof win.MouseEvent === 'function') {\n                return new win.MouseEvent(type, {\n                    bubbles: true,\n                    cancelable: true,\n                    composed: true,\n                    button: 0,\n                    buttons: 1,\n                    relatedTarget: relatedTarget || simulatedEventTarget,\n                    view: win,\n                    detail: type === 'click' ? 1 : 0,\n                    screenX: pos.x,\n                    screenY: pos.y,\n                    clientX: pos.x,\n                    clientY: pos.y\n                });\n            }\n            // No MouseEvent support, try using initMouseEvent\n            if (doc.createEvent) {\n                const evt = doc.createEvent('MouseEvent');\n                if (evt.initMouseEvent) {\n                    evt.initMouseEvent(type, true, // Bubble\n                    true, // Cancel\n                    win, // View\n                    type === 'click' ? 1 : 0, // Detail\n                    // Coords\n                    pos.x, pos.y, pos.x, pos.y, \n                    // Pressed keys\n                    false, false, false, false, 0, // button\n                    null // related target\n                    );\n                    return evt;\n                }\n            }\n            return { type: type };\n        }\n        /**\n         * Get an appropriate heading level for an element. Corresponds to the\n         * heading level below the previous heading in the DOM.\n         *\n         * Note: Only detects previous headings in the DOM that are siblings,\n         * ancestors, or previous siblings of ancestors. Headings that are nested below\n         * siblings of ancestors (cousins et.al) are not picked up. This is because it\n         * is ambiguous whether or not the nesting is for layout purposes or indicates a\n         * separate section.\n         *\n         * @private\n         * @param {Highcharts.HTMLDOMElement} [element]\n         * @return {string} The heading tag name (h1, h2 etc).\n         * If no nearest heading is found, \"p\" is returned.\n         */\n        function getHeadingTagNameForElement(element) {\n            const getIncreasedHeadingLevel = (tagName) => {\n                const headingLevel = parseInt(tagName.slice(1), 10), newLevel = Math.min(6, headingLevel + 1);\n                return 'h' + newLevel;\n            };\n            const isHeading = (tagName) => /H[1-6]/.test(tagName);\n            const getPreviousSiblingsHeading = (el) => {\n                let sibling = el;\n                while (sibling = sibling.previousSibling) { // eslint-disable-line\n                    const tagName = sibling.tagName || '';\n                    if (isHeading(tagName)) {\n                        return tagName;\n                    }\n                }\n                return '';\n            };\n            const getHeadingRecursive = (el) => {\n                const prevSiblingsHeading = getPreviousSiblingsHeading(el);\n                if (prevSiblingsHeading) {\n                    return getIncreasedHeadingLevel(prevSiblingsHeading);\n                }\n                // No previous siblings are headings, try parent node\n                const parent = el.parentElement;\n                if (!parent) {\n                    return 'p';\n                }\n                const parentTagName = parent.tagName;\n                if (isHeading(parentTagName)) {\n                    return getIncreasedHeadingLevel(parentTagName);\n                }\n                return getHeadingRecursive(parent);\n            };\n            return getHeadingRecursive(element);\n        }\n        /**\n         * Remove an element from the DOM.\n         * @private\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} [element]\n         * @return {void}\n         */\n        function removeElement(element) {\n            if (element && element.parentNode) {\n                element.parentNode.removeChild(element);\n            }\n        }\n        /**\n         * Remove all child nodes from an element.\n         * @private\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} [element]\n         * @return {void}\n         */\n        function removeChildNodes(element) {\n            while (element.lastChild) {\n                element.removeChild(element.lastChild);\n            }\n        }\n        /**\n         * Utility function. Reverses child nodes of a DOM element.\n         * @private\n         */\n        function reverseChildNodes(node) {\n            let i = node.childNodes.length;\n            while (i--) {\n                node.appendChild(node.childNodes[i]);\n            }\n        }\n        /**\n         * Used for aria-label attributes, painting on a canvas will fail if the\n         * text contains tags.\n         * @private\n         */\n        function stripHTMLTagsFromString(str) {\n            return typeof str === 'string' ?\n                str.replace(/<\\/?[^>]+(>|$)/g, '') : str;\n        }\n        /**\n         * Utility function for hiding an element visually, but still keeping it\n         * available to screen reader users.\n         * @private\n         */\n        function visuallyHideElement(element) {\n            css(element, {\n                position: 'absolute',\n                width: '1px',\n                height: '1px',\n                overflow: 'hidden',\n                whiteSpace: 'nowrap',\n                clip: 'rect(1px, 1px, 1px, 1px)',\n                marginTop: '-3px',\n                '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)',\n                filter: 'alpha(opacity=1)',\n                opacity: 0.01\n            });\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const HTMLUtilities = {\n            addClass,\n            cloneMouseEvent,\n            cloneTouchEvent,\n            escapeStringForHTML,\n            getElement,\n            getFakeMouseEvent,\n            getHeadingTagNameForElement,\n            removeChildNodes,\n            removeClass,\n            removeElement,\n            reverseChildNodes,\n            simulatedEventTarget,\n            stripHTMLTagsFromString,\n            visuallyHideElement\n        };\n\n        return HTMLUtilities;\n    });\n    _registerModule(_modules, 'Accessibility/A11yI18n.js', [_modules['Core/Templating.js'], _modules['Core/Utilities.js']], function (F, U) {\n        /* *\n         *\n         *  Accessibility module - internationalization support\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *  Author: Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { format } = F;\n        const { getNestedProperty, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var A11yI18nComposition;\n        (function (A11yI18nComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.langFormat = langFormat;\n                }\n                return ChartClass;\n            }\n            A11yI18nComposition.compose = compose;\n            /**\n             * i18n utility function.  Format a single array or plural statement in a\n             * format string.  If the statement is not an array or plural statement,\n             * returns the statement within brackets.  Invalid array statements return\n             * an empty string.\n             *\n             * @private\n             * @function formatExtendedStatement\n             * @param {string} statement\n             * @param {Highcharts.Dictionary<*>} ctx\n             * Context to apply to the format string.\n             */\n            function formatExtendedStatement(statement, ctx) {\n                const eachStart = statement.indexOf('#each('), pluralStart = statement.indexOf('#plural('), indexStart = statement.indexOf('['), indexEnd = statement.indexOf(']');\n                let arr, result;\n                // Dealing with an each-function?\n                if (eachStart > -1) {\n                    const eachEnd = statement.slice(eachStart).indexOf(')') + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(',');\n                    let lenArg = Number(eachArguments[1]), len;\n                    result = '';\n                    arr = getNestedProperty(eachArguments[0], ctx);\n                    if (arr) {\n                        lenArg = isNaN(lenArg) ? arr.length : lenArg;\n                        len = lenArg < 0 ?\n                            arr.length + lenArg :\n                            Math.min(lenArg, arr.length); // Overshoot\n                        // Run through the array for the specified length\n                        for (let i = 0; i < len; ++i) {\n                            result += preEach + arr[i] + postEach;\n                        }\n                    }\n                    return result.length ? result : '';\n                }\n                // Dealing with a plural-function?\n                if (pluralStart > -1) {\n                    const pluralEnd = (statement.slice(pluralStart).indexOf(')') + pluralStart), pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(','), num = Number(getNestedProperty(pluralArguments[0], ctx));\n                    switch (num) {\n                        case 0:\n                            result = pick(pluralArguments[4], pluralArguments[1]);\n                            break;\n                        case 1:\n                            result = pick(pluralArguments[2], pluralArguments[1]);\n                            break;\n                        case 2:\n                            result = pick(pluralArguments[3], pluralArguments[1]);\n                            break;\n                        default:\n                            result = pluralArguments[1];\n                    }\n                    return result ? stringTrim(result) : '';\n                }\n                // Array index\n                if (indexStart > -1) {\n                    const arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd));\n                    let val;\n                    arr = getNestedProperty(arrayName, ctx);\n                    if (!isNaN(ix) && arr) {\n                        if (ix < 0) {\n                            val = arr[arr.length + ix];\n                            // Handle negative overshoot\n                            if (typeof val === 'undefined') {\n                                val = arr[0];\n                            }\n                        }\n                        else {\n                            val = arr[ix];\n                            // Handle positive overshoot\n                            if (typeof val === 'undefined') {\n                                val = arr[arr.length - 1];\n                            }\n                        }\n                    }\n                    return typeof val !== 'undefined' ? val : '';\n                }\n                // Standard substitution, delegate to format or similar\n                return '{' + statement + '}';\n            }\n            /* eslint-disable max-len */\n            /**\n             * i18n formatting function.  Extends Highcharts.format() functionality by\n             * also handling arrays and plural conditionals.  Arrays can be indexed as\n             * follows:\n             *\n             * - Format: 'This is the first index: {myArray[0]}. The last: {myArray[-1]}.'\n             *\n             * - Context: { myArray: [0, 1, 2, 3, 4, 5] }\n             *\n             * - Result: 'This is the first index: 0. The last: 5.'\n             *\n             *\n             * They can also be iterated using the #each() function.  This will repeat\n             * the contents of the bracket expression for each element.  Example:\n             *\n             * - Format: 'List contains: {#each(myArray)cm }'\n             *\n             * - Context: { myArray: [0, 1, 2] }\n             *\n             * - Result: 'List contains: 0cm 1cm 2cm '\n             *\n             *\n             * The #each() function optionally takes a length parameter.  If positive,\n             * this parameter specifies the max number of elements to iterate through.\n             * If negative, the function will subtract the number from the length of the\n             * array.  Use this to stop iterating before the array ends.  Example:\n             *\n             * - Format: 'List contains: {#each(myArray, -1) }and {myArray[-1]}.'\n             *\n             * - Context: { myArray: [0, 1, 2, 3] }\n             *\n             * - Result: 'List contains: 0, 1, 2, and 3.'\n             *\n             *\n             * Use the #plural() function to pick a string depending on whether or not a\n             * context object is 1.  Arguments are #plural(obj, plural, singular).\n             * Example:\n             *\n             * - Format: 'Has {numPoints} {#plural(numPoints, points, point}.'\n             *\n             * - Context: { numPoints: 5 }\n             *\n             * - Result: 'Has 5 points.'\n             *\n             *\n             * Optionally there are additional parameters for dual and none:\n             * #plural(obj, plural, singular, dual, none).  Example:\n             *\n             * - Format: 'Has {#plural(numPoints, many points, one point, two points,\n             *   none}.'\n             *\n             * - Context: { numPoints: 2 }\n             *\n             * - Result: 'Has two points.'\n             *\n             *\n             * The dual or none parameters will take precedence if they are supplied.\n             *\n             * @requires modules/accessibility\n             *\n             * @function Highcharts.i18nFormat\n             *\n             * @param {string} formatString\n             * The string to format.\n             *\n             * @param {Highcharts.Dictionary<*>} context\n             * Context to apply to the format string.\n             *\n             * @param {Highcharts.Chart} chart\n             * A `Chart` instance with a time object and numberFormatter, passed on to\n             * format().\n             *\n             * @deprecated\n             *\n             * @return {string}\n             * The formatted string.\n             */\n            function i18nFormat(formatString, context, chart) {\n                const getFirstBracketStatement = (sourceStr, offset) => {\n                    const str = sourceStr.slice(offset || 0), startBracket = str.indexOf('{'), endBracket = str.indexOf('}');\n                    if (startBracket > -1 && endBracket > startBracket) {\n                        return {\n                            statement: str.substring(startBracket + 1, endBracket),\n                            begin: offset + startBracket + 1,\n                            end: offset + endBracket\n                        };\n                    }\n                }, tokens = [];\n                let bracketRes, constRes, cursor = 0;\n                // Tokenize format string into bracket statements and constants\n                do {\n                    bracketRes = getFirstBracketStatement(formatString, cursor);\n                    constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);\n                    // If we have constant content before this bracket statement, add it\n                    if (constRes.length) {\n                        tokens.push({\n                            value: constRes,\n                            type: 'constant'\n                        });\n                    }\n                    // Add the bracket statement\n                    if (bracketRes) {\n                        tokens.push({\n                            value: bracketRes.statement,\n                            type: 'statement'\n                        });\n                    }\n                    cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;\n                } while (bracketRes);\n                // Perform the formatting.  The formatArrayStatement function returns\n                // the statement in brackets if it is not an array statement, which\n                // means it gets picked up by format below.\n                tokens.forEach((token) => {\n                    if (token.type === 'statement') {\n                        token.value = formatExtendedStatement(token.value, context);\n                    }\n                });\n                // Join string back together and pass to format to pick up non-array\n                // statements.\n                return format(tokens.reduce((acc, cur) => acc + cur.value, ''), context, chart);\n            }\n            A11yI18nComposition.i18nFormat = i18nFormat;\n            /* eslint-enable max-len */\n            /**\n             * Apply context to a format string from lang options of the chart.\n             *\n             * @requires modules/accessibility\n             *\n             * @function Highcharts.Chart#langFormat\n             *\n             * @param {string} langKey\n             * Key (using dot notation) into lang option structure.\n             *\n             * @param {Highcharts.Dictionary<*>} context\n             * Context to apply to the format string.\n             *\n             * @return {string}\n             * The formatted string.\n             */\n            function langFormat(langKey, context) {\n                const keys = langKey.split('.');\n                let formatString = this.options.lang, i = 0;\n                for (; i < keys.length; ++i) {\n                    formatString = formatString && formatString[keys[i]];\n                }\n                return typeof formatString === 'string' ?\n                    i18nFormat(formatString, context, this) : '';\n            }\n            /**\n             * @private\n             * @function stringTrim\n             *\n             * @param {string} str\n             * The input string\n             *\n             * @return {string}\n             * The trimmed string\n             */\n            function stringTrim(str) {\n                return str.trim && str.trim() || str.replace(/^\\s+|\\s+$/g, '');\n            }\n        })(A11yI18nComposition || (A11yI18nComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return A11yI18nComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/ChartUtilities.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Utils for dealing with charts.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { stripHTMLTagsFromString: stripHTMLTags } = HU;\n        const { defined, find, fireEvent } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Fire an event on an element that is either wrapped by Highcharts,\n         * or a DOM element.\n         * @private\n         */\n        function fireEventOnWrappedOrUnwrappedElement(el, eventObject) {\n            const type = eventObject.type;\n            const hcEvents = el.hcEvents;\n            if ((doc.createEvent) &&\n                (el.dispatchEvent || el.fireEvent)) {\n                if (el.dispatchEvent) {\n                    el.dispatchEvent(eventObject);\n                }\n                else {\n                    el.fireEvent(type, eventObject);\n                }\n            }\n            else if (hcEvents && hcEvents[type]) {\n                fireEvent(el, type, eventObject);\n            }\n            else if (el.element) {\n                fireEventOnWrappedOrUnwrappedElement(el.element, eventObject);\n            }\n        }\n        /**\n         * @private\n         */\n        function getChartTitle(chart) {\n            return stripHTMLTags(chart.options.title.text ||\n                chart.langFormat('accessibility.defaultChartTitle', { chart: chart }));\n        }\n        /**\n         * Return string with the axis name/title.\n         * @private\n         */\n        function getAxisDescription(axis) {\n            var _a,\n                _b;\n            return axis && (((_a = axis.options.accessibility) === null || _a === void 0 ? void 0 : _a.description) ||\n                ((_b = axis.axisTitle) === null || _b === void 0 ? void 0 : _b.textStr) ||\n                axis.options.id ||\n                axis.categories && 'categories' ||\n                axis.dateTime && 'Time' ||\n                'values');\n        }\n        /**\n         * Return string with text description of the axis range.\n         * @private\n         * @param {Highcharts.Axis} axis\n         * The axis to get range desc of.\n         * @return {string}\n         * A string with the range description for the axis.\n         */\n        function getAxisRangeDescription(axis) {\n            const axisOptions = axis.options || {};\n            // Handle overridden range description\n            if (axisOptions.accessibility &&\n                typeof axisOptions.accessibility.rangeDescription !== 'undefined') {\n                return axisOptions.accessibility.rangeDescription;\n            }\n            // Handle category axes\n            if (axis.categories) {\n                return getCategoryAxisRangeDesc(axis);\n            }\n            // Use time range, not from-to?\n            if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {\n                return getAxisTimeLengthDesc(axis);\n            }\n            // Just use from and to.\n            // We have the range and the unit to use, find the desc format\n            return getAxisFromToDescription(axis);\n        }\n        /**\n         * Describe the range of a category axis.\n         * @private\n         */\n        function getCategoryAxisRangeDesc(axis) {\n            const chart = axis.chart;\n            if (axis.dataMax && axis.dataMin) {\n                return chart.langFormat('accessibility.axis.rangeCategories', {\n                    chart: chart,\n                    axis: axis,\n                    numCategories: axis.dataMax - axis.dataMin + 1\n                });\n            }\n            return '';\n        }\n        /**\n         * Describe the length of the time window shown on an axis.\n         * @private\n         */\n        function getAxisTimeLengthDesc(axis) {\n            const chart = axis.chart, range = {}, min = axis.dataMin || axis.min || 0, max = axis.dataMax || axis.max || 0;\n            let rangeUnit = 'Seconds';\n            range.Seconds = (max - min) / 1000;\n            range.Minutes = range.Seconds / 60;\n            range.Hours = range.Minutes / 60;\n            range.Days = range.Hours / 24;\n            ['Minutes', 'Hours', 'Days'].forEach(function (unit) {\n                if (range[unit] > 2) {\n                    rangeUnit = unit;\n                }\n            });\n            const rangeValue = range[rangeUnit].toFixed(rangeUnit !== 'Seconds' &&\n                rangeUnit !== 'Minutes' ? 1 : 0 // Use decimals for days/hours\n            );\n            // We have the range and the unit to use, find the desc format\n            return chart.langFormat('accessibility.axis.timeRange' + rangeUnit, {\n                chart: chart,\n                axis: axis,\n                range: rangeValue.replace('.0', '')\n            });\n        }\n        /**\n         * Describe an axis from-to range.\n         * @private\n         */\n        function getAxisFromToDescription(axis) {\n            const chart = axis.chart, options = chart.options, dateRangeFormat = (options &&\n                options.accessibility &&\n                options.accessibility.screenReaderSection.axisRangeDateFormat ||\n                ''), extremes = {\n                min: axis.dataMin || axis.min || 0,\n                max: axis.dataMax || axis.max || 0\n            }, format = function (key) {\n                return axis.dateTime ?\n                    chart.time.dateFormat(dateRangeFormat, extremes[key]) :\n                    extremes[key].toString();\n            };\n            return chart.langFormat('accessibility.axis.rangeFromTo', {\n                chart: chart,\n                axis: axis,\n                rangeFrom: format('min'),\n                rangeTo: format('max')\n            });\n        }\n        /**\n         * Get the DOM element for the first point in the series.\n         * @private\n         * @param {Highcharts.Series} series\n         * The series to get element for.\n         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement|undefined}\n         * The DOM element for the point.\n         */\n        function getSeriesFirstPointElement(series) {\n            if (series.points && series.points.length) {\n                const firstPointWithGraphic = find(series.points, (p) => !!p.graphic);\n                return (firstPointWithGraphic &&\n                    firstPointWithGraphic.graphic &&\n                    firstPointWithGraphic.graphic.element);\n            }\n        }\n        /**\n         * Get the DOM element for the series that we put accessibility info on.\n         * @private\n         * @param {Highcharts.Series} series\n         * The series to get element for.\n         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement|undefined}\n         * The DOM element for the series\n         */\n        function getSeriesA11yElement(series) {\n            const firstPointEl = getSeriesFirstPointElement(series);\n            return (firstPointEl &&\n                firstPointEl.parentNode || series.graph &&\n                series.graph.element || series.group &&\n                series.group.element); // Could be tracker series depending on series type\n        }\n        /**\n         * Remove aria-hidden from element. Also unhides parents of the element, and\n         * hides siblings that are not explicitly unhidden.\n         * @private\n         */\n        function unhideChartElementFromAT(chart, element) {\n            element.setAttribute('aria-hidden', false);\n            if (element === chart.renderTo ||\n                !element.parentNode ||\n                element.parentNode === doc.body // #16126: Full screen printing\n            ) {\n                return;\n            }\n            // Hide siblings unless their hidden state is already explicitly set\n            Array.prototype.forEach.call(element.parentNode.childNodes, function (node) {\n                if (!node.hasAttribute('aria-hidden')) {\n                    node.setAttribute('aria-hidden', true);\n                }\n            });\n            // Repeat for parent\n            unhideChartElementFromAT(chart, element.parentNode);\n        }\n        /**\n         * Hide series from screen readers.\n         * @private\n         */\n        function hideSeriesFromAT(series) {\n            const seriesEl = getSeriesA11yElement(series);\n            if (seriesEl) {\n                seriesEl.setAttribute('aria-hidden', true);\n            }\n        }\n        /**\n         * Get series objects by series name.\n         * @private\n         */\n        function getSeriesFromName(chart, name) {\n            if (!name) {\n                return chart.series;\n            }\n            return (chart.series || []).filter(function (s) {\n                return s.name === name;\n            });\n        }\n        /**\n         * Get point in a series from x/y values.\n         * @private\n         */\n        function getPointFromXY(series, x, y) {\n            let i = series.length, res;\n            while (i--) {\n                res = find(series[i].points || [], function (p) {\n                    return p.x === x && p.y === y;\n                });\n                if (res) {\n                    return res;\n                }\n            }\n        }\n        /**\n         * Get relative position of point on an x/y axis from 0 to 1.\n         * @private\n         */\n        function getRelativePointAxisPosition(axis, point) {\n            if (!defined(axis.dataMin) || !defined(axis.dataMax)) {\n                return 0;\n            }\n            const axisStart = axis.toPixels(axis.dataMin), axisEnd = axis.toPixels(axis.dataMax), \n            // We have to use pixel position because of axis breaks, log axis etc.\n            positionProp = axis.coll === 'xAxis' ? 'x' : 'y', pointPos = axis.toPixels(point[positionProp] || 0);\n            return (pointPos - axisStart) / (axisEnd - axisStart);\n        }\n        /**\n         * Get relative position of point on an x/y axis from 0 to 1.\n         * @private\n         */\n        function scrollToPoint(point) {\n            const xAxis = point.series.xAxis, yAxis = point.series.yAxis, axis = (xAxis && xAxis.scrollbar ? xAxis : yAxis), scrollbar = (axis && axis.scrollbar);\n            if (scrollbar && defined(scrollbar.to) && defined(scrollbar.from)) {\n                const range = scrollbar.to - scrollbar.from;\n                const pos = getRelativePointAxisPosition(axis, point);\n                scrollbar.updatePosition(pos - range / 2, pos + range / 2);\n                fireEvent(scrollbar, 'changed', {\n                    from: scrollbar.from,\n                    to: scrollbar.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: null\n                });\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ChartUtilities = {\n            fireEventOnWrappedOrUnwrappedElement,\n            getChartTitle,\n            getAxisDescription,\n            getAxisRangeDescription,\n            getPointFromXY,\n            getSeriesFirstPointElement,\n            getSeriesFromName,\n            getSeriesA11yElement,\n            unhideChartElementFromAT,\n            hideSeriesFromAT,\n            scrollToPoint\n        };\n\n        return ChartUtilities;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/DOMElementProvider.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Class that can keep track of elements added to DOM and clean them up on\n         *  destroy.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { removeElement } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         */\n        class DOMElementProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor() {\n                this.elements = [];\n            }\n            /**\n             * Create an element and keep track of it for later removal.\n             * Same args as document.createElement\n             * @private\n             */\n            createElement() {\n                const el = doc.createElement.apply(doc, arguments);\n                this.elements.push(el);\n                return el;\n            }\n            /**\n             * Destroy all created elements, removing them from the DOM.\n             * @private\n             */\n            destroyCreatedElements() {\n                this.elements.forEach(function (element) {\n                    removeElement(element);\n                });\n                this.elements = [];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DOMElementProvider;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/EventProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Class that can keep track of events added, and clean them up on destroy.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         */\n        class EventProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor() {\n                this.eventRemovers = [];\n            }\n            /**\n             * Add an event to an element and keep track of it for later removal.\n             * Same args as Highcharts.addEvent.\n             * @private\n             */\n            addEvent() {\n                const remover = addEvent.apply(H, arguments);\n                this.eventRemovers.push(remover);\n                return remover;\n            }\n            /**\n             * Remove all added events.\n             * @private\n             */\n            removeAddedEvents() {\n                this.eventRemovers.forEach((remover) => remover());\n                this.eventRemovers = [];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return EventProvider;\n    });\n    _registerModule(_modules, 'Accessibility/AccessibilityComponent.js', [_modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (CU, DOMElementProvider, EventProvider, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component class definition\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { fireEventOnWrappedOrUnwrappedElement } = CU;\n        const { getFakeMouseEvent } = HU;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The AccessibilityComponent base class, representing a part of the chart that\n         * has accessibility logic connected to it. This class can be inherited from to\n         * create a custom accessibility component for a chart.\n         *\n         * Components should take care to destroy added elements and unregister event\n         * handlers on destroy. This is handled automatically if using this.addEvent and\n         * this.createElement.\n         *\n         * @sample highcharts/accessibility/custom-component\n         *         Custom accessibility component\n         *\n         * @requires module:modules/accessibility\n         * @class\n         * @name Highcharts.AccessibilityComponent\n         */\n        class AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.domElementProvider = void 0;\n                this.eventProvider = void 0;\n                this.keyCodes = void 0;\n                this.proxyProvider = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the class\n             * @private\n             * @param {Highcharts.Chart} chart The chart object\n             * @param {Highcharts.ProxyProvider} proxyProvider The proxy provider of the accessibility module\n             */\n            initBase(chart, proxyProvider) {\n                this.chart = chart;\n                this.eventProvider = new EventProvider();\n                this.domElementProvider = new DOMElementProvider();\n                this.proxyProvider = proxyProvider;\n                // Key code enum for common keys\n                this.keyCodes = {\n                    left: 37,\n                    right: 39,\n                    up: 38,\n                    down: 40,\n                    enter: 13,\n                    space: 32,\n                    esc: 27,\n                    tab: 9,\n                    pageUp: 33,\n                    pageDown: 34,\n                    end: 35,\n                    home: 36\n                };\n            }\n            /**\n             * Add an event to an element and keep track of it for later removal.\n             * See EventProvider for details.\n             * @private\n             */\n            addEvent(el, type, fn, options) {\n                return this.eventProvider.addEvent(el, type, fn, options);\n            }\n            /**\n             * Create an element and keep track of it for later removal.\n             * See DOMElementProvider for details.\n             * @private\n             */\n            createElement(tagName, options) {\n                return this.domElementProvider.createElement(tagName, options);\n            }\n            /**\n             * Fire a fake click event on an element. It is useful to have this on\n             * AccessibilityComponent for users of custom components.\n             */\n            fakeClickEvent(el) {\n                const fakeEvent = getFakeMouseEvent('click');\n                fireEventOnWrappedOrUnwrappedElement(el, fakeEvent);\n            }\n            /**\n             * Remove traces of the component.\n             * @private\n             */\n            destroyBase() {\n                this.domElementProvider.destroyCreatedElements();\n                this.eventProvider.removeAddedEvents();\n            }\n        }\n        extend(AccessibilityComponent.prototype, \n        /** @lends Highcharts.AccessibilityComponent */\n        {\n            /**\n             * Called on component initialization.\n             */\n            init() { },\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation: function () { },\n            /**\n             * Called on updates to the chart, including options changes.\n             * Note that this is also called on first render of chart.\n             */\n            onChartUpdate() { },\n            /**\n             * Called on every chart render.\n             */\n            onChartRender() { },\n            /**\n             * Called when accessibility is disabled or chart is destroyed.\n             */\n            destroy() { }\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AccessibilityComponent;\n    });\n    _registerModule(_modules, 'Accessibility/KeyboardNavigationHandler.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Keyboard navigation handler base class definition\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { find } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Define a keyboard navigation handler for use with a\n         * Highcharts.AccessibilityComponent instance. This functions as an abstraction\n         * layer for keyboard navigation, and defines a map of keyCodes to handler\n         * functions.\n         *\n         * @requires module:modules/accessibility\n         *\n         * @sample highcharts/accessibility/custom-component\n         *         Custom accessibility component\n         *\n         * @class\n         * @name Highcharts.KeyboardNavigationHandler\n         *\n         * @param {Highcharts.Chart} chart\n         * The chart this module should act on.\n         *\n         * @param {Highcharts.KeyboardNavigationHandlerOptionsObject} options\n         * Options for the keyboard navigation handler.\n         */\n        class KeyboardNavigationHandler {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, options) {\n                this.chart = chart;\n                this.keyCodeMap = options.keyCodeMap || [];\n                this.validate = options.validate;\n                this.init = options.init;\n                this.terminate = options.terminate;\n                // Response enum\n                this.response = {\n                    success: 1,\n                    prev: 2,\n                    next: 3,\n                    noHandler: 4,\n                    fail: 5 // Handler failed\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Find handler function(s) for key code in the keyCodeMap and run it.\n             *\n             * @function KeyboardNavigationHandler#run\n             * @param {global.KeyboardEvent} e\n             * @return {number} Returns a response code indicating whether the run was\n             *      a success/fail/unhandled, or if we should move to next/prev module.\n             */\n            run(e) {\n                const keyCode = e.which || e.keyCode;\n                let response = this.response.noHandler;\n                const handlerCodeSet = find(this.keyCodeMap, function (codeSet) {\n                    return codeSet[0].indexOf(keyCode) > -1;\n                });\n                if (handlerCodeSet) {\n                    response = handlerCodeSet[1].call(this, keyCode, e);\n                }\n                else if (keyCode === 9) {\n                    // Default tab handler, move to next/prev module\n                    response = this.response[e.shiftKey ? 'prev' : 'next'];\n                }\n                return response;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Options for the keyboard navigation handler.\n         *\n         * @interface Highcharts.KeyboardNavigationHandlerOptionsObject\n         */ /**\n        * An array containing pairs of an array of keycodes, mapped to a handler\n        * function. When the keycode is received, the handler is called with the\n        * keycode as parameter.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#keyCodeMap\n        * @type {Array<Array<Array<number>, Function>>}\n        */ /**\n        * Function to run on initialization of module.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#init\n        * @type {Function}\n        */ /**\n        * Function to run before moving to next/prev module. Receives moving direction\n        * as parameter: +1 for next, -1 for previous.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#terminate\n        * @type {Function|undefined}\n        */ /**\n        * Function to run to validate module. Should return false if module should not\n        * run, true otherwise. Receives chart as parameter.\n        * @name Highcharts.KeyboardNavigationHandlerOptionsObject#validate\n        * @type {Function|undefined}\n        */\n        (''); // keeps doclets above in JS file\n\n        return KeyboardNavigationHandler;\n    });\n    _registerModule(_modules, 'Accessibility/Components/ContainerComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (AccessibilityComponent, KeyboardNavigationHandler, CU, H, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for chart container.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT, getChartTitle } = CU;\n        const { doc } = H;\n        const { stripHTMLTagsFromString: stripHTMLTags } = HU;\n        /**\n         * The ContainerComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.ContainerComponent\n         */\n        class ContainerComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Called on first render/updates to the chart, including options changes.\n             */\n            onChartUpdate() {\n                this.handleSVGTitleElement();\n                this.setSVGContainerLabel();\n                this.setGraphicContainerAttrs();\n                this.setRenderToAttrs();\n                this.makeCreditsAccessible();\n            }\n            /**\n             * @private\n             */\n            handleSVGTitleElement() {\n                const chart = this.chart, titleId = 'highcharts-title-' + chart.index, titleContents = stripHTMLTags(chart.langFormat('accessibility.svgContainerTitle', {\n                    chartTitle: getChartTitle(chart)\n                }));\n                if (titleContents.length) {\n                    const titleElement = this.svgTitleElement =\n                        this.svgTitleElement || doc.createElementNS('http://www.w3.org/2000/svg', 'title');\n                    titleElement.textContent = titleContents;\n                    titleElement.id = titleId;\n                    chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);\n                }\n            }\n            /**\n             * @private\n             */\n            setSVGContainerLabel() {\n                const chart = this.chart, svgContainerLabel = chart.langFormat('accessibility.svgContainerLabel', {\n                    chartTitle: getChartTitle(chart)\n                });\n                if (chart.renderer.box && svgContainerLabel.length) {\n                    chart.renderer.box.setAttribute('aria-label', svgContainerLabel);\n                }\n            }\n            /**\n             * @private\n             */\n            setGraphicContainerAttrs() {\n                const chart = this.chart, label = chart.langFormat('accessibility.graphicContainerLabel', {\n                    chartTitle: getChartTitle(chart)\n                });\n                if (label.length) {\n                    chart.container.setAttribute('aria-label', label);\n                }\n            }\n            /**\n             * Set attributes on the chart container element.\n             * @private\n             */\n            setRenderToAttrs() {\n                const chart = this.chart, shouldHaveLandmark = chart.options.accessibility\n                    .landmarkVerbosity !== 'disabled', containerLabel = chart.langFormat('accessibility.chartContainerLabel', {\n                    title: getChartTitle(chart),\n                    chart: chart\n                });\n                if (containerLabel) {\n                    chart.renderTo.setAttribute('role', shouldHaveLandmark ? 'region' : 'group');\n                    chart.renderTo.setAttribute('aria-label', containerLabel);\n                }\n            }\n            /**\n             * @private\n             */\n            makeCreditsAccessible() {\n                const chart = this.chart, credits = chart.credits;\n                if (credits) {\n                    if (credits.textStr) {\n                        credits.element.setAttribute('aria-label', chart.langFormat('accessibility.credits', { creditsStr: stripHTMLTags(credits.textStr) }));\n                    }\n                    unhideChartElementFromAT(chart, credits.element);\n                }\n            }\n            /**\n             * Empty handler to just set focus on chart\n             * @private\n             */\n            getKeyboardNavigation() {\n                const chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [],\n                    validate: function () {\n                        return true;\n                    },\n                    init: function () {\n                        const a11y = chart.accessibility;\n                        if (a11y) {\n                            a11y.keyboardNavigation.tabindexContainer.focus();\n                        }\n                    }\n                });\n            }\n            /**\n             * Accessibility disabled/chart destroyed.\n             */\n            destroy() {\n                this.chart.renderTo.setAttribute('aria-hidden', true);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ContainerComponent;\n    });\n    _registerModule(_modules, 'Accessibility/FocusBorder.js', [_modules['Core/Renderer/SVG/SVGLabel.js'], _modules['Core/Utilities.js']], function (SVGLabel, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Extend SVG and Chart classes with focus border capabilities.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var FocusBorderComposition;\n        (function (FocusBorderComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            // Attributes that trigger a focus border update\n            const svgElementBorderUpdateTriggers = [\n                'x', 'y', 'transform', 'width', 'height', 'r', 'd', 'stroke-width'\n            ];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass, SVGElementClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.renderFocusBorder = chartRenderFocusBorder;\n                    chartProto.setFocusToElement = chartSetFocusToElement;\n                }\n                if (U.pushUnique(composedMembers, SVGElementClass)) {\n                    const svgElementProto = SVGElementClass.prototype;\n                    svgElementProto.addFocusBorder = svgElementAddFocusBorder;\n                    svgElementProto.removeFocusBorder = svgElementRemoveFocusBorder;\n                }\n            }\n            FocusBorderComposition.compose = compose;\n            /**\n             * Redraws the focus border on the currently focused element.\n             *\n             * @private\n             * @function Highcharts.Chart#renderFocusBorder\n             */\n            function chartRenderFocusBorder() {\n                const focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;\n                if (focusElement) {\n                    focusElement.removeFocusBorder();\n                    if (focusBorderOptions.enabled) {\n                        focusElement.addFocusBorder(focusBorderOptions.margin, {\n                            stroke: focusBorderOptions.style.color,\n                            strokeWidth: focusBorderOptions.style.lineWidth,\n                            r: focusBorderOptions.style.borderRadius\n                        });\n                    }\n                }\n            }\n            /**\n             * Set chart's focus to an SVGElement. Calls focus() on it, and draws the\n             * focus border. This is used by multiple components.\n             *\n             * @private\n             * @function Highcharts.Chart#setFocusToElement\n             *\n             * @param {Highcharts.SVGElement} svgElement\n             * Element to draw the border around.\n             *\n             * @param {SVGDOMElement|HTMLDOMElement} [focusElement]\n             * If supplied, it draws the border around svgElement and sets the focus to\n             * focusElement.\n             */\n            function chartSetFocusToElement(svgElement, focusElement) {\n                const focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;\n                // Set browser focus if possible\n                if (browserFocusElement &&\n                    browserFocusElement.focus) {\n                    // If there is no focusin-listener, add one to work around Edge\n                    // where Narrator is not reading out points despite calling focus().\n                    if (!(browserFocusElement.hcEvents &&\n                        browserFocusElement.hcEvents.focusin)) {\n                        addEvent(browserFocusElement, 'focusin', function () { });\n                    }\n                    browserFocusElement.focus();\n                    // Hide default focus ring\n                    if (focusBorderOptions.hideBrowserFocusOutline) {\n                        browserFocusElement.style.outline = 'none';\n                    }\n                }\n                if (this.focusElement) {\n                    this.focusElement.removeFocusBorder();\n                }\n                this.focusElement = svgElement;\n                this.renderFocusBorder();\n            }\n            /**\n             * Add hook to destroy focus border if SVG element is destroyed, unless\n             * hook already exists.\n             * @private\n             * @param el Element to add destroy hook to\n             */\n            function svgElementAddDestroyFocusBorderHook(el) {\n                if (el.focusBorderDestroyHook) {\n                    return;\n                }\n                const origDestroy = el.destroy;\n                el.destroy = function () {\n                    if (el.focusBorder && el.focusBorder.destroy) {\n                        el.focusBorder.destroy();\n                    }\n                    return origDestroy.apply(el, arguments);\n                };\n                el.focusBorderDestroyHook = origDestroy;\n            }\n            /**\n             * Add focus border functionality to SVGElements. Draws a new rect on top of\n             * element around its bounding box. This is used by multiple components.\n             *\n             * @private\n             * @function Highcharts.SVGElement#addFocusBorder\n             *\n             * @param {number} margin\n             *\n             * @param {SVGAttributes} attribs\n             */\n            function svgElementAddFocusBorder(margin, attribs) {\n                // Allow updating by just adding new border\n                if (this.focusBorder) {\n                    this.removeFocusBorder();\n                }\n                // Add the border rect\n                const bb = this.getBBox(), pad = pick(margin, 3), parent = this.parentGroup, scaleX = this.scaleX || parent && parent.scaleX, scaleY = this.scaleY || parent && parent.scaleY, oneDefined = scaleX ? !scaleY : scaleY, scaleBoth = oneDefined ? Math.abs(scaleX || scaleY || 1) :\n                    (Math.abs(scaleX || 1) + Math.abs(scaleY || 1)) / 2;\n                bb.x += this.translateX ? this.translateX : 0;\n                bb.y += this.translateY ? this.translateY : 0;\n                let borderPosX = bb.x - pad, borderPosY = bb.y - pad, borderWidth = bb.width + 2 * pad, borderHeight = bb.height + 2 * pad;\n                /**\n                 * For text elements, apply x and y offset, #11397.\n                 * @private\n                 */\n                function getTextAnchorCorrection(text) {\n                    let posXCorrection = 0, posYCorrection = 0;\n                    if (text.attr('text-anchor') === 'middle') {\n                        posXCorrection = posYCorrection = 0.5;\n                    }\n                    else if (!text.rotation) {\n                        posYCorrection = 0.75;\n                    }\n                    else {\n                        posXCorrection = 0.25;\n                    }\n                    return {\n                        x: posXCorrection,\n                        y: posYCorrection\n                    };\n                }\n                const isLabel = this instanceof SVGLabel;\n                if (this.element.nodeName === 'text' || isLabel) {\n                    const isRotated = !!this.rotation;\n                    const correction = !isLabel ? getTextAnchorCorrection(this) :\n                        {\n                            x: isRotated ? 1 : 0,\n                            y: 0\n                        };\n                    const attrX = +this.attr('x');\n                    const attrY = +this.attr('y');\n                    if (!isNaN(attrX)) {\n                        borderPosX = attrX - (bb.width * correction.x) - pad;\n                    }\n                    if (!isNaN(attrY)) {\n                        borderPosY = attrY - (bb.height * correction.y) - pad;\n                    }\n                    if (isLabel && isRotated) {\n                        const temp = borderWidth;\n                        borderWidth = borderHeight;\n                        borderHeight = temp;\n                        if (!isNaN(attrX)) {\n                            borderPosX = attrX - (bb.height * correction.x) - pad;\n                        }\n                        if (!isNaN(attrY)) {\n                            borderPosY = attrY - (bb.width * correction.y) - pad;\n                        }\n                    }\n                }\n                this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10) / scaleBoth)\n                    .addClass('highcharts-focus-border')\n                    .attr({\n                    zIndex: 99\n                })\n                    .add(parent);\n                if (!this.renderer.styledMode) {\n                    this.focusBorder.attr({\n                        stroke: attribs && attribs.stroke,\n                        'stroke-width': (attribs && attribs.strokeWidth || 0) / scaleBoth\n                    });\n                }\n                avgElementAddUpdateFocusBorderHooks(this, margin, attribs);\n                svgElementAddDestroyFocusBorderHook(this);\n            }\n            /**\n             * Add hooks to update the focus border of an element when the element\n             * size/position is updated, unless already added.\n             * @private\n             * @param el Element to add update hooks to\n             * @param updateParams Parameters to pass through to addFocusBorder when updating.\n             */\n            function avgElementAddUpdateFocusBorderHooks(el, ...updateParams) {\n                if (el.focusBorderUpdateHooks) {\n                    return;\n                }\n                el.focusBorderUpdateHooks = {};\n                svgElementBorderUpdateTriggers.forEach((trigger) => {\n                    const setterKey = trigger + 'Setter';\n                    const origSetter = el[setterKey] || el._defaultSetter;\n                    el.focusBorderUpdateHooks[setterKey] = origSetter;\n                    el[setterKey] = function () {\n                        const ret = origSetter.apply(el, arguments);\n                        el.addFocusBorder.apply(el, updateParams);\n                        return ret;\n                    };\n                });\n            }\n            /**\n             * Remove hook from SVG element added by addDestroyFocusBorderHook, if\n             * existing.\n             * @private\n             * @param el Element to remove destroy hook from\n             */\n            function svgElementRemoveDestroyFocusBorderHook(el) {\n                if (!el.focusBorderDestroyHook) {\n                    return;\n                }\n                el.destroy = el.focusBorderDestroyHook;\n                delete el.focusBorderDestroyHook;\n            }\n            /**\n             * Add focus border functionality to SVGElements. Draws a new rect on top of\n             * element around its bounding box. This is used by multiple components.\n             * @private\n             * @function Highcharts.SVGElement#removeFocusBorder\n             */\n            function svgElementRemoveFocusBorder() {\n                svgElementRemoveUpdateFocusBorderHooks(this);\n                svgElementRemoveDestroyFocusBorderHook(this);\n                if (this.focusBorder) {\n                    this.focusBorder.destroy();\n                    delete this.focusBorder;\n                }\n            }\n            /**\n             * Remove hooks from SVG element added by addUpdateFocusBorderHooks, if\n             * existing.\n             * @private\n             * @param el Element to remove update hooks from\n             */\n            function svgElementRemoveUpdateFocusBorderHooks(el) {\n                if (!el.focusBorderUpdateHooks) {\n                    return;\n                }\n                Object.keys(el.focusBorderUpdateHooks).forEach((setterKey) => {\n                    const origSetter = el.focusBorderUpdateHooks[setterKey];\n                    if (origSetter === el._defaultSetter) {\n                        delete el[setterKey];\n                    }\n                    else {\n                        el[setterKey] = origSetter;\n                    }\n                });\n                delete el.focusBorderUpdateHooks;\n            }\n        })(FocusBorderComposition || (FocusBorderComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return FocusBorderComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Utils/Announcer.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (AST, DOMElementProvider, H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Create announcer to speak messages to screen readers and other AT.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { addClass, visuallyHideElement } = HU;\n        const { attr } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Announcer {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, type) {\n                this.chart = chart;\n                this.domElementProvider = new DOMElementProvider();\n                this.announceRegion = this.addAnnounceRegion(type);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            destroy() {\n                this.domElementProvider.destroyCreatedElements();\n            }\n            announce(message) {\n                AST.setElementHTML(this.announceRegion, message);\n                // Delete contents after a little while to avoid user finding the live\n                // region in the DOM.\n                if (this.clearAnnouncementRegionTimer) {\n                    clearTimeout(this.clearAnnouncementRegionTimer);\n                }\n                this.clearAnnouncementRegionTimer = setTimeout(() => {\n                    this.announceRegion.innerHTML = AST.emptyHTML;\n                    delete this.clearAnnouncementRegionTimer;\n                }, 1000);\n            }\n            addAnnounceRegion(type) {\n                const chartContainer = (this.chart.announcerContainer || this.createAnnouncerContainer()), div = this.domElementProvider.createElement('div');\n                attr(div, {\n                    'aria-hidden': false,\n                    'aria-live': type\n                });\n                if (this.chart.styledMode) {\n                    addClass(div, 'highcharts-visually-hidden');\n                }\n                else {\n                    visuallyHideElement(div);\n                }\n                chartContainer.appendChild(div);\n                return div;\n            }\n            createAnnouncerContainer() {\n                const chart = this.chart, container = doc.createElement('div');\n                attr(container, {\n                    'aria-hidden': false,\n                    'class': 'highcharts-announcer-container'\n                });\n                container.style.position = 'relative';\n                chart.renderTo.insertBefore(container, chart.renderTo.firstChild);\n                chart.announcerContainer = container;\n                return container;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Announcer;\n    });\n    _registerModule(_modules, 'Accessibility/Components/AnnotationsA11y.js', [_modules['Accessibility/Utils/HTMLUtilities.js']], function (HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Annotations accessibility code.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { escapeStringForHTML, stripHTMLTagsFromString } = HTMLUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get list of all annotation labels in the chart.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {Array<object>} The labels, or empty array if none.\n         */\n        function getChartAnnotationLabels(chart) {\n            const annotations = chart.annotations || [];\n            return annotations.reduce((acc, cur) => {\n                if (cur.options &&\n                    cur.options.visible !== false) {\n                    acc = acc.concat(cur.labels);\n                }\n                return acc;\n            }, []);\n        }\n        /**\n         * Get the text of an annotation label.\n         *\n         * @private\n         * @param {Object} label The annotation label object\n         * @return {string} The text in the label.\n         */\n        function getLabelText(label) {\n            return ((label.options &&\n                label.options.accessibility &&\n                label.options.accessibility.description) ||\n                (label.graphic &&\n                    label.graphic.text &&\n                    label.graphic.text.textStr) ||\n                '');\n        }\n        /**\n         * Describe an annotation label.\n         *\n         * @private\n         * @param {Object} label The annotation label object to describe\n         * @return {string} The description for the label.\n         */\n        function getAnnotationLabelDescription(label) {\n            const a11yDesc = (label.options &&\n                label.options.accessibility &&\n                label.options.accessibility.description);\n            if (a11yDesc) {\n                return a11yDesc;\n            }\n            const chart = label.chart;\n            const labelText = getLabelText(label);\n            const points = label.points;\n            const getAriaLabel = (point) => (point.graphic &&\n                point.graphic.element &&\n                point.graphic.element.getAttribute('aria-label') ||\n                '');\n            const getValueDesc = (point) => {\n                const valDesc = (point.accessibility &&\n                    point.accessibility.valueDescription ||\n                    getAriaLabel(point));\n                const seriesName = (point &&\n                    point.series.name ||\n                    '');\n                return (seriesName ? seriesName + ', ' : '') + 'data point ' + valDesc;\n            };\n            const pointValueDescriptions = points\n                .filter((p) => !!p.graphic) // Filter out mock points\n                .map(getValueDesc)\n                // Filter out points we can't describe\n                .filter((desc) => !!desc);\n            const numPoints = pointValueDescriptions.length;\n            const pointsSelector = numPoints > 1 ?\n                'MultiplePoints' : numPoints ?\n                'SinglePoint' : 'NoPoints';\n            const langFormatStr = ('accessibility.screenReaderSection.annotations.description' +\n                pointsSelector);\n            const context = {\n                annotationText: labelText,\n                annotation: label,\n                numPoints: numPoints,\n                annotationPoint: pointValueDescriptions[0],\n                additionalAnnotationPoints: pointValueDescriptions.slice(1)\n            };\n            return chart.langFormat(langFormatStr, context);\n        }\n        /**\n         * Return array of HTML strings for each annotation label in the chart.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {Array<string>} Array of strings with HTML content for each annotation label.\n         */\n        function getAnnotationListItems(chart) {\n            const labels = getChartAnnotationLabels(chart);\n            return labels.map((label) => {\n                const desc = escapeStringForHTML(stripHTMLTagsFromString(getAnnotationLabelDescription(label)));\n                return desc ? `<li>${desc}</li>` : '';\n            });\n        }\n        /**\n         * Return the annotation info for a chart as string.\n         *\n         * @private\n         * @param {Highcharts.Chart} chart The chart to get annotation info on.\n         * @return {string} String with HTML content or empty string if no annotations.\n         */\n        function getAnnotationsInfoHTML(chart) {\n            const annotations = chart.annotations;\n            if (!(annotations && annotations.length)) {\n                return '';\n            }\n            const annotationItems = getAnnotationListItems(chart);\n            return `<ul style=\"list-style-type: none\">${annotationItems.join(' ')}</ul>`;\n        }\n        /**\n         * Return the texts for the annotation(s) connected to a point, or empty array\n         * if none.\n         *\n         * @private\n         * @param {Highcharts.Point} point The data point to get the annotation info from.\n         * @return {Array<string>} Annotation texts\n         */\n        function getPointAnnotationTexts(point) {\n            const labels = getChartAnnotationLabels(point.series.chart);\n            const pointLabels = labels\n                .filter((label) => label.points.indexOf(point) > -1);\n            if (!pointLabels.length) {\n                return [];\n            }\n            return pointLabels.map((label) => `${getLabelText(label)}`);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const AnnotationsA11y = {\n            getAnnotationsInfoHTML,\n            getAnnotationLabelDescription,\n            getAnnotationListItems,\n            getPointAnnotationTexts\n        };\n\n        return AnnotationsA11y;\n    });\n    _registerModule(_modules, 'Accessibility/Components/InfoRegionsComponent.js', [_modules['Accessibility/A11yI18n.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (A11yI18n, AccessibilityComponent, Announcer, AnnotationsA11y, AST, CU, F, H, HU, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for chart info region and table.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getAnnotationsInfoHTML } = AnnotationsA11y;\n        const { getAxisDescription, getAxisRangeDescription, getChartTitle, unhideChartElementFromAT } = CU;\n        const { format } = F;\n        const { doc } = H;\n        const { addClass, getElement, getHeadingTagNameForElement, stripHTMLTagsFromString, visuallyHideElement } = HU;\n        const { attr, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function getTableSummary(chart) {\n            return chart.langFormat('accessibility.table.tableSummary', { chart: chart });\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForMapChart(chart, formatContext) {\n            return formatContext.mapTitle ?\n                chart.langFormat('accessibility.chartTypes.mapTypeDescription', formatContext) :\n                chart.langFormat('accessibility.chartTypes.unknownMap', formatContext);\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForCombinationChart(chart, formatContext) {\n            return chart.langFormat('accessibility.chartTypes.combinationChart', formatContext);\n        }\n        /**\n         * @private\n         */\n        function getTypeDescForEmptyChart(chart, formatContext) {\n            return chart.langFormat('accessibility.chartTypes.emptyChart', formatContext);\n        }\n        /**\n         * @private\n         */\n        function buildTypeDescriptionFromSeries(chart, types, context) {\n            const firstType = types[0], typeExplaination = chart.langFormat('accessibility.seriesTypeDescriptions.' + firstType, context), multi = chart.series && chart.series.length < 2 ? 'Single' : 'Multiple';\n            return (chart.langFormat('accessibility.chartTypes.' + firstType + multi, context) ||\n                chart.langFormat('accessibility.chartTypes.default' + multi, context)) + (typeExplaination ? ' ' + typeExplaination : '');\n        }\n        /**\n         * Return simplified explaination of chart type. Some types will not be\n         * familiar to most users, but in those cases we try to add an explaination\n         * of the type.\n         *\n         * @private\n         * @function Highcharts.Chart#getTypeDescription\n         * @param {Array<string>} types The series types in this chart.\n         * @return {string} The text description of the chart type.\n         */\n        function getTypeDescription(chart, types) {\n            const firstType = types[0], firstSeries = chart.series && chart.series[0] || {}, mapTitle = chart.mapView && chart.mapView.geoMap &&\n                chart.mapView.geoMap.title, formatContext = {\n                numSeries: chart.series.length,\n                numPoints: firstSeries.points && firstSeries.points.length,\n                chart,\n                mapTitle\n            };\n            if (!firstType) {\n                return getTypeDescForEmptyChart(chart, formatContext);\n            }\n            if (firstType === 'map' || firstType === 'tiledwebmap') {\n                return getTypeDescForMapChart(chart, formatContext);\n            }\n            if (chart.types.length > 1) {\n                return getTypeDescForCombinationChart(chart, formatContext);\n            }\n            return buildTypeDescriptionFromSeries(chart, types, formatContext);\n        }\n        /**\n         * @private\n         */\n        function stripEmptyHTMLTags(str) {\n            return str.replace(/<(\\w+)[^>]*?>\\s*<\\/\\1>/g, '');\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The InfoRegionsComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.InfoRegionsComponent\n         */\n        class InfoRegionsComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.announcer = void 0;\n                this.screenReaderSections = {};\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                const component = this;\n                this.initRegionsDefinitions();\n                this.addEvent(chart, 'aftergetTableAST', function (e) {\n                    component.onDataTableCreated(e);\n                });\n                this.addEvent(chart, 'afterViewData', function (e) {\n                    if (e.wasHidden) {\n                        component.dataTableDiv = e.element;\n                        // Use a small delay to give browsers & AT time to\n                        // register the new table.\n                        setTimeout(function () {\n                            component.focusDataTable();\n                        }, 300);\n                    }\n                });\n                this.announcer = new Announcer(chart, 'assertive');\n            }\n            /**\n             * @private\n             */\n            initRegionsDefinitions() {\n                const component = this;\n                this.screenReaderSections = {\n                    before: {\n                        element: null,\n                        buildContent: function (chart) {\n                            const formatter = chart.options.accessibility\n                                .screenReaderSection.beforeChartFormatter;\n                            return formatter ? formatter(chart) :\n                                component.defaultBeforeChartFormatter(chart);\n                        },\n                        insertIntoDOM: function (el, chart) {\n                            chart.renderTo.insertBefore(el, chart.renderTo.firstChild);\n                        },\n                        afterInserted: function () {\n                            if (typeof component.sonifyButtonId !== 'undefined') {\n                                component.initSonifyButton(component.sonifyButtonId);\n                            }\n                            if (typeof component.dataTableButtonId !== 'undefined') {\n                                component.initDataTableButton(component.dataTableButtonId);\n                            }\n                        }\n                    },\n                    after: {\n                        element: null,\n                        buildContent: function (chart) {\n                            const formatter = chart.options.accessibility\n                                .screenReaderSection\n                                .afterChartFormatter;\n                            return formatter ? formatter(chart) :\n                                component.defaultAfterChartFormatter();\n                        },\n                        insertIntoDOM: function (el, chart) {\n                            chart.renderTo.insertBefore(el, chart.container.nextSibling);\n                        },\n                        afterInserted: function () {\n                            if (component.chart.accessibility) {\n                                component.chart.accessibility\n                                    .keyboardNavigation.updateExitAnchor(); // #15986\n                            }\n                        }\n                    }\n                };\n            }\n            /**\n             * Called on chart render. Have to update the sections on render, in order\n             * to get a11y info from series.\n             */\n            onChartRender() {\n                const component = this;\n                this.linkedDescriptionElement = this.getLinkedDescriptionElement();\n                this.setLinkedDescriptionAttrs();\n                Object.keys(this.screenReaderSections).forEach(function (regionKey) {\n                    component.updateScreenReaderSection(regionKey);\n                });\n            }\n            /**\n             * @private\n             */\n            getLinkedDescriptionElement() {\n                const chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;\n                if (!linkedDescOption) {\n                    return;\n                }\n                if (typeof linkedDescOption !== 'string') {\n                    return linkedDescOption;\n                }\n                const query = format(linkedDescOption, this.chart), queryMatch = doc.querySelectorAll(query);\n                if (queryMatch.length === 1) {\n                    return queryMatch[0];\n                }\n            }\n            /**\n             * @private\n             */\n            setLinkedDescriptionAttrs() {\n                const el = this.linkedDescriptionElement;\n                if (el) {\n                    el.setAttribute('aria-hidden', 'true');\n                    addClass(el, 'highcharts-linked-description');\n                }\n            }\n            /**\n             * @private\n             * @param {string} regionKey\n             * The name/key of the region to update\n             */\n            updateScreenReaderSection(regionKey) {\n                const chart = this.chart;\n                const region = this.screenReaderSections[regionKey];\n                const content = region.buildContent(chart);\n                const sectionDiv = region.element = (region.element || this.createElement('div'));\n                const hiddenDiv = (sectionDiv.firstChild || this.createElement('div'));\n                if (content) {\n                    this.setScreenReaderSectionAttribs(sectionDiv, regionKey);\n                    AST.setElementHTML(hiddenDiv, content);\n                    sectionDiv.appendChild(hiddenDiv);\n                    region.insertIntoDOM(sectionDiv, chart);\n                    if (chart.styledMode) {\n                        addClass(hiddenDiv, 'highcharts-visually-hidden');\n                    }\n                    else {\n                        visuallyHideElement(hiddenDiv);\n                    }\n                    unhideChartElementFromAT(chart, hiddenDiv);\n                    if (region.afterInserted) {\n                        region.afterInserted();\n                    }\n                }\n                else {\n                    if (sectionDiv.parentNode) {\n                        sectionDiv.parentNode.removeChild(sectionDiv);\n                    }\n                    region.element = null;\n                }\n            }\n            /**\n             * Apply a11y attributes to a screen reader info section\n             * @private\n             * @param {Highcharts.HTMLDOMElement} sectionDiv The section element\n             * @param {string} regionKey Name/key of the region we are setting attrs for\n             */\n            setScreenReaderSectionAttribs(sectionDiv, regionKey) {\n                const chart = this.chart, labelText = chart.langFormat('accessibility.screenReaderSection.' + regionKey +\n                    'RegionLabel', { chart: chart, chartTitle: getChartTitle(chart) }), sectionId = `highcharts-screen-reader-region-${regionKey}-${chart.index}`;\n                attr(sectionDiv, {\n                    id: sectionId,\n                    'aria-label': labelText || void 0\n                });\n                // Sections are wrapped to be positioned relatively to chart in case\n                // elements inside are tabbed to.\n                sectionDiv.style.position = 'relative';\n                if (labelText) {\n                    sectionDiv.setAttribute('role', chart.options.accessibility.landmarkVerbosity === 'all' ?\n                        'region' : 'group');\n                }\n            }\n            /**\n             * @private\n             */\n            defaultBeforeChartFormatter() {\n                const chart = this.chart, format = chart.options.accessibility.screenReaderSection\n                    .beforeChartFormat;\n                if (!format) {\n                    return '';\n                }\n                const axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = (chart.sonify &&\n                    chart.options.sonification &&\n                    chart.options.sonification.enabled), sonifyButtonId = 'highcharts-a11y-sonify-data-btn-' +\n                    chart.index, dataTableButtonId = 'hc-linkto-highcharts-data-table-' +\n                    chart.index, annotationsList = getAnnotationsInfoHTML(chart), annotationsTitleStr = chart.langFormat('accessibility.screenReaderSection.annotations.heading', { chart: chart }), context = {\n                    headingTagName: getHeadingTagNameForElement(chart.renderTo),\n                    chartTitle: getChartTitle(chart),\n                    typeDescription: this.getTypeDescriptionText(),\n                    chartSubtitle: this.getSubtitleText(),\n                    chartLongdesc: this.getLongdescText(),\n                    xAxisDescription: axesDesc.xAxis,\n                    yAxisDescription: axesDesc.yAxis,\n                    playAsSoundButton: shouldHaveSonifyBtn ?\n                        this.getSonifyButtonText(sonifyButtonId) : '',\n                    viewTableButton: chart.getCSV ?\n                        this.getDataTableButtonText(dataTableButtonId) : '',\n                    annotationsTitle: annotationsList ? annotationsTitleStr : '',\n                    annotationsList: annotationsList\n                }, formattedString = A11yI18n.i18nFormat(format, context, chart);\n                this.dataTableButtonId = dataTableButtonId;\n                this.sonifyButtonId = sonifyButtonId;\n                return stripEmptyHTMLTags(formattedString);\n            }\n            /**\n             * @private\n             */\n            defaultAfterChartFormatter() {\n                const chart = this.chart;\n                const format = chart.options.accessibility.screenReaderSection\n                    .afterChartFormat;\n                if (!format) {\n                    return '';\n                }\n                const context = { endOfChartMarker: this.getEndOfChartMarkerText() };\n                const formattedString = A11yI18n.i18nFormat(format, context, chart);\n                return stripEmptyHTMLTags(formattedString);\n            }\n            /**\n             * @private\n             */\n            getLinkedDescription() {\n                const el = this.linkedDescriptionElement, content = el && el.innerHTML || '';\n                return stripHTMLTagsFromString(content);\n            }\n            /**\n             * @private\n             */\n            getLongdescText() {\n                const chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();\n                return (chartOptions.accessibility.description ||\n                    linkedDescription ||\n                    captionText ||\n                    '');\n            }\n            /**\n             * @private\n             */\n            getTypeDescriptionText() {\n                const chart = this.chart;\n                return chart.types ?\n                    chart.options.accessibility.typeDescription ||\n                        getTypeDescription(chart, chart.types) : '';\n            }\n            /**\n             * @private\n             */\n            getDataTableButtonText(buttonId) {\n                const chart = this.chart, buttonText = chart.langFormat('accessibility.table.viewAsDataTableButtonText', { chart: chart, chartTitle: getChartTitle(chart) });\n                return '<button id=\"' + buttonId + '\">' + buttonText + '</button>';\n            }\n            /**\n             * @private\n             */\n            getSonifyButtonText(buttonId) {\n                const chart = this.chart;\n                if (chart.options.sonification &&\n                    chart.options.sonification.enabled === false) {\n                    return '';\n                }\n                const buttonText = chart.langFormat('accessibility.sonification.playAsSoundButtonText', { chart: chart, chartTitle: getChartTitle(chart) });\n                return '<button id=\"' + buttonId + '\">' + buttonText + '</button>';\n            }\n            /**\n             * @private\n             */\n            getSubtitleText() {\n                const subtitle = (this.chart.options.subtitle);\n                return stripHTMLTagsFromString(subtitle && subtitle.text || '');\n            }\n            /**\n             * @private\n             */\n            getEndOfChartMarkerText() {\n                const chart = this.chart, markerText = chart.langFormat('accessibility.screenReaderSection.endOfChartMarker', { chart: chart }), id = 'highcharts-end-of-chart-marker-' + chart.index;\n                return '<div id=\"' + id + '\">' + markerText + '</div>';\n            }\n            /**\n             * @private\n             * @param {Highcharts.Dictionary<string>} e\n             */\n            onDataTableCreated(e) {\n                const chart = this.chart;\n                if (chart.options.accessibility.enabled) {\n                    if (this.viewDataTableButton) {\n                        this.viewDataTableButton.setAttribute('aria-expanded', 'true');\n                    }\n                    const attributes = e.tree.attributes || {};\n                    attributes.tabindex = -1;\n                    attributes.summary = getTableSummary(chart);\n                    e.tree.attributes = attributes;\n                }\n            }\n            /**\n             * @private\n             */\n            focusDataTable() {\n                const tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName('table')[0];\n                if (table && table.focus) {\n                    table.focus();\n                }\n            }\n            /**\n             * @private\n             * @param {string} sonifyButtonId\n             */\n            initSonifyButton(sonifyButtonId) {\n                const el = this.sonifyButton = getElement(sonifyButtonId);\n                const chart = this.chart;\n                const defaultHandler = (e) => {\n                    if (el) {\n                        el.setAttribute('aria-hidden', 'true');\n                        el.setAttribute('aria-label', '');\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    const announceMsg = chart.langFormat('accessibility.sonification.playAsSoundClickAnnouncement', { chart: chart });\n                    this.announcer.announce(announceMsg);\n                    setTimeout(() => {\n                        if (el) {\n                            el.removeAttribute('aria-hidden');\n                            el.removeAttribute('aria-label');\n                        }\n                        if (chart.sonify) {\n                            chart.sonify();\n                        }\n                    }, 1000); // Delay to let screen reader speak the button press\n                };\n                if (el && chart) {\n                    el.setAttribute('tabindex', -1);\n                    el.onclick = function (e) {\n                        const onPlayAsSoundClick = (chart.options.accessibility &&\n                            chart.options.accessibility.screenReaderSection\n                                .onPlayAsSoundClick);\n                        (onPlayAsSoundClick || defaultHandler).call(this, e, chart);\n                    };\n                }\n            }\n            /**\n             * Set attribs and handlers for default viewAsDataTable button if exists.\n             * @private\n             * @param {string} tableButtonId\n             */\n            initDataTableButton(tableButtonId) {\n                const el = this.viewDataTableButton = getElement(tableButtonId), chart = this.chart, tableId = tableButtonId.replace('hc-linkto-', '');\n                if (el) {\n                    attr(el, {\n                        tabindex: -1,\n                        'aria-expanded': !!getElement(tableId)\n                    });\n                    el.onclick = chart.options.accessibility\n                        .screenReaderSection.onViewDataTableClick ||\n                        function () {\n                            chart.viewData();\n                        };\n                }\n            }\n            /**\n             * Return object with text description of each of the chart's axes.\n             * @private\n             */\n            getAxesDescription() {\n                const chart = this.chart, shouldDescribeColl = function (collectionKey, defaultCondition) {\n                    const axes = chart[collectionKey];\n                    return axes.length > 1 || axes[0] &&\n                        pick(axes[0].options.accessibility &&\n                            axes[0].options.accessibility.enabled, defaultCondition);\n                }, hasNoMap = !!chart.types &&\n                    chart.types.indexOf('map') < 0 &&\n                    chart.types.indexOf('treemap') < 0 &&\n                    chart.types.indexOf('tilemap') < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl('xAxis', !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl('yAxis', hasCartesian && hasNoMap), desc = {};\n                if (showXAxes) {\n                    desc.xAxis = this.getAxisDescriptionText('xAxis');\n                }\n                if (showYAxes) {\n                    desc.yAxis = this.getAxisDescriptionText('yAxis');\n                }\n                return desc;\n            }\n            /**\n             * @private\n             */\n            getAxisDescriptionText(collectionKey) {\n                const chart = this.chart;\n                const axes = chart[collectionKey];\n                return chart.langFormat('accessibility.axis.' + collectionKey + 'Description' + (axes.length > 1 ? 'Plural' : 'Singular'), {\n                    chart: chart,\n                    names: axes.map(function (axis) {\n                        return getAxisDescription(axis);\n                    }),\n                    ranges: axes.map(function (axis) {\n                        return getAxisRangeDescription(axis);\n                    }),\n                    numAxes: axes.length\n                });\n            }\n            /**\n             * Remove component traces\n             */\n            destroy() {\n                if (this.announcer) {\n                    this.announcer.destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return InfoRegionsComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/MenuComponent.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (Chart, U, AccessibilityComponent, KeyboardNavigationHandler, ChartUtilities, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for exporting menu.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { attr } = U;\n        const { getChartTitle, unhideChartElementFromAT } = ChartUtilities;\n        const { getFakeMouseEvent } = HTMLUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Get the wrapped export button element of a chart.\n         * @private\n         */\n        function getExportMenuButtonElement(chart) {\n            return chart.exportSVGElements && chart.exportSVGElements[0];\n        }\n        /**\n         * @private\n         */\n        function exportingShouldHaveA11y(chart) {\n            const exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);\n            return !!(exportingOpts &&\n                exportingOpts.enabled !== false &&\n                exportingOpts.accessibility &&\n                exportingOpts.accessibility.enabled &&\n                exportButton &&\n                exportButton.element);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The MenuComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.MenuComponent\n         */\n        class MenuComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             */\n            init() {\n                const chart = this.chart, component = this;\n                this.addEvent(chart, 'exportMenuShown', function () {\n                    component.onMenuShown();\n                });\n                this.addEvent(chart, 'exportMenuHidden', function () {\n                    component.onMenuHidden();\n                });\n                this.createProxyGroup();\n            }\n            /**\n             * @private\n             */\n            onMenuHidden() {\n                const menu = this.chart.exportContextMenu;\n                if (menu) {\n                    menu.setAttribute('aria-hidden', 'true');\n                }\n                this.setExportButtonExpandedState('false');\n            }\n            /**\n             * @private\n             */\n            onMenuShown() {\n                const chart = this.chart, menu = chart.exportContextMenu;\n                if (menu) {\n                    this.addAccessibleContextMenuAttribs();\n                    unhideChartElementFromAT(chart, menu);\n                }\n                this.setExportButtonExpandedState('true');\n            }\n            /**\n             * @private\n             * @param {string} stateStr\n             */\n            setExportButtonExpandedState(stateStr) {\n                if (this.exportButtonProxy) {\n                    this.exportButtonProxy.buttonElement.setAttribute('aria-expanded', stateStr);\n                }\n            }\n            /**\n             * Called on each render of the chart. We need to update positioning of the\n             * proxy overlay.\n             */\n            onChartRender() {\n                const chart = this.chart, focusEl = chart.focusElement, a11y = chart.accessibility;\n                this.proxyProvider.clearGroup('chartMenu');\n                this.proxyMenuButton();\n                if (this.exportButtonProxy &&\n                    focusEl &&\n                    focusEl === chart.exportingGroup) {\n                    if (focusEl.focusBorder) {\n                        chart.setFocusToElement(focusEl, this.exportButtonProxy.buttonElement);\n                    }\n                    else if (a11y) {\n                        a11y.keyboardNavigation.tabindexContainer.focus();\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            proxyMenuButton() {\n                const chart = this.chart;\n                const proxyProvider = this.proxyProvider;\n                const buttonEl = getExportMenuButtonElement(chart);\n                if (exportingShouldHaveA11y(chart) && buttonEl) {\n                    this.exportButtonProxy = proxyProvider.addProxyElement('chartMenu', { click: buttonEl }, {\n                        'aria-label': chart.langFormat('accessibility.exporting.menuButtonLabel', {\n                            chart: chart,\n                            chartTitle: getChartTitle(chart)\n                        }),\n                        'aria-expanded': false,\n                        title: chart.options.lang.contextButtonTitle || null\n                    });\n                }\n            }\n            /**\n             * @private\n             */\n            createProxyGroup() {\n                const chart = this.chart;\n                if (chart && this.proxyProvider) {\n                    this.proxyProvider.addGroup('chartMenu', 'div');\n                }\n            }\n            /**\n             * @private\n             */\n            addAccessibleContextMenuAttribs() {\n                const chart = this.chart, exportList = chart.exportDivElements;\n                if (exportList && exportList.length) {\n                    // Set tabindex on the menu items to allow focusing by script\n                    // Set role to give screen readers a chance to pick up the contents\n                    exportList.forEach((item) => {\n                        if (item) {\n                            if (item.tagName === 'LI' &&\n                                !(item.children && item.children.length)) {\n                                item.setAttribute('tabindex', -1);\n                            }\n                            else {\n                                item.setAttribute('aria-hidden', 'true');\n                            }\n                        }\n                    });\n                    // Set accessibility properties on parent div\n                    const parentDiv = (exportList[0] && exportList[0].parentNode);\n                    if (parentDiv) {\n                        attr(parentDiv, {\n                            'aria-hidden': void 0,\n                            'aria-label': chart.langFormat('accessibility.exporting.chartMenuLabel', { chart }),\n                            role: 'list' // Needed for webkit/VO\n                        });\n                    }\n                }\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                const keys = this.keyCodes, chart = this.chart, component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        // Arrow prev handler\n                        [\n                            [keys.left, keys.up],\n                            function () {\n                                return component.onKbdPrevious(this);\n                            }\n                        ],\n                        // Arrow next handler\n                        [\n                            [keys.right, keys.down],\n                            function () {\n                                return component.onKbdNext(this);\n                            }\n                        ],\n                        // Click handler\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onKbdClick(this);\n                            }\n                        ]\n                    ],\n                    // Only run exporting navigation if exporting support exists and is\n                    // enabled on chart\n                    validate: function () {\n                        return !!chart.exporting &&\n                            chart.options.exporting.enabled !== false &&\n                            chart.options.exporting.accessibility.enabled !==\n                                false;\n                    },\n                    // Focus export menu button\n                    init: function () {\n                        const proxy = component.exportButtonProxy;\n                        const svgEl = component.chart.exportingGroup;\n                        if (proxy && svgEl) {\n                            chart.setFocusToElement(svgEl, proxy.buttonElement);\n                        }\n                    },\n                    // Hide the menu\n                    terminate: function () {\n                        chart.hideExportMenu();\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdPrevious(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const a11yOptions = chart.options.accessibility;\n                const response = keyboardNavigationHandler.response;\n                // Try to highlight prev item in list. Highlighting e.g.\n                // separators will fail.\n                let i = chart.highlightedExportItemIx || 0;\n                while (i--) {\n                    if (chart.highlightExportItem(i)) {\n                        return response.success;\n                    }\n                }\n                // We failed, so wrap around or move to prev module\n                if (a11yOptions.keyboardNavigation.wrapAround) {\n                    chart.highlightLastExportItem();\n                    return response.success;\n                }\n                return response.prev;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdNext(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const a11yOptions = chart.options.accessibility;\n                const response = keyboardNavigationHandler.response;\n                // Try to highlight next item in list. Highlighting e.g.\n                // separators will fail.\n                for (let i = (chart.highlightedExportItemIx || 0) + 1; i < chart.exportDivElements.length; ++i) {\n                    if (chart.highlightExportItem(i)) {\n                        return response.success;\n                    }\n                }\n                // We failed, so wrap around or move to next module\n                if (a11yOptions.keyboardNavigation.wrapAround) {\n                    chart.highlightExportItem(0);\n                    return response.success;\n                }\n                return response.next;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdClick(keyboardNavigationHandler) {\n                const chart = this.chart;\n                const curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx];\n                const exportButtonElement = getExportMenuButtonElement(chart).element;\n                if (chart.openMenu) {\n                    this.fakeClickEvent(curHighlightedItem);\n                }\n                else {\n                    this.fakeClickEvent(exportButtonElement);\n                    chart.highlightExportItem(0);\n                }\n                return keyboardNavigationHandler.response.success;\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (MenuComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(ChartClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = Chart.prototype;\n                    chartProto.hideExportMenu = chartHideExportMenu;\n                    chartProto.highlightExportItem = chartHighlightExportItem;\n                    chartProto.highlightLastExportItem = chartHighlightLastExportItem;\n                    chartProto.showExportMenu = chartShowExportMenu;\n                }\n            }\n            MenuComponent.compose = compose;\n            /**\n             * Show the export menu and focus the first item (if exists).\n             *\n             * @private\n             * @function Highcharts.Chart#showExportMenu\n             */\n            function chartShowExportMenu() {\n                const exportButton = getExportMenuButtonElement(this);\n                if (exportButton) {\n                    const el = exportButton.element;\n                    if (el.onclick) {\n                        el.onclick(getFakeMouseEvent('click'));\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.Chart#hideExportMenu\n             */\n            function chartHideExportMenu() {\n                const chart = this, exportList = chart.exportDivElements;\n                if (exportList && chart.exportContextMenu && chart.openMenu) {\n                    // Reset hover states etc.\n                    exportList.forEach((el) => {\n                        if (el &&\n                            el.className === 'highcharts-menu-item' &&\n                            el.onmouseout) {\n                            el.onmouseout(getFakeMouseEvent('mouseout'));\n                        }\n                    });\n                    chart.highlightedExportItemIx = 0;\n                    // Hide the menu div\n                    chart.exportContextMenu.hideMenu();\n                    // Make sure the chart has focus and can capture keyboard events\n                    chart.container.focus();\n                }\n            }\n            /**\n             * Highlight export menu item by index.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightExportItem\n             */\n            function chartHighlightExportItem(ix) {\n                const listItem = this.exportDivElements && this.exportDivElements[ix];\n                const curHighlighted = this.exportDivElements &&\n                    this.exportDivElements[this.highlightedExportItemIx];\n                if (listItem &&\n                    listItem.tagName === 'LI' &&\n                    !(listItem.children && listItem.children.length)) {\n                    // Test if we have focus support for SVG elements\n                    const hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName('g')[0] || {}).focus;\n                    // Only focus if we can set focus back to the elements after\n                    // destroying the menu (#7422)\n                    if (listItem.focus && hasSVGFocusSupport) {\n                        listItem.focus();\n                    }\n                    if (curHighlighted && curHighlighted.onmouseout) {\n                        curHighlighted.onmouseout(getFakeMouseEvent('mouseout'));\n                    }\n                    if (listItem.onmouseover) {\n                        listItem.onmouseover(getFakeMouseEvent('mouseover'));\n                    }\n                    this.highlightedExportItemIx = ix;\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Try to highlight the last valid export menu item.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightLastExportItem\n             */\n            function chartHighlightLastExportItem() {\n                const chart = this;\n                if (chart.exportDivElements) {\n                    let i = chart.exportDivElements.length;\n                    while (i--) {\n                        if (chart.highlightExportItem(i)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n        })(MenuComponent || (MenuComponent = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MenuComponent;\n    });\n    _registerModule(_modules, 'Accessibility/KeyboardNavigation.js', [_modules['Core/Globals.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, MenuComponent, U, EventProvider, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Main keyboard navigation handling.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, win } = H;\n        const { addEvent, fireEvent } = U;\n        const { getElement, simulatedEventTarget } = HTMLUtilities;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The KeyboardNavigation class, containing the overall keyboard navigation\n         * logic for the chart.\n         *\n         * @requires module:modules/accessibility\n         *\n         * @private\n         * @class\n         * @param {Highcharts.Chart} chart\n         *        Chart object\n         * @param {Object} components\n         *        Map of component names to AccessibilityComponent objects.\n         * @name Highcharts.KeyboardNavigation\n         */\n        class KeyboardNavigation {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, components) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.components = void 0;\n                this.currentModuleIx = NaN;\n                this.eventProvider = void 0;\n                this.exitAnchor = void 0;\n                this.modules = [];\n                this.tabindexContainer = void 0;\n                this.init(chart, components);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the class\n             * @private\n             * @param {Highcharts.Chart} chart\n             *        Chart object\n             * @param {Object} components\n             *        Map of component names to AccessibilityComponent objects.\n             */\n            init(chart, components) {\n                const ep = this.eventProvider = new EventProvider();\n                this.chart = chart;\n                this.components = components;\n                this.modules = [];\n                this.currentModuleIx = 0;\n                this.update();\n                ep.addEvent(this.tabindexContainer, 'keydown', (e) => this.onKeydown(e));\n                ep.addEvent(this.tabindexContainer, 'focus', (e) => this.onFocus(e));\n                ['mouseup', 'touchend'].forEach((eventName) => ep.addEvent(doc, eventName, (e) => this.onMouseUp(e)));\n                ['mousedown', 'touchstart'].forEach((eventName) => ep.addEvent(chart.renderTo, eventName, () => {\n                    this.isClickingChart = true;\n                }));\n            }\n            /**\n             * Update the modules for the keyboard navigation.\n             * @param {Array<string>} [order]\n             *        Array specifying the tab order of the components.\n             */\n            update(order) {\n                const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;\n                this.updateContainerTabindex();\n                if (keyboardOptions &&\n                    keyboardOptions.enabled &&\n                    order &&\n                    order.length) {\n                    // We (still) have keyboard navigation. Update module list\n                    this.modules = order.reduce(function (modules, componentName) {\n                        const navModules = components[componentName]\n                            .getKeyboardNavigation();\n                        return modules.concat(navModules);\n                    }, []);\n                    this.updateExitAnchor();\n                }\n                else {\n                    this.modules = [];\n                    this.currentModuleIx = 0;\n                    this.removeExitAnchor();\n                }\n            }\n            /**\n             * We use an exit anchor to move focus out of chart whenever we want, by\n             * setting focus to this div and not preventing the default tab action. We\n             * also use this when users come back into the chart by tabbing back, in\n             * order to navigate from the end of the chart.\n             * @private\n             */\n            updateExitAnchor() {\n                const endMarkerId = `highcharts-end-of-chart-marker-${this.chart.index}`, endMarker = getElement(endMarkerId);\n                this.removeExitAnchor();\n                if (endMarker) {\n                    this.makeElementAnExitAnchor(endMarker);\n                    this.exitAnchor = endMarker;\n                }\n                else {\n                    this.createExitAnchor();\n                }\n            }\n            /**\n             * Move to prev/next module.\n             * @private\n             * @param {number} direction\n             * Direction to move. +1 for next, -1 for prev.\n             * @return {boolean}\n             * True if there was a valid module in direction.\n             */\n            move(direction) {\n                const curModule = this.modules && this.modules[this.currentModuleIx];\n                if (curModule && curModule.terminate) {\n                    curModule.terminate(direction);\n                }\n                // Remove existing focus border if any\n                if (this.chart.focusElement) {\n                    this.chart.focusElement.removeFocusBorder();\n                }\n                this.currentModuleIx += direction;\n                const newModule = this.modules && this.modules[this.currentModuleIx];\n                if (newModule) {\n                    if (newModule.validate && !newModule.validate()) {\n                        return this.move(direction); // Invalid module, recurse\n                    }\n                    if (newModule.init) {\n                        newModule.init(direction); // Valid module, init it\n                        return true;\n                    }\n                }\n                // No module\n                this.currentModuleIx = 0; // Reset counter\n                // Set focus to chart or exit anchor depending on direction\n                this.exiting = true;\n                if (direction > 0) {\n                    this.exitAnchor && this.exitAnchor.focus();\n                }\n                else {\n                    this.tabindexContainer.focus();\n                }\n                return false;\n            }\n            /**\n             * Function to run on container focus\n             * @private\n             * @param {global.FocusEvent} e Browser focus event.\n             */\n            onFocus(e) {\n                const chart = this.chart, focusComesFromChart = (e.relatedTarget &&\n                    chart.container.contains(e.relatedTarget)), a11yOptions = chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, enabled = keyboardOptions && keyboardOptions.enabled;\n                // Init keyboard nav if tabbing into chart\n                if (enabled &&\n                    !this.exiting &&\n                    !this.tabbingInBackwards &&\n                    !this.isClickingChart &&\n                    !focusComesFromChart) {\n                    const ix = this.getFirstValidModuleIx();\n                    if (ix !== null) {\n                        this.currentModuleIx = ix;\n                        this.modules[ix].init(1);\n                    }\n                }\n                this.exiting = false;\n            }\n            /**\n             * Reset chart navigation state if we mouse click and it's not already\n             * reset. Reset fully if outside the chart, otherwise just hide focus\n             * indicator.\n             * @private\n             */\n            onMouseUp(e) {\n                delete this.isClickingChart;\n                if (!this.keyboardReset &&\n                    e.relatedTarget !== simulatedEventTarget) {\n                    const chart = this.chart;\n                    if (!e.target ||\n                        !chart.container.contains(e.target)) {\n                        const curMod = this.modules &&\n                            this.modules[this.currentModuleIx || 0];\n                        if (curMod && curMod.terminate) {\n                            curMod.terminate();\n                        }\n                        this.currentModuleIx = 0;\n                    }\n                    if (chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                        delete chart.focusElement;\n                    }\n                    this.keyboardReset = true;\n                }\n            }\n            /**\n             * Function to run on keydown\n             * @private\n             * @param {global.KeyboardEvent} ev Browser keydown event.\n             */\n            onKeydown(ev) {\n                const e = ev || win.event, curNavModule = (this.modules &&\n                    this.modules.length &&\n                    this.modules[this.currentModuleIx]);\n                let preventDefault;\n                // Used for resetting nav state when clicking outside chart\n                this.keyboardReset = false;\n                // Used for sending focus out of the chart by the modules.\n                this.exiting = false;\n                // If there is a nav module for the current index, run it.\n                // Otherwise, we are outside of the chart in some direction.\n                if (curNavModule) {\n                    const response = curNavModule.run(e);\n                    if (response === curNavModule.response.success) {\n                        preventDefault = true;\n                    }\n                    else if (response === curNavModule.response.prev) {\n                        preventDefault = this.move(-1);\n                    }\n                    else if (response === curNavModule.response.next) {\n                        preventDefault = this.move(1);\n                    }\n                    if (preventDefault) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                }\n            }\n            /**\n             * Chart container should have tabindex if navigation is enabled.\n             * @private\n             */\n            updateContainerTabindex() {\n                const a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;\n                let tabindexContainer;\n                if (chart.renderTo.hasAttribute('tabindex')) {\n                    container.removeAttribute('tabindex');\n                    tabindexContainer = chart.renderTo;\n                }\n                else {\n                    tabindexContainer = container;\n                }\n                this.tabindexContainer = tabindexContainer;\n                const curTabindex = tabindexContainer.getAttribute('tabindex');\n                if (shouldHaveTabindex && !curTabindex) {\n                    tabindexContainer.setAttribute('tabindex', '0');\n                }\n                else if (!shouldHaveTabindex) {\n                    chart.container.removeAttribute('tabindex');\n                }\n            }\n            /**\n             * Add new exit anchor to the chart.\n             * @private\n             */\n            createExitAnchor() {\n                const chart = this.chart, exitAnchor = this.exitAnchor = doc.createElement('div');\n                chart.renderTo.appendChild(exitAnchor);\n                this.makeElementAnExitAnchor(exitAnchor);\n            }\n            /**\n             * Add attributes and events to an element to make it function as an\n             * exit anchor.\n             * @private\n             */\n            makeElementAnExitAnchor(el) {\n                const chartTabindex = this.tabindexContainer.getAttribute('tabindex') || 0;\n                el.setAttribute('class', 'highcharts-exit-anchor');\n                el.setAttribute('tabindex', chartTabindex);\n                el.setAttribute('aria-hidden', false);\n                // Handle focus\n                this.addExitAnchorEventsToEl(el);\n            }\n            /**\n             * Destroy the exit anchor and remove from DOM.\n             * @private\n             */\n            removeExitAnchor() {\n                if (this.exitAnchor && this.exitAnchor.parentNode) {\n                    this.exitAnchor.parentNode.removeChild(this.exitAnchor);\n                    delete this.exitAnchor;\n                }\n            }\n            /**\n             * Add focus handler to exit anchor element.\n             * @private\n             */\n            addExitAnchorEventsToEl(element) {\n                const chart = this.chart, keyboardNavigation = this;\n                this.eventProvider.addEvent(element, 'focus', function (ev) {\n                    const e = ev || win.event, focusComesFromChart = (e.relatedTarget &&\n                        chart.container.contains(e.relatedTarget)), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);\n                    if (chart.focusElement) {\n                        delete chart.focusElement;\n                    }\n                    if (comingInBackwards) {\n                        // Focus the container instead\n                        keyboardNavigation.tabbingInBackwards = true;\n                        keyboardNavigation.tabindexContainer.focus();\n                        delete keyboardNavigation.tabbingInBackwards;\n                        e.preventDefault();\n                        // Move to last valid keyboard nav module\n                        // Note the we don't run it, just set the index\n                        if (keyboardNavigation.modules &&\n                            keyboardNavigation.modules.length) {\n                            keyboardNavigation.currentModuleIx =\n                                keyboardNavigation.modules.length - 1;\n                            const curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];\n                            // Validate the module\n                            if (curModule &&\n                                curModule.validate && !curModule.validate()) {\n                                // Invalid. Try moving backwards to find next valid.\n                                keyboardNavigation.move(-1);\n                            }\n                            else if (curModule) {\n                                // We have a valid module, init it\n                                curModule.init(-1);\n                            }\n                        }\n                    }\n                    else {\n                        // Don't skip the next focus, we only skip once.\n                        keyboardNavigation.exiting = false;\n                    }\n                });\n            }\n            /**\n             * Get the ix of the first module that either does not require validation or\n             * validates positively.\n             * @private\n             */\n            getFirstValidModuleIx() {\n                const len = this.modules.length;\n                for (let i = 0; i < len; ++i) {\n                    const mod = this.modules[i];\n                    if (!mod.validate || mod.validate()) {\n                        return i;\n                    }\n                }\n                return null;\n            }\n            /**\n             * Remove all traces of keyboard navigation.\n             * @private\n             */\n            destroy() {\n                this.removeExitAnchor();\n                this.eventProvider.removeAddedEvents();\n                this.chart.container.removeAttribute('tabindex');\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (KeyboardNavigation) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Construction\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Composition function.\n             * @private\n             */\n            function compose(ChartClass) {\n                MenuComponent.compose(ChartClass);\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.dismissPopupContent = chartDismissPopupContent;\n                }\n                if (U.pushUnique(composedMembers, doc)) {\n                    addEvent(doc, 'keydown', documentOnKeydown);\n                }\n                return ChartClass;\n            }\n            KeyboardNavigation.compose = compose;\n            /**\n             * Dismiss popup content in chart, including export menu and tooltip.\n             * @private\n             */\n            function chartDismissPopupContent() {\n                const chart = this;\n                fireEvent(this, 'dismissPopupContent', {}, function () {\n                    if (chart.tooltip) {\n                        chart.tooltip.hide(0);\n                    }\n                    chart.hideExportMenu();\n                });\n            }\n            /**\n             * Add event listener to document to detect ESC key press and dismiss\n             * hover/popup content.\n             * @private\n             */\n            function documentOnKeydown(e) {\n                const keycode = e.which || e.keyCode;\n                const esc = 27;\n                if (keycode === esc && H.charts) {\n                    H.charts.forEach((chart) => {\n                        if (chart && chart.dismissPopupContent) {\n                            chart.dismissPopupContent();\n                        }\n                    });\n                }\n            }\n        })(KeyboardNavigation || (KeyboardNavigation = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return KeyboardNavigation;\n    });\n    _registerModule(_modules, 'Accessibility/Components/LegendComponent.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Legend/Legend.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (A, H, Legend, U, AccessibilityComponent, KeyboardNavigationHandler, CU, HU) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for chart legend.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { doc } = H;\n        const { addEvent, fireEvent, isNumber, pick, syncTimeout } = U;\n        const { getChartTitle } = CU;\n        const { stripHTMLTagsFromString: stripHTMLTags, addClass, removeClass } = HU;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function scrollLegendToItem(legend, itemIx) {\n            const itemPage = (legend.allItems[itemIx].legendItem || {}).pageIx, curPage = legend.currentPage;\n            if (typeof itemPage !== 'undefined' && itemPage + 1 !== curPage) {\n                legend.scroll(1 + itemPage - curPage);\n            }\n        }\n        /**\n         * @private\n         */\n        function shouldDoLegendA11y(chart) {\n            const items = chart.legend && chart.legend.allItems, legendA11yOptions = (chart.options.legend.accessibility || {}), unsupportedColorAxis = chart.colorAxis && chart.colorAxis.some((c) => !c.dataClasses || !c.dataClasses.length);\n            return !!(items && items.length &&\n                !unsupportedColorAxis &&\n                legendA11yOptions.enabled !== false);\n        }\n        /**\n         * @private\n         */\n        function setLegendItemHoverState(hoverActive, item) {\n            const legendItem = item.legendItem || {};\n            item.setState(hoverActive ? 'hover' : '', true);\n            for (const key of ['group', 'label', 'symbol']) {\n                const svgElement = legendItem[key];\n                const element = svgElement && svgElement.element || svgElement;\n                if (element) {\n                    fireEvent(element, hoverActive ? 'mouseover' : 'mouseout');\n                }\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The LegendComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.LegendComponent\n         */\n        class LegendComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.highlightedLegendItemIx = NaN;\n                this.proxyGroup = null;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const component = this;\n                this.recreateProxies();\n                // Note: Chart could create legend dynamically, so events cannot be\n                // tied to the component's chart's current legend.\n                // @todo 1. attach component to created legends\n                // @todo 2. move listeners to composition and access `this.component`\n                this.addEvent(Legend, 'afterScroll', function () {\n                    if (this.chart === component.chart) {\n                        component.proxyProvider.updateGroupProxyElementPositions('legend');\n                        component.updateLegendItemProxyVisibility();\n                        if (component.highlightedLegendItemIx > -1) {\n                            this.chart.highlightLegendItem(component.highlightedLegendItemIx);\n                        }\n                    }\n                });\n                this.addEvent(Legend, 'afterPositionItem', function (e) {\n                    if (this.chart === component.chart && this.chart.renderer) {\n                        component.updateProxyPositionForItem(e.item);\n                    }\n                });\n                this.addEvent(Legend, 'afterRender', function () {\n                    if (this.chart === component.chart &&\n                        this.chart.renderer &&\n                        component.recreateProxies()) {\n                        syncTimeout(() => component.proxyProvider\n                            .updateGroupProxyElementPositions('legend'), animObject(pick(this.chart.renderer.globalAnimation, true)).duration);\n                    }\n                });\n            }\n            /**\n             * Update visibility of legend items when using paged legend\n             * @private\n             */\n            updateLegendItemProxyVisibility() {\n                const chart = this.chart;\n                const legend = chart.legend;\n                const items = legend.allItems || [];\n                const curPage = legend.currentPage || 1;\n                const clipHeight = legend.clipHeight || 0;\n                let legendItem;\n                items.forEach((item) => {\n                    if (item.a11yProxyElement) {\n                        const hasPages = legend.pages && legend.pages.length;\n                        const proxyEl = item.a11yProxyElement.element;\n                        let hide = false;\n                        legendItem = item.legendItem || {};\n                        if (hasPages) {\n                            const itemPage = legendItem.pageIx || 0;\n                            const y = legendItem.y || 0;\n                            const h = legendItem.label ?\n                                Math.round(legendItem.label.getBBox().height) :\n                                0;\n                            hide = y + h - legend.pages[itemPage] > clipHeight ||\n                                itemPage !== curPage - 1;\n                        }\n                        if (hide) {\n                            if (chart.styledMode) {\n                                addClass(proxyEl, 'highcharts-a11y-invisible');\n                            }\n                            else {\n                                proxyEl.style.visibility = 'hidden';\n                            }\n                        }\n                        else {\n                            removeClass(proxyEl, 'highcharts-a11y-invisible');\n                            proxyEl.style.visibility = '';\n                        }\n                    }\n                });\n            }\n            /**\n             * @private\n             */\n            onChartRender() {\n                if (!shouldDoLegendA11y(this.chart)) {\n                    this.removeProxies();\n                }\n            }\n            /**\n             * @private\n             */\n            highlightAdjacentLegendPage(direction) {\n                const chart = this.chart;\n                const legend = chart.legend;\n                const curPageIx = legend.currentPage || 1;\n                const newPageIx = curPageIx + direction;\n                const pages = legend.pages || [];\n                if (newPageIx > 0 && newPageIx <= pages.length) {\n                    let i = 0, res;\n                    for (const item of legend.allItems) {\n                        if (((item.legendItem || {}).pageIx || 0) + 1 === newPageIx) {\n                            res = chart.highlightLegendItem(i);\n                            if (res) {\n                                this.highlightedLegendItemIx = i;\n                            }\n                        }\n                        ++i;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            updateProxyPositionForItem(item) {\n                if (item.a11yProxyElement) {\n                    item.a11yProxyElement.refreshPosition();\n                }\n            }\n            /**\n             * Returns false if legend a11y is disabled and proxies were not created,\n             * true otherwise.\n             * @private\n             */\n            recreateProxies() {\n                const focusedElement = doc.activeElement;\n                const proxyGroup = this.proxyGroup;\n                const shouldRestoreFocus = focusedElement && proxyGroup &&\n                    proxyGroup.contains(focusedElement);\n                this.removeProxies();\n                if (shouldDoLegendA11y(this.chart)) {\n                    this.addLegendProxyGroup();\n                    this.proxyLegendItems();\n                    this.updateLegendItemProxyVisibility();\n                    this.updateLegendTitle();\n                    if (shouldRestoreFocus) {\n                        this.chart.highlightLegendItem(this.highlightedLegendItemIx);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * @private\n             */\n            removeProxies() {\n                this.proxyProvider.removeGroup('legend');\n            }\n            /**\n             * @private\n             */\n            updateLegendTitle() {\n                const chart = this.chart;\n                const legendTitle = stripHTMLTags((chart.legend &&\n                    chart.legend.options.title &&\n                    chart.legend.options.title.text ||\n                    '').replace(/<br ?\\/?>/g, ' '));\n                const legendLabel = chart.langFormat('accessibility.legend.legendLabel' + (legendTitle ? '' : 'NoTitle'), {\n                    chart,\n                    legendTitle,\n                    chartTitle: getChartTitle(chart)\n                });\n                this.proxyProvider.updateGroupAttrs('legend', {\n                    'aria-label': legendLabel\n                });\n            }\n            /**\n             * @private\n             */\n            addLegendProxyGroup() {\n                const a11yOptions = this.chart.options.accessibility;\n                const groupRole = a11yOptions.landmarkVerbosity === 'all' ?\n                    'region' : null;\n                this.proxyGroup = this.proxyProvider.addGroup('legend', 'ul', {\n                    // Filled by updateLegendTitle, to keep up to date without\n                    // recreating group\n                    'aria-label': '_placeholder_',\n                    role: groupRole\n                });\n            }\n            /**\n             * @private\n             */\n            proxyLegendItems() {\n                const component = this, items = (this.chart.legend || {}).allItems || [];\n                let legendItem;\n                items.forEach((item) => {\n                    legendItem = item.legendItem || {};\n                    if (legendItem.label && legendItem.label.element) {\n                        component.proxyLegendItem(item);\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n             */\n            proxyLegendItem(item) {\n                const legendItem = item.legendItem || {};\n                if (!legendItem.label || !legendItem.group) {\n                    return;\n                }\n                const itemLabel = this.chart.langFormat('accessibility.legend.legendItem', {\n                    chart: this.chart,\n                    itemName: stripHTMLTags(item.name),\n                    item\n                });\n                const attribs = {\n                    tabindex: -1,\n                    'aria-pressed': item.visible,\n                    'aria-label': itemLabel\n                };\n                // Considers useHTML\n                const proxyPositioningElement = legendItem.group.div ?\n                    legendItem.label :\n                    legendItem.group;\n                item.a11yProxyElement = this.proxyProvider.addProxyElement('legend', {\n                    click: legendItem.label,\n                    visual: proxyPositioningElement.element\n                }, attribs);\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                const keys = this.keyCodes, component = this, chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.left, keys.right, keys.up, keys.down],\n                            function (keyCode) {\n                                return component.onKbdArrowKey(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onKbdClick(this);\n                            }\n                        ],\n                        [\n                            [keys.pageDown, keys.pageUp],\n                            function (keyCode) {\n                                const direction = keyCode === keys.pageDown ? 1 : -1;\n                                component.highlightAdjacentLegendPage(direction);\n                                return this.response.success;\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return component.shouldHaveLegendNavigation();\n                    },\n                    init: function () {\n                        chart.highlightLegendItem(0);\n                        component.highlightedLegendItemIx = 0;\n                    },\n                    terminate: function () {\n                        component.highlightedLegendItemIx = -1;\n                        chart.legend.allItems.forEach((item) => setLegendItemHoverState(false, item));\n                    }\n                });\n            }\n            /**\n             * Arrow key navigation\n             * @private\n             */\n            onKbdArrowKey(keyboardNavigationHandler, keyCode) {\n                const keys = this.keyCodes, response = keyboardNavigationHandler.response, chart = this.chart, a11yOptions = chart.options.accessibility, numItems = chart.legend.allItems.length, direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1;\n                const res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);\n                if (res) {\n                    this.highlightedLegendItemIx += direction;\n                    return response.success;\n                }\n                if (numItems > 1 &&\n                    a11yOptions.keyboardNavigation.wrapAround) {\n                    keyboardNavigationHandler.init(direction);\n                    return response.success;\n                }\n                return response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @return {number} Response code\n             */\n            onKbdClick(keyboardNavigationHandler) {\n                const legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];\n                if (legendItem && legendItem.a11yProxyElement) {\n                    legendItem.a11yProxyElement.click();\n                }\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             */\n            shouldHaveLegendNavigation() {\n                if (!shouldDoLegendA11y(this.chart)) {\n                    return false;\n                }\n                const chart = this.chart, legendOptions = chart.options.legend || {}, legendA11yOptions = (legendOptions.accessibility || {});\n                return !!(chart.legend.display &&\n                    legendA11yOptions.keyboardNavigation &&\n                    legendA11yOptions.keyboardNavigation.enabled);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (LegendComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Highlight legend item by index.\n             * @private\n             */\n            function chartHighlightLegendItem(ix) {\n                const items = this.legend.allItems;\n                const oldIx = this.accessibility &&\n                    this.accessibility.components.legend.highlightedLegendItemIx;\n                const itemToHighlight = items[ix], legendItem = itemToHighlight.legendItem || {};\n                if (itemToHighlight) {\n                    if (isNumber(oldIx) && items[oldIx]) {\n                        setLegendItemHoverState(false, items[oldIx]);\n                    }\n                    scrollLegendToItem(this.legend, ix);\n                    const legendItemProp = legendItem.label;\n                    const proxyBtn = itemToHighlight.a11yProxyElement &&\n                        itemToHighlight.a11yProxyElement.buttonElement;\n                    if (legendItemProp && legendItemProp.element && proxyBtn) {\n                        this.setFocusToElement(legendItemProp, proxyBtn);\n                    }\n                    setLegendItemHoverState(true, itemToHighlight);\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, LegendClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightLegendItem = chartHighlightLegendItem;\n                }\n                if (U.pushUnique(composedMembers, LegendClass)) {\n                    addEvent(LegendClass, 'afterColorizeItem', legendOnAfterColorizeItem);\n                }\n            }\n            LegendComponent.compose = compose;\n            /**\n             * Keep track of pressed state for legend items.\n             * @private\n             */\n            function legendOnAfterColorizeItem(e) {\n                const chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e.item;\n                if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {\n                    legendItem.a11yProxyElement.buttonElement.setAttribute('aria-pressed', e.visible ? 'true' : 'false');\n                }\n            }\n        })(LegendComponent || (LegendComponent = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return LegendComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesDescriber.js', [_modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Templating.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function (AnnotationsA11y, ChartUtilities, F, HTMLUtilities, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Place desriptions on a series and its points.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getPointAnnotationTexts } = AnnotationsA11y;\n        const { getAxisDescription, getSeriesFirstPointElement, getSeriesA11yElement, unhideChartElementFromAT } = ChartUtilities;\n        const { format, numberFormat } = F;\n        const { reverseChildNodes, stripHTMLTagsFromString: stripHTMLTags } = HTMLUtilities;\n        const { find, isNumber, isString, pick, defined } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function findFirstPointWithGraphic(point) {\n            const sourcePointIndex = point.index;\n            if (!point.series || !point.series.data || !defined(sourcePointIndex)) {\n                return null;\n            }\n            return find(point.series.data, function (p) {\n                return !!(p &&\n                    typeof p.index !== 'undefined' &&\n                    p.index > sourcePointIndex &&\n                    p.graphic &&\n                    p.graphic.element);\n            }) || null;\n        }\n        /**\n         * Whether or not we should add a mock point element in\n         * order to describe a point that has no graphic.\n         * @private\n         */\n        function shouldAddMockPoint(point) {\n            // Note: Sunburst series use isNull for hidden points on drilldown.\n            // Ignore these.\n            const series = point.series, chart = series && series.chart, isSunburst = series && series.is('sunburst'), isNull = point.isNull, shouldDescribeNull = chart &&\n                chart\n                    .options.accessibility.point.describeNull;\n            return isNull && !isSunburst && shouldDescribeNull;\n        }\n        /**\n         * @private\n         */\n        function makeMockElement(point, pos) {\n            const renderer = point.series.chart.renderer, mock = renderer.rect(pos.x, pos.y, 1, 1);\n            mock.attr({\n                'class': 'highcharts-a11y-mock-point',\n                fill: 'none',\n                opacity: 0,\n                'fill-opacity': 0,\n                'stroke-opacity': 0\n            });\n            return mock;\n        }\n        /**\n         * @private\n         */\n        function addMockPointElement(point) {\n            const series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ?\n                firstGraphic.parentGroup :\n                series.graph || series.group, mockPos = firstPointWithGraphic ? {\n                x: pick(point.plotX, firstPointWithGraphic.plotX, 0),\n                y: pick(point.plotY, firstPointWithGraphic.plotY, 0)\n            } : {\n                x: pick(point.plotX, 0),\n                y: pick(point.plotY, 0)\n            }, mockElement = makeMockElement(point, mockPos);\n            if (parentGroup && parentGroup.element) {\n                point.graphic = mockElement;\n                point.hasMockGraphic = true;\n                mockElement.add(parentGroup);\n                // Move to correct pos in DOM\n                parentGroup.element.insertBefore(mockElement.element, firstGraphic ? firstGraphic.element : null);\n                return mockElement.element;\n            }\n        }\n        /**\n         * @private\n         */\n        function hasMorePointsThanDescriptionThreshold(series) {\n            const chartA11yOptions = series.chart.options.accessibility, threshold = (chartA11yOptions.series.pointDescriptionEnabledThreshold);\n            return !!(threshold !== false &&\n                series.points &&\n                series.points.length >= threshold);\n        }\n        /**\n         * @private\n         */\n        function shouldSetScreenReaderPropsOnPoints(series) {\n            const seriesA11yOptions = series.options.accessibility || {};\n            return !hasMorePointsThanDescriptionThreshold(series) &&\n                !seriesA11yOptions.exposeAsGroupOnly;\n        }\n        /**\n         * @private\n         */\n        function shouldSetKeyboardNavPropsOnPoints(series) {\n            const chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;\n            return !!(series.points && (series.points.length <\n                seriesNavOptions.pointNavigationEnabledThreshold ||\n                seriesNavOptions.pointNavigationEnabledThreshold === false));\n        }\n        /**\n         * @private\n         */\n        function shouldDescribeSeriesElement(series) {\n            const chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;\n            return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption ||\n                exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));\n        }\n        /**\n         * @private\n         */\n        function pointNumberToString(point, value) {\n            const series = point.series, chart = series.chart, a11yPointOptions = chart.options.accessibility.point || {}, seriesA11yPointOptions = series.options.accessibility &&\n                series.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, lang = chart.options.lang;\n            if (isNumber(value)) {\n                return numberFormat(value, seriesA11yPointOptions.valueDecimals ||\n                    a11yPointOptions.valueDecimals ||\n                    tooltipOptions.valueDecimals ||\n                    -1, lang.decimalPoint, lang.accessibility.thousandsSep || lang.thousandsSep);\n            }\n            return value;\n        }\n        /**\n         * @private\n         */\n        function getSeriesDescriptionText(series) {\n            const seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;\n            return descOpt && series.chart.langFormat('accessibility.series.description', {\n                description: descOpt,\n                series: series\n            }) || '';\n        }\n        /**\n         * @private\n         */\n        function getSeriesAxisDescriptionText(series, axisCollection) {\n            const axis = series[axisCollection];\n            return series.chart.langFormat('accessibility.series.' + axisCollection + 'Description', {\n                name: getAxisDescription(axis),\n                series: series\n            });\n        }\n        /**\n         * Get accessible time description for a point on a datetime axis.\n         *\n         * @private\n         */\n        function getPointA11yTimeDescription(point) {\n            const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility &&\n                series.options.accessibility.point || {}, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;\n            if (dateXAxis) {\n                const tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat = seriesA11yOptions.dateFormatter &&\n                    seriesA11yOptions.dateFormatter(point) ||\n                    a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) ||\n                    seriesA11yOptions.dateFormat ||\n                    a11yOptions.dateFormat ||\n                    tooltipDateFormat;\n                return chart.time.dateFormat(dateFormat, point.x || 0, void 0);\n            }\n        }\n        /**\n         * @private\n         */\n        function getPointXDescription(point) {\n            const timeDesc = getPointA11yTimeDescription(point), xAxis = point.series.xAxis || {}, pointCategory = xAxis.categories && defined(point.category) &&\n                ('' + point.category).replace('<br/>', ' '), canUseId = defined(point.id) &&\n                ('' + point.id).indexOf('highcharts-') < 0, fallback = 'x, ' + point.x;\n            return point.name || timeDesc || pointCategory ||\n                (canUseId ? point.id : fallback);\n        }\n        /**\n         * @private\n         */\n        function getPointArrayMapValueDescription(point, prefix, suffix) {\n            const pre = prefix || '', suf = suffix || '', keyToValStr = function (key) {\n                const num = pointNumberToString(point, pick(point[key], point.options[key]));\n                return num !== void 0 ?\n                    key + ': ' + pre + num + suf :\n                    num;\n            }, pointArrayMap = point.series.pointArrayMap;\n            return pointArrayMap.reduce(function (desc, key) {\n                const propDesc = keyToValStr(key);\n                return propDesc ?\n                    (desc + (desc.length ? ', ' : '') + propDesc) :\n                    desc;\n            }, '');\n        }\n        /**\n         * @private\n         */\n        function getPointValue(point) {\n            const series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, seriesA11yPointOpts = series.chart.options.accessibility &&\n                series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = seriesA11yPointOpts.valuePrefix ||\n                a11yPointOpts.valuePrefix ||\n                tooltipOptions.valuePrefix ||\n                '', valueSuffix = seriesA11yPointOpts.valueSuffix ||\n                a11yPointOpts.valueSuffix ||\n                tooltipOptions.valueSuffix ||\n                '', fallbackKey = (typeof point.value !==\n                'undefined' ?\n                'value' : 'y'), fallbackDesc = pointNumberToString(point, point[fallbackKey]);\n            if (point.isNull) {\n                return series.chart.langFormat('accessibility.series.nullPointValue', {\n                    point: point\n                });\n            }\n            if (series.pointArrayMap) {\n                return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);\n            }\n            return valuePrefix + fallbackDesc + valueSuffix;\n        }\n        /**\n         * Return the description for the annotation(s) connected to a point, or\n         * empty string if none.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         * The data point to get the annotation info from.\n         * @return {string}\n         * Annotation description\n         */\n        function getPointAnnotationDescription(point) {\n            const chart = point.series.chart;\n            const langKey = 'accessibility.series.pointAnnotationsDescription';\n            const annotations = getPointAnnotationTexts(point);\n            const context = { point, annotations };\n            return annotations.length ? chart.langFormat(langKey, context) : '';\n        }\n        /**\n         * Return string with information about point.\n         * @private\n         */\n        function getPointValueDescription(point) {\n            const series = point.series, chart = series.chart, seriesA11yOptions = series.options.accessibility, seriesValueDescFormat = seriesA11yOptions && seriesA11yOptions.point &&\n                seriesA11yOptions.point.valueDescriptionFormat, pointValueDescriptionFormat = seriesValueDescFormat ||\n                chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick(series.xAxis &&\n                series.xAxis.options.accessibility &&\n                series.xAxis.options.accessibility.enabled, !chart.angular && series.type !== 'flowmap'), xDesc = showXDescription ? getPointXDescription(point) : '', context = {\n                point: point,\n                index: defined(point.index) ? (point.index + 1) : '',\n                xDescription: xDesc,\n                value: getPointValue(point),\n                separator: showXDescription ? ', ' : ''\n            };\n            return format(pointValueDescriptionFormat, context, chart);\n        }\n        /**\n         * Return string with information about point.\n         * @private\n         */\n        function defaultPointDescriptionFormatter(point) {\n            const series = point.series, shouldExposeSeriesName = series.chart.series.length > 1 ||\n                series.options.name, valText = getPointValueDescription(point), description = point.options && point.options.accessibility &&\n                point.options.accessibility.description, userDescText = description ? ' ' + description : '', seriesNameText = shouldExposeSeriesName ? ' ' + series.name + '.' : '', annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? ' ' + annotationsDesc : '';\n            point.accessibility = point.accessibility || {};\n            point.accessibility.valueDescription = valText;\n            return valText + userDescText + seriesNameText + pointAnnotationsText;\n        }\n        /**\n         * Set a11y props on a point element\n         * @private\n         * @param {Highcharts.Point} point\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} pointElement\n         */\n        function setPointScreenReaderAttribs(point, pointElement) {\n            var _a,\n                _b,\n                _c;\n            const series = point.series, seriesPointA11yOptions = ((_a = series.options.accessibility) === null || _a === void 0 ? void 0 : _a.point) || {}, a11yPointOptions = series.chart.options.accessibility.point || {}, label = stripHTMLTags((isString(seriesPointA11yOptions.descriptionFormat) &&\n                format(seriesPointA11yOptions.descriptionFormat, point, series.chart)) ||\n                ((_b = seriesPointA11yOptions.descriptionFormatter) === null || _b === void 0 ? void 0 : _b.call(seriesPointA11yOptions, point)) ||\n                (isString(a11yPointOptions.descriptionFormat) &&\n                    format(a11yPointOptions.descriptionFormat, point, series.chart)) ||\n                ((_c = a11yPointOptions.descriptionFormatter) === null || _c === void 0 ? void 0 : _c.call(a11yPointOptions, point)) ||\n                defaultPointDescriptionFormatter(point));\n            pointElement.setAttribute('role', 'img');\n            pointElement.setAttribute('aria-label', label);\n        }\n        /**\n         * Add accessible info to individual point elements of a series\n         * @private\n         * @param {Highcharts.Series} series\n         */\n        function describePointsInSeries(series) {\n            const setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series), shouldDescribeNullPoints = series.chart.options.accessibility\n                .point.describeNull;\n            if (setScreenReaderProps || setKeyboardProps) {\n                series.points.forEach((point) => {\n                    const pointEl = point.graphic && point.graphic.element ||\n                        shouldAddMockPoint(point) && addMockPointElement(point), pointA11yDisabled = (point.options &&\n                        point.options.accessibility &&\n                        point.options.accessibility.enabled === false);\n                    if (pointEl) {\n                        if (point.isNull && !shouldDescribeNullPoints) {\n                            pointEl.setAttribute('aria-hidden', true);\n                            return;\n                        }\n                        // We always set tabindex, as long as we are setting props.\n                        // When setting tabindex, also remove default outline to\n                        // avoid ugly border on click.\n                        pointEl.setAttribute('tabindex', '-1');\n                        if (!series.chart.styledMode) {\n                            pointEl.style.outline = 'none';\n                        }\n                        if (setScreenReaderProps && !pointA11yDisabled) {\n                            setPointScreenReaderAttribs(point, pointEl);\n                        }\n                        else {\n                            pointEl.setAttribute('aria-hidden', true);\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Return string with information about series.\n         * @private\n         */\n        function defaultSeriesDescriptionFormatter(series) {\n            const chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function (coll) {\n                return chart[coll] && chart[coll].length > 1 && series[coll];\n            }, seriesNumber = series.index + 1, xAxisInfo = getSeriesAxisDescriptionText(series, 'xAxis'), yAxisInfo = getSeriesAxisDescriptionText(series, 'yAxis'), summaryContext = {\n                seriesNumber,\n                series,\n                chart\n            }, combinationSuffix = chartTypes.length > 1 ? 'Combination' : '', summary = chart.langFormat('accessibility.series.summary.' + series.type + combinationSuffix, summaryContext) || chart.langFormat('accessibility.series.summary.default' + combinationSuffix, summaryContext), axisDescription = (shouldDescribeAxis('yAxis') ? ' ' + yAxisInfo + '.' : '') + (shouldDescribeAxis('xAxis') ? ' ' + xAxisInfo + '.' : ''), formatStr = pick(series.options.accessibility &&\n                series.options.accessibility.descriptionFormat, chart.options.accessibility.series.descriptionFormat, '');\n            return format(formatStr, {\n                seriesDescription: summary,\n                authorDescription: (description ? ' ' + description : ''),\n                axisDescription,\n                series,\n                chart,\n                seriesNumber\n            }, void 0);\n        }\n        /**\n         * Set a11y props on a series element\n         * @private\n         * @param {Highcharts.Series} series\n         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} seriesElement\n         */\n        function describeSeriesElement(series, seriesElement) {\n            const seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;\n            // Handle role attribute\n            if (seriesA11yOptions.exposeAsGroupOnly) {\n                seriesElement.setAttribute('role', 'img');\n            }\n            else if (landmarkVerbosity === 'all') {\n                seriesElement.setAttribute('role', 'region');\n            }\n            else {\n                seriesElement.setAttribute('role', 'group');\n            }\n            seriesElement.setAttribute('tabindex', '-1');\n            if (!series.chart.styledMode) {\n                // Don't show browser outline on click, despite tabindex\n                seriesElement.style.outline = 'none';\n            }\n            seriesElement.setAttribute('aria-label', stripHTMLTags(a11yOptions.series.descriptionFormatter &&\n                a11yOptions.series.descriptionFormatter(series) ||\n                defaultSeriesDescriptionFormatter(series)));\n        }\n        /**\n         * Put accessible info on series and points of a series.\n         * @param {Highcharts.Series} series The series to add info on.\n         */\n        function describeSeries(series) {\n            const chart = series.chart, firstPointEl = getSeriesFirstPointElement(series), seriesEl = getSeriesA11yElement(series), is3d = chart.is3d && chart.is3d();\n            if (seriesEl) {\n                // For some series types the order of elements do not match the\n                // order of points in series. In that case we have to reverse them\n                // in order for AT to read them out in an understandable order.\n                // Due to z-index issues we cannot do this for 3D charts.\n                if (seriesEl.lastChild === firstPointEl && !is3d) {\n                    reverseChildNodes(seriesEl);\n                }\n                describePointsInSeries(series);\n                unhideChartElementFromAT(chart, seriesEl);\n                if (shouldDescribeSeriesElement(series)) {\n                    describeSeriesElement(series, seriesEl);\n                }\n                else {\n                    seriesEl.removeAttribute('aria-label');\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const SeriesDescriber = {\n            defaultPointDescriptionFormatter,\n            defaultSeriesDescriptionFormatter,\n            describeSeries\n        };\n\n        return SeriesDescriber;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/NewDataAnnouncer.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function (H, U, Announcer, ChartUtilities, EventProvider, SeriesDescriber) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Handle announcing new data for a chart.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined } = U;\n        const { getChartTitle } = ChartUtilities;\n        const { defaultPointDescriptionFormatter, defaultSeriesDescriptionFormatter } = SeriesDescriber;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function chartHasAnnounceEnabled(chart) {\n            return !!chart.options.accessibility.announceNewData.enabled;\n        }\n        /**\n         * @private\n         */\n        function findPointInDataArray(point) {\n            const candidates = point.series.data.filter((candidate) => (point.x === candidate.x && point.y === candidate.y));\n            return candidates.length === 1 ? candidates[0] : point;\n        }\n        /**\n         * Get array of unique series from two arrays\n         * @private\n         */\n        function getUniqueSeries(arrayA, arrayB) {\n            const uniqueSeries = (arrayA || []).concat(arrayB || []).reduce((acc, cur) => {\n                acc[cur.name + cur.index] = cur;\n                return acc;\n            }, {});\n            return Object\n                .keys(uniqueSeries)\n                .map((ix) => uniqueSeries[ix]);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class NewDataAnnouncer {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Public\n                 *\n                 * */\n                this.announcer = void 0;\n                this.dirty = {\n                    allSeries: {}\n                };\n                this.eventProvider = void 0;\n                this.lastAnnouncementTime = 0;\n                this.chart = chart;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the new data announcer.\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                const announceOptions = (chart.options.accessibility.announceNewData);\n                const announceType = announceOptions.interruptUser ?\n                    'assertive' : 'polite';\n                this.lastAnnouncementTime = 0;\n                this.dirty = {\n                    allSeries: {}\n                };\n                this.eventProvider = new EventProvider();\n                this.announcer = new Announcer(chart, announceType);\n                this.addEventListeners();\n            }\n            /**\n             * Remove traces of announcer.\n             * @private\n             */\n            destroy() {\n                this.eventProvider.removeAddedEvents();\n                this.announcer.destroy();\n            }\n            /**\n             * Add event listeners for the announcer\n             * @private\n             */\n            addEventListeners() {\n                const announcer = this, chart = this.chart, e = this.eventProvider;\n                e.addEvent(chart, 'afterApplyDrilldown', function () {\n                    announcer.lastAnnouncementTime = 0;\n                });\n                e.addEvent(chart, 'afterAddSeries', function (e) {\n                    announcer.onSeriesAdded(e.series);\n                });\n                e.addEvent(chart, 'redraw', function () {\n                    announcer.announceDirtyData();\n                });\n            }\n            /**\n             * On new data series added, update dirty list.\n             * @private\n             * @param {Highcharts.Series} series\n             */\n            onSeriesAdded(series) {\n                if (chartHasAnnounceEnabled(this.chart)) {\n                    this.dirty.hasDirty = true;\n                    this.dirty.allSeries[series.name + series.index] = series;\n                    // Add it to newSeries storage unless we already have one\n                    this.dirty.newSeries = defined(this.dirty.newSeries) ?\n                        void 0 : series;\n                }\n            }\n            /**\n             * Gather what we know and announce the data to user.\n             * @private\n             */\n            announceDirtyData() {\n                const chart = this.chart, announcer = this;\n                if (chart.options.accessibility.announceNewData &&\n                    this.dirty.hasDirty) {\n                    let newPoint = this.dirty.newPoint;\n                    // If we have a single new point, see if we can find it in the\n                    // data array. Otherwise we can only pass through options to\n                    // the description builder, and it is a bit sparse in info.\n                    if (newPoint) {\n                        newPoint = findPointInDataArray(newPoint);\n                    }\n                    this.queueAnnouncement(Object\n                        .keys(this.dirty.allSeries)\n                        .map((ix) => announcer.dirty.allSeries[ix]), this.dirty.newSeries, newPoint);\n                    // Reset\n                    this.dirty = {\n                        allSeries: {}\n                    };\n                }\n            }\n            /**\n             * Announce to user that there is new data.\n             * @private\n             * @param {Array<Highcharts.Series>} dirtySeries\n             *          Array of series with new data.\n             * @param {Highcharts.Series} [newSeries]\n             *          If a single new series was added, a reference to this series.\n             * @param {Highcharts.Point} [newPoint]\n             *          If a single point was added, a reference to this point.\n             */\n            queueAnnouncement(dirtySeries, newSeries, newPoint) {\n                const chart = this.chart;\n                const annOptions = chart.options.accessibility.announceNewData;\n                if (annOptions.enabled) {\n                    const now = +new Date();\n                    const dTime = now - this.lastAnnouncementTime;\n                    const time = Math.max(0, annOptions.minAnnounceInterval - dTime);\n                    // Add series from previously queued announcement.\n                    const allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);\n                    // Build message and announce\n                    const message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);\n                    if (message) {\n                        // Is there already one queued?\n                        if (this.queuedAnnouncement) {\n                            clearTimeout(this.queuedAnnouncementTimer);\n                        }\n                        // Build the announcement\n                        this.queuedAnnouncement = {\n                            time: now,\n                            message: message,\n                            series: allSeries\n                        };\n                        // Queue the announcement\n                        this.queuedAnnouncementTimer = setTimeout(() => {\n                            if (this && this.announcer) {\n                                this.lastAnnouncementTime = +new Date();\n                                this.announcer.announce(this.queuedAnnouncement.message);\n                                delete this.queuedAnnouncement;\n                                delete this.queuedAnnouncementTimer;\n                            }\n                        }, time);\n                    }\n                }\n            }\n            /**\n             * Get announcement message for new data.\n             * @private\n             * @param {Array<Highcharts.Series>} dirtySeries\n             *          Array of series with new data.\n             * @param {Highcharts.Series} [newSeries]\n             *          If a single new series was added, a reference to this series.\n             * @param {Highcharts.Point} [newPoint]\n             *          If a single point was added, a reference to this point.\n             *\n             * @return {string|null}\n             * The announcement message to give to user.\n             */\n            buildAnnouncementMessage(dirtySeries, newSeries, newPoint) {\n                const chart = this.chart, annOptions = chart.options.accessibility.announceNewData;\n                // User supplied formatter?\n                if (annOptions.announcementFormatter) {\n                    const formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);\n                    if (formatterRes !== false) {\n                        return formatterRes.length ? formatterRes : null;\n                    }\n                }\n                // Default formatter - use lang options\n                const multiple = H.charts && H.charts.length > 1 ?\n                    'Multiple' : 'Single', langKey = newSeries ? 'newSeriesAnnounce' + multiple :\n                    newPoint ? 'newPointAnnounce' + multiple : 'newDataAnnounce', chartTitle = getChartTitle(chart);\n                return chart.langFormat('accessibility.announceNewData.' + langKey, {\n                    chartTitle: chartTitle,\n                    seriesDesc: newSeries ?\n                        defaultSeriesDescriptionFormatter(newSeries) :\n                        null,\n                    pointDesc: newPoint ?\n                        defaultPointDescriptionFormatter(newPoint) :\n                        null,\n                    point: newPoint,\n                    series: newSeries\n                });\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (NewDataAnnouncer) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            NewDataAnnouncer.composedMembers = [];\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            function compose(SeriesClass) {\n                if (U.pushUnique(NewDataAnnouncer.composedMembers, SeriesClass)) {\n                    addEvent(SeriesClass, 'addPoint', seriesOnAddPoint);\n                    addEvent(SeriesClass, 'updatedData', seriesOnUpdatedData);\n                }\n            }\n            NewDataAnnouncer.compose = compose;\n            /**\n             * On new point added, update dirty list.\n             * @private\n             * @param {Highcharts.Point} point\n             */\n            function seriesOnAddPoint(e) {\n                const chart = this.chart, newDataAnnouncer = this.newDataAnnouncer;\n                if (newDataAnnouncer &&\n                    newDataAnnouncer.chart === chart &&\n                    chartHasAnnounceEnabled(chart)) {\n                    // Add it to newPoint storage unless we already have one\n                    newDataAnnouncer.dirty.newPoint = (defined(newDataAnnouncer.dirty.newPoint) ?\n                        void 0 :\n                        e.point);\n                }\n            }\n            /**\n             * On new data in the series, make sure we add it to the dirty list.\n             * @private\n             * @param {Highcharts.Series} series\n             */\n            function seriesOnUpdatedData() {\n                const chart = this.chart, newDataAnnouncer = this.newDataAnnouncer;\n                if (newDataAnnouncer &&\n                    newDataAnnouncer.chart === chart &&\n                    chartHasAnnounceEnabled(chart)) {\n                    newDataAnnouncer.dirty.hasDirty = true;\n                    newDataAnnouncer.dirty.allSeries[this.name + this.index] = this;\n                }\n            }\n        })(NewDataAnnouncer || (NewDataAnnouncer = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NewDataAnnouncer;\n    });\n    _registerModule(_modules, 'Accessibility/ProxyElement.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function (H, U, EventProvider, ChartUtilities, HTMLUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Proxy elements are used to shadow SVG elements in HTML for assistive\n         *  technology, such as screen readers or voice input software.\n         *\n         *  The ProxyElement class represents such an element, and deals with\n         *  overlay positioning and mirroring events for the target.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { attr, css, merge } = U;\n        const { fireEventOnWrappedOrUnwrappedElement } = ChartUtilities;\n        const { cloneMouseEvent, cloneTouchEvent, getFakeMouseEvent, removeElement } = HTMLUtilities;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Represents a proxy element that overlays a target and relays events\n         * to its target.\n         *\n         * @private\n         * @class\n         */\n        class ProxyElement {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, target, groupType, attributes) {\n                this.chart = chart;\n                this.target = target;\n                this.groupType = groupType;\n                const isListItem = groupType === 'ul';\n                this.eventProvider = new EventProvider();\n                const wrapperEl = isListItem ? doc.createElement('li') : null;\n                const btnEl = this.buttonElement = doc.createElement('button');\n                if (!chart.styledMode) {\n                    this.hideButtonVisually(btnEl);\n                }\n                if (wrapperEl) {\n                    if (isListItem && !chart.styledMode) {\n                        wrapperEl.style.listStyle = 'none';\n                    }\n                    wrapperEl.appendChild(btnEl);\n                    this.element = wrapperEl;\n                }\n                else {\n                    this.element = btnEl;\n                }\n                this.updateTarget(target, attributes);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Fake a click event on the target.\n             */\n            click() {\n                const pos = this.getTargetPosition();\n                pos.x += pos.width / 2;\n                pos.y += pos.height / 2;\n                const fakeEventObject = getFakeMouseEvent('click', pos);\n                fireEventOnWrappedOrUnwrappedElement(this.target.click, fakeEventObject);\n            }\n            /**\n             * Update the target to be proxied. The position and events are updated to\n             * match the new target.\n             * @param target The new target definition\n             * @param attributes New HTML attributes to apply to the button. Set an\n             * attribute to null to remove.\n             */\n            updateTarget(target, attributes) {\n                this.target = target;\n                this.updateCSSClassName();\n                const attrs = attributes || {};\n                Object.keys(attrs).forEach((a) => {\n                    if (attrs[a] === null) {\n                        delete attrs[a];\n                    }\n                });\n                attr(this.buttonElement, merge({\n                    'aria-label': this.getTargetAttr(target.click, 'aria-label')\n                }, attrs));\n                this.eventProvider.removeAddedEvents();\n                this.addProxyEventsToButton(this.buttonElement, target.click);\n                this.refreshPosition();\n            }\n            /**\n             * Refresh the position of the proxy element to match the current target\n             */\n            refreshPosition() {\n                const bBox = this.getTargetPosition();\n                css(this.buttonElement, {\n                    width: (bBox.width || 1) + 'px',\n                    height: (bBox.height || 1) + 'px',\n                    left: (Math.round(bBox.x) || 0) + 'px',\n                    top: (Math.round(bBox.y) || 0) + 'px'\n                });\n            }\n            /**\n             * Remove button from DOM, and clear events.\n             */\n            remove() {\n                this.eventProvider.removeAddedEvents();\n                removeElement(this.element);\n            }\n            // -------------------------- private ------------------------------------\n            /**\n             * Update the CSS class name to match target\n             */\n            updateCSSClassName() {\n                const stringHasNoTooltip = (s) => (s.indexOf('highcharts-no-tooltip') > -1);\n                const legend = this.chart.legend;\n                const groupDiv = legend.group && legend.group.div;\n                const noTooltipOnGroup = stringHasNoTooltip(groupDiv && groupDiv.className || '');\n                const targetClassName = this.getTargetAttr(this.target.click, 'class') || '';\n                const noTooltipOnTarget = stringHasNoTooltip(targetClassName);\n                this.buttonElement.className = noTooltipOnGroup || noTooltipOnTarget ?\n                    'highcharts-a11y-proxy-button highcharts-no-tooltip' :\n                    'highcharts-a11y-proxy-button';\n            }\n            /**\n             * Mirror events for a proxy button to a target\n             */\n            addProxyEventsToButton(button, target) {\n                [\n                    'click', 'touchstart', 'touchend', 'touchcancel', 'touchmove',\n                    'mouseover', 'mouseenter', 'mouseleave', 'mouseout'\n                ].forEach((evtType) => {\n                    const isTouchEvent = evtType.indexOf('touch') === 0;\n                    this.eventProvider.addEvent(button, evtType, (e) => {\n                        const clonedEvent = isTouchEvent ?\n                            cloneTouchEvent(e) :\n                            cloneMouseEvent(e);\n                        if (target) {\n                            fireEventOnWrappedOrUnwrappedElement(target, clonedEvent);\n                        }\n                        e.stopPropagation();\n                        // #9682, #15318: Touch scrolling didnt work when touching\n                        // proxy\n                        if (!isTouchEvent) {\n                            e.preventDefault();\n                        }\n                    }, { passive: false });\n                });\n            }\n            /**\n             * Set visually hidden style on a proxy button\n             */\n            hideButtonVisually(button) {\n                css(button, {\n                    borderWidth: 0,\n                    backgroundColor: 'transparent',\n                    cursor: 'pointer',\n                    outline: 'none',\n                    opacity: 0.001,\n                    filter: 'alpha(opacity=1)',\n                    zIndex: 999,\n                    overflow: 'hidden',\n                    padding: 0,\n                    margin: 0,\n                    display: 'block',\n                    position: 'absolute',\n                    '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)'\n                });\n            }\n            /**\n             * Get the position relative to chart container for the target\n             */\n            getTargetPosition() {\n                const clickTarget = this.target.click;\n                // We accept both DOM elements and wrapped elements as click targets.\n                const clickTargetElement = clickTarget.element ?\n                    clickTarget.element :\n                    clickTarget;\n                const posElement = this.target.visual || clickTargetElement;\n                const chartDiv = this.chart.renderTo;\n                if (chartDiv && posElement && posElement.getBoundingClientRect) {\n                    const rectEl = posElement.getBoundingClientRect(), chartPos = this.chart.pointer.getChartPosition();\n                    return {\n                        x: (rectEl.left - chartPos.left) / chartPos.scaleX,\n                        y: (rectEl.top - chartPos.top) / chartPos.scaleY,\n                        width: rectEl.right / chartPos.scaleX -\n                            rectEl.left / chartPos.scaleX,\n                        height: rectEl.bottom / chartPos.scaleY -\n                            rectEl.top / chartPos.scaleY\n                    };\n                }\n                return { x: 0, y: 0, width: 1, height: 1 };\n            }\n            /**\n             * Get an attribute value of a target\n             */\n            getTargetAttr(target, key) {\n                if (target.element) {\n                    return target.element.getAttribute(key);\n                }\n                return target.getAttribute(key);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ProxyElement;\n    });\n    _registerModule(_modules, 'Accessibility/ProxyProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/ProxyElement.js']], function (H, U, CU, DOMElementProvider, HU, ProxyElement) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Proxy elements are used to shadow SVG elements in HTML for assistive\n         *  technology, such as screen readers or voice input software.\n         *\n         *  The ProxyProvider keeps track of all proxy elements of the a11y module,\n         *  and updating their order and positioning.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { attr, css } = U;\n        const { unhideChartElementFromAT } = CU;\n        const { removeElement, removeChildNodes } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Keeps track of all proxy elements and proxy groups.\n         *\n         * @private\n         * @class\n         */\n        class ProxyProvider {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.chart = chart;\n                this.domElementProvider = new DOMElementProvider();\n                this.groups = {};\n                this.groupOrder = [];\n                this.beforeChartProxyPosContainer = this.createProxyPosContainer('before');\n                this.afterChartProxyPosContainer = this.createProxyPosContainer('after');\n                this.update();\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable */\n            /**\n             * Add a new proxy element to a group, proxying a target control.\n             */\n            addProxyElement(groupKey, target, attributes) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.addProxyElement: Invalid group key ' + groupKey);\n                }\n                const proxy = new ProxyElement(this.chart, target, group.type, attributes);\n                group.proxyContainerElement.appendChild(proxy.element);\n                group.proxyElements.push(proxy);\n                return proxy;\n            }\n            /**\n             * Create a group that will contain proxy elements. The group order is\n             * automatically updated according to the last group order keys.\n             *\n             * Returns the added group.\n             */\n            addGroup(groupKey, groupType, attributes) {\n                const existingGroup = this.groups[groupKey];\n                if (existingGroup) {\n                    return existingGroup.groupElement;\n                }\n                const proxyContainer = this.domElementProvider.createElement(groupType);\n                // If we want to add a role to the group, and still use e.g.\n                // a list group, we need a wrapper div.\n                let groupElement;\n                if (attributes && attributes.role && groupType !== 'div') {\n                    groupElement = this.domElementProvider.createElement('div');\n                    groupElement.appendChild(proxyContainer);\n                }\n                else {\n                    groupElement = proxyContainer;\n                }\n                groupElement.className = 'highcharts-a11y-proxy-group highcharts-a11y-proxy-group-' +\n                    groupKey.replace(/\\W/g, '-');\n                this.groups[groupKey] = {\n                    proxyContainerElement: proxyContainer,\n                    groupElement,\n                    type: groupType,\n                    proxyElements: []\n                };\n                attr(groupElement, attributes || {});\n                if (groupType === 'ul') {\n                    proxyContainer.setAttribute('role', 'list'); // Needed for webkit\n                }\n                // Add the group to the end by default, and perhaps then we\n                // won't have to reorder the whole set of groups.\n                this.afterChartProxyPosContainer.appendChild(groupElement);\n                this.updateGroupOrder(this.groupOrder);\n                return groupElement;\n            }\n            /**\n             * Update HTML attributes of a group.\n             */\n            updateGroupAttrs(groupKey, attributes) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.updateGroupAttrs: Invalid group key ' + groupKey);\n                }\n                attr(group.groupElement, attributes);\n            }\n            /**\n             * Reorder the proxy groups.\n             *\n             * The group key \"series\" refers to the chart's data points / <svg> element.\n             * This is so that the keyboardNavigation.order option can be used to\n             * determine the proxy group order.\n             */\n            updateGroupOrder(groupKeys) {\n                // Store so that we can update order when a new group is created\n                this.groupOrder = groupKeys.slice();\n                // Don't unnecessarily reorder, because keyboard focus is lost\n                if (this.isDOMOrderGroupOrder()) {\n                    return;\n                }\n                const seriesIx = groupKeys.indexOf('series');\n                const beforeKeys = seriesIx > -1 ? groupKeys.slice(0, seriesIx) : groupKeys;\n                const afterKeys = seriesIx > -1 ? groupKeys.slice(seriesIx + 1) : [];\n                // Store focused element since it will be lost when reordering\n                const activeElement = doc.activeElement;\n                // Add groups to correct container\n                ['before', 'after'].forEach((pos) => {\n                    const posContainer = this[pos === 'before' ?\n                        'beforeChartProxyPosContainer' :\n                        'afterChartProxyPosContainer'];\n                    const keys = pos === 'before' ? beforeKeys : afterKeys;\n                    removeChildNodes(posContainer);\n                    keys.forEach((groupKey) => {\n                        const group = this.groups[groupKey];\n                        if (group) {\n                            posContainer.appendChild(group.groupElement);\n                        }\n                    });\n                });\n                // Attempt to restore focus after reordering, but note that this may\n                // cause screen readers re-announcing the button.\n                if ((this.beforeChartProxyPosContainer.contains(activeElement) ||\n                    this.afterChartProxyPosContainer.contains(activeElement)) &&\n                    activeElement && activeElement.focus) {\n                    activeElement.focus();\n                }\n            }\n            /**\n             * Remove all proxy elements in a group\n             */\n            clearGroup(groupKey) {\n                const group = this.groups[groupKey];\n                if (!group) {\n                    throw new Error('ProxyProvider.clearGroup: Invalid group key ' + groupKey);\n                }\n                removeChildNodes(group.proxyContainerElement);\n            }\n            /**\n             * Remove a group from the DOM and from the proxy provider's group list.\n             * All child elements are removed.\n             * If the group does not exist, nothing happens.\n             */\n            removeGroup(groupKey) {\n                const group = this.groups[groupKey];\n                if (group) {\n                    removeElement(group.groupElement);\n                    delete this.groups[groupKey];\n                }\n            }\n            /**\n             * Update the position and order of all proxy groups and elements\n             */\n            update() {\n                this.updatePosContainerPositions();\n                this.updateGroupOrder(this.groupOrder);\n                this.updateProxyElementPositions();\n            }\n            /**\n             * Update all proxy element positions\n             */\n            updateProxyElementPositions() {\n                Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));\n            }\n            /**\n             * Update a group's proxy elements' positions.\n             * If the group does not exist, nothing happens.\n             */\n            updateGroupProxyElementPositions(groupKey) {\n                const group = this.groups[groupKey];\n                if (group) {\n                    group.proxyElements.forEach((el) => el.refreshPosition());\n                }\n            }\n            /**\n             * Remove all added elements\n             */\n            destroy() {\n                this.domElementProvider.destroyCreatedElements();\n            }\n            // -------------------------- private ------------------------------------\n            /**\n             * Create and return a pos container element (the overall containers for\n             * the proxy groups).\n             */\n            createProxyPosContainer(classNamePostfix) {\n                const el = this.domElementProvider.createElement('div');\n                el.setAttribute('aria-hidden', 'false');\n                el.className = 'highcharts-a11y-proxy-container' + (classNamePostfix ? '-' + classNamePostfix : '');\n                css(el, {\n                    top: '0',\n                    left: '0'\n                });\n                if (!this.chart.styledMode) {\n                    el.style.whiteSpace = 'nowrap';\n                    el.style.position = 'absolute';\n                }\n                return el;\n            }\n            /**\n             * Get an array of group keys that corresponds to the current group order\n             * in the DOM.\n             */\n            getCurrentGroupOrderInDOM() {\n                const getGroupKeyFromElement = (el) => {\n                    const allGroups = Object.keys(this.groups);\n                    let i = allGroups.length;\n                    while (i--) {\n                        const groupKey = allGroups[i];\n                        const group = this.groups[groupKey];\n                        if (group && el === group.groupElement) {\n                            return groupKey;\n                        }\n                    }\n                };\n                const getChildrenGroupOrder = (el) => {\n                    const childrenOrder = [];\n                    const children = el.children;\n                    for (let i = 0; i < children.length; ++i) {\n                        const groupKey = getGroupKeyFromElement(children[i]);\n                        if (groupKey) {\n                            childrenOrder.push(groupKey);\n                        }\n                    }\n                    return childrenOrder;\n                };\n                const before = getChildrenGroupOrder(this.beforeChartProxyPosContainer);\n                const after = getChildrenGroupOrder(this.afterChartProxyPosContainer);\n                before.push('series');\n                return before.concat(after);\n            }\n            /**\n             * Check if the current DOM order matches the current group order, so that\n             * a reordering/update is unnecessary.\n             */\n            isDOMOrderGroupOrder() {\n                const domOrder = this.getCurrentGroupOrderInDOM();\n                const groupOrderWithGroups = this.groupOrder.filter((x) => x === 'series' || !!this.groups[x]);\n                let i = domOrder.length;\n                if (i !== groupOrderWithGroups.length) {\n                    return false;\n                }\n                while (i--) {\n                    if (domOrder[i] !== groupOrderWithGroups[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * Update the DOM positions of the before/after proxy\n             * positioning containers for the groups.\n             */\n            updatePosContainerPositions() {\n                const chart = this.chart;\n                // If exporting, don't add these containers to the DOM.\n                if (chart.renderer.forExport) {\n                    return;\n                }\n                const rendererSVGEl = chart.renderer.box;\n                chart.container.insertBefore(this.afterChartProxyPosContainer, rendererSVGEl.nextSibling);\n                chart.container.insertBefore(this.beforeChartProxyPosContainer, rendererSVGEl);\n                unhideChartElementFromAT(this.chart, this.afterChartProxyPosContainer);\n                unhideChartElementFromAT(this.chart, this.beforeChartProxyPosContainer);\n            }\n        }\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n\n        return ProxyProvider;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Declarations\n         *\n         * */\n        /**\n         * Language object. The language object is global and it can't be set\n         * on each chart initialization. Instead, use `Highcharts.setOptions` to\n         * set it before any chart is initialized.\n         *\n         * ```js\n         * Highcharts.setOptions({\n         *     lang: {\n         *         months: [\n         *             'Janvier', 'Février', 'Mars', 'Avril',\n         *             'Mai', 'Juin', 'Juillet', 'Août',\n         *             'Septembre', 'Octobre', 'Novembre', 'Décembre'\n         *         ],\n         *         weekdays: [\n         *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',\n         *             'Jeudi', 'Vendredi', 'Samedi'\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * @optionparent lang\n         */\n        const lang = {\n            /**\n             * The text for the label for the range selector buttons.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorZoom: 'Zoom',\n            /**\n             * The text for the label for the \"from\" input box in the range\n             * selector. Since v9.0, this string is empty as the label is not\n             * rendered by default.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorFrom: '',\n            /**\n             * The text for the label for the \"to\" input box in the range selector.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorTo: '→'\n        };\n        /**\n         * The range selector is a tool for selecting ranges to display within\n         * the chart. It provides buttons to select preconfigured ranges in\n         * the chart, like 1 day, 1 week, 1 month etc. It also provides input\n         * boxes where min and max dates can be manually input.\n         *\n         * @product      highstock gantt\n         * @optionparent rangeSelector\n         */\n        const rangeSelector = {\n            /**\n             * Whether to enable all buttons from the start. By default buttons are\n             * only enabled if the corresponding time range exists on the X axis,\n             * but enabling all buttons allows for dynamically loading different\n             * time ranges.\n             *\n             * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/\n             *         All buttons enabled\n             *\n             * @since     2.0.3\n             */\n            allButtonsEnabled: false,\n            /**\n             * An array of configuration objects for the buttons.\n             *\n             * Defaults to:\n             * ```js\n             * buttons: [{\n             *     type: 'month',\n             *     count: 1,\n             *     text: '1m',\n             *     title: 'View 1 month'\n             * }, {\n             *     type: 'month',\n             *     count: 3,\n             *     text: '3m',\n             *     title: 'View 3 months'\n             * }, {\n             *     type: 'month',\n             *     count: 6,\n             *     text: '6m',\n             *     title: 'View 6 months'\n             * }, {\n             *     type: 'ytd',\n             *     text: 'YTD',\n             *     title: 'View year to date'\n             * }, {\n             *     type: 'year',\n             *     count: 1,\n             *     text: '1y',\n             *     title: 'View 1 year'\n             * }, {\n             *     type: 'all',\n             *     text: 'All',\n             *     title: 'View all'\n             * }]\n             * ```\n             *\n             * @sample {highstock} stock/rangeselector/datagrouping/\n             *         Data grouping by buttons\n             *\n             * @type      {Array<*>}\n             */\n            buttons: void 0,\n            /**\n             * How many units of the defined type the button should span. If `type`\n             * is \"month\" and `count` is 3, the button spans three months.\n             *\n             * @type      {number}\n             * @default   1\n             * @apioption rangeSelector.buttons.count\n             */\n            /**\n             * Fires when clicking on the rangeSelector button. One parameter,\n             * event, is passed to the function, containing common event\n             * information.\n             *\n             * ```js\n             * click: function(e) {\n             *   console.log(this);\n             * }\n             * ```\n             *\n             * Return false to stop default button's click action.\n             *\n             * @sample {highstock} stock/rangeselector/button-click/\n             *         Click event on the button\n             *\n             * @type      {Highcharts.RangeSelectorClickCallbackFunction}\n             * @apioption rangeSelector.buttons.events.click\n             */\n            /**\n             * Additional range (in milliseconds) added to the end of the calculated\n             * time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMax\n             */\n            /**\n             * Additional range (in milliseconds) added to the start of the\n             * calculated time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMin\n             */\n            /**\n             * When buttons apply dataGrouping on a series, by default zooming\n             * in/out will deselect buttons and unset dataGrouping. Enable this\n             * option to keep buttons selected when extremes change.\n             *\n             * @sample {highstock} stock/rangeselector/preserve-datagrouping/\n             *         Different preserveDataGrouping settings\n             *\n             * @type      {boolean}\n             * @default   false\n             * @since     6.1.2\n             * @apioption rangeSelector.buttons.preserveDataGrouping\n             */\n            /**\n             * A custom data grouping object for each button.\n             *\n             * @see [series.dataGrouping](#plotOptions.series.dataGrouping)\n             *\n             * @sample {highstock} stock/rangeselector/datagrouping/\n             *         Data grouping by range selector buttons\n             *\n             * @type      {*}\n             * @extends   plotOptions.series.dataGrouping\n             * @apioption rangeSelector.buttons.dataGrouping\n             */\n            /**\n             * The text for the button itself.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.text\n             */\n            /**\n             * Explanation for the button, shown as a tooltip on hover, and used by\n             * assistive technology.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.title\n             */\n            /**\n             * Defined the time span for the button. Can be one of `millisecond`,\n             * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,\n             * and `all`.\n             *\n             * @type       {Highcharts.RangeSelectorButtonTypeValue}\n             * @apioption  rangeSelector.buttons.type\n             */\n            /**\n             * The space in pixels between the buttons in the range selector.\n             */\n            buttonSpacing: 5,\n            /**\n             * Whether to collapse the range selector buttons into a dropdown when\n             * there is not enough room to show everything in a single row, instead\n             * of dividing the range selector into multiple rows.\n             * Can be one of the following:\n             *  - `always`: Always collapse\n             *  - `responsive`: Only collapse when there is not enough room\n             *  - `never`: Never collapse\n             *\n             * @sample {highstock} stock/rangeselector/dropdown/\n             *         Dropdown option\n             *\n             * @validvalue [\"always\", \"responsive\", \"never\"]\n             * @since 9.0.0\n             */\n            dropdown: 'responsive',\n            /**\n             * Enable or disable the range selector. Default to `true` for stock\n             * charts, using the `stockChart` factory.\n             *\n             * @sample {highstock} stock/rangeselector/enabled/\n             *         Disable the range selector\n             *\n             * @type {boolean|undefined}\n             * @default {highstock} true\n             */\n            enabled: void 0,\n            /**\n             * The vertical alignment of the rangeselector box. Allowed properties\n             * are `top`, `middle`, `bottom`.\n             *\n             * @sample {highstock} stock/rangeselector/vertical-align-middle/\n             *         Middle\n             * @sample {highstock} stock/rangeselector/vertical-align-bottom/\n             *         Bottom\n             *\n             * @type  {Highcharts.VerticalAlignValue}\n             * @since 6.0.0\n             */\n            verticalAlign: 'top',\n            /**\n             * A collection of attributes for the buttons. The object takes SVG\n             * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,\n             * a collection of CSS properties for the text.\n             *\n             * The object can also be extended with states, so you can set\n             * presentational options for `hover`, `select` or `disabled` button\n             * states.\n             *\n             * CSS styles for the text label.\n             *\n             * In styled mode, the buttons are styled by the\n             * `.highcharts-range-selector-buttons .highcharts-button` rule with its\n             * different states.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.SVGAttributes}\n             */\n            buttonTheme: {\n                /** @ignore */\n                width: 28,\n                /** @ignore */\n                height: 18,\n                /** @ignore */\n                padding: 2,\n                /** @ignore */\n                zIndex: 7 // #484, #852\n            },\n            /**\n             * When the rangeselector is floating, the plot area does not reserve\n             * space for it. This opens for positioning anywhere on the chart.\n             *\n             * @sample {highstock} stock/rangeselector/floating/\n             *         Placing the range selector between the plot area and the\n             *         navigator\n             *\n             * @since 6.0.0\n             */\n            floating: false,\n            /**\n             * The x offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            x: 0,\n            /**\n             * The y offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            y: 0,\n            /**\n             * Deprecated. The height of the range selector. Currently it is\n             * calculated dynamically.\n             *\n             * @deprecated\n             * @type  {number|undefined}\n             * @since 2.1.9\n             */\n            height: void 0,\n            /**\n             * The border color of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.ColorString}\n             * @since     1.3.7\n             */\n            inputBoxBorderColor: 'none',\n            /**\n             * The pixel height of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @since     1.3.7\n             */\n            inputBoxHeight: 17,\n            /**\n             * The pixel width of the date input boxes. When `undefined`, the width\n             * is fitted to the rendered content.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type   {number|undefined}\n             * @since  1.3.7\n             */\n            inputBoxWidth: void 0,\n            /**\n             * The date format in the input boxes when not selected for editing.\n             * Defaults to `%e %b %Y`.\n             *\n             * This is used to determine which type of input to show,\n             * `datetime-local`, `date` or `time` and falling back to `text` when\n             * the browser does not support the input type or the format contains\n             * milliseconds.\n             *\n             * @sample {highstock} stock/rangeselector/input-type/\n             *         Input types\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputDateFormat: '%e %b %Y',\n            /**\n             * A custom callback function to parse values entered in the input boxes\n             * and return a valid JavaScript time as milliseconds since 1970.\n             * The first argument passed is a value to parse,\n             * second is a boolean indicating use of the UTC time.\n             *\n             * This will only get called for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             * @type      {Highcharts.RangeSelectorParseCallbackFunction}\n             * @since     1.3.3\n             */\n            inputDateParser: void 0,\n            /**\n             * The date format in the input boxes when they are selected for\n             * editing. This must be a format that is recognized by JavaScript\n             * Date.parse.\n             *\n             * This will only be used for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputEditDateFormat: '%Y-%m-%d',\n            /**\n             * Enable or disable the date input boxes.\n             */\n            inputEnabled: true,\n            /**\n             * Positioning for the input boxes. Allowed properties are `align`,\n             *  `x` and `y`.\n             *\n             * @since 1.2.4\n             */\n            inputPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'right',\n                /**\n                 * X offset of the input row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the input row.\n                 */\n                y: 0\n            },\n            /**\n             * The space in pixels between the labels and the date input boxes in\n             * the range selector.\n             *\n             * @since 9.0.0\n             */\n            inputSpacing: 5,\n            /**\n             * The index of the button to appear pre-selected.\n             *\n             * @type      {number}\n             */\n            selected: void 0,\n            /**\n             * Positioning for the button row.\n             *\n             * @since 1.2.4\n             */\n            buttonPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'left',\n                /**\n                 * X offset of the button row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the button row.\n                 */\n                y: 0\n            },\n            /**\n             * CSS for the HTML inputs in the range selector.\n             *\n             * In styled mode, the inputs are styled by the\n             * `.highcharts-range-input text` rule in SVG mode, and\n             * `input.highcharts-range-selector` when active.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.CSSObject}\n             * @apioption rangeSelector.inputStyle\n             */\n            inputStyle: {\n                /** @ignore */\n                color: \"#334eff\" /* Palette.highlightColor80 */,\n                /** @ignore */\n                cursor: 'pointer',\n                /** @ignore */\n                fontSize: '0.8em'\n            },\n            /**\n             * CSS styles for the labels - the Zoom, From and To texts.\n             *\n             * In styled mode, the labels are styled by the\n             * `.highcharts-range-label` class.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.CSSObject}\n             */\n            labelStyle: {\n                /** @ignore */\n                color: \"#666666\" /* Palette.neutralColor60 */,\n                /** @ignore */\n                fontSize: '0.8em'\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorDefaults = {\n            lang,\n            rangeSelector\n        };\n\n        return RangeSelectorDefaults;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorComposition.js', [_modules['Core/Defaults.js'], _modules['Stock/RangeSelector/RangeSelectorDefaults.js'], _modules['Core/Utilities.js']], function (D, RangeSelectorDefaults, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions, setOptions } = D;\n        const { addEvent, defined, extend, find, isNumber, merge, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const chartDestroyEvents = [];\n        const composedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let RangeSelectorConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the axis min value based on the range option and the current max. For\n         * stock charts this is extended via the {@link RangeSelector} so that if the\n         * selected range is a multiple of months or years, it is compensated for\n         * various month lengths.\n         *\n         * @private\n         * @function Highcharts.Axis#minFromRange\n         * @return {number|undefined}\n         *         The new minimum value.\n         */\n        function axisMinFromRange() {\n            const rangeOptions = this.range, type = rangeOptions.type, max = this.max, time = this.chart.time, \n            // Get the true range from a start date\n            getTrueRange = function (base, count) {\n                const timeName = type === 'year' ?\n                    'FullYear' : 'Month';\n                const date = new time.Date(base);\n                const basePeriod = time.get(timeName, date);\n                time.set(timeName, date, basePeriod + count);\n                if (basePeriod === time.get(timeName, date)) {\n                    time.set('Date', date, 0); // #6537\n                }\n                return date.getTime() - base;\n            };\n            let min, range;\n            if (isNumber(rangeOptions)) {\n                min = max - rangeOptions;\n                range = rangeOptions;\n            }\n            else if (rangeOptions) {\n                min = max + getTrueRange(max, -(rangeOptions.count || 1));\n                // Let the fixedRange reflect initial settings (#5930)\n                if (this.chart) {\n                    this.chart.fixedRange = max - min;\n                }\n            }\n            const dataMin = pick(this.dataMin, Number.MIN_VALUE);\n            if (!isNumber(min)) {\n                min = dataMin;\n            }\n            if (min <= dataMin) {\n                min = dataMin;\n                if (typeof range === 'undefined') { // #4501\n                    range = getTrueRange(min, rangeOptions.count);\n                }\n                this.newMax = Math.min(min + range, pick(this.dataMax, Number.MAX_VALUE));\n            }\n            if (!isNumber(max)) {\n                min = void 0;\n            }\n            else if (!isNumber(rangeOptions) &&\n                rangeOptions &&\n                rangeOptions._offsetMin) {\n                min += rangeOptions._offsetMin;\n            }\n            return min;\n        }\n        /**\n         * @private\n         */\n        function compose(AxisClass, ChartClass, RangeSelectorClass) {\n            RangeSelectorConstructor = RangeSelectorClass;\n            if (U.pushUnique(composedMembers, AxisClass)) {\n                AxisClass.prototype.minFromRange = axisMinFromRange;\n            }\n            if (U.pushUnique(composedMembers, ChartClass)) {\n                addEvent(ChartClass, 'afterGetContainer', onChartAfterGetContainer);\n                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);\n                addEvent(ChartClass, 'destroy', onChartDestroy);\n                addEvent(ChartClass, 'getMargins', onChartGetMargins);\n                addEvent(ChartClass, 'render', onChartRender);\n                addEvent(ChartClass, 'update', onChartUpdate);\n                const chartProto = ChartClass.prototype;\n                chartProto.callbacks.push(onChartCallback);\n            }\n            if (U.pushUnique(composedMembers, setOptions)) {\n                extend(defaultOptions, { rangeSelector: RangeSelectorDefaults.rangeSelector });\n                extend(defaultOptions.lang, RangeSelectorDefaults.lang);\n            }\n        }\n        /**\n         * Initialize rangeselector for stock charts\n         * @private\n         */\n        function onChartAfterGetContainer() {\n            if (this.options.rangeSelector &&\n                this.options.rangeSelector.enabled) {\n                this.rangeSelector = new RangeSelectorConstructor(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartBeforeRender() {\n            const chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector;\n            if (rangeSelector) {\n                if (isNumber(rangeSelector.deferredYTDClick)) {\n                    rangeSelector.clickButton(rangeSelector.deferredYTDClick);\n                    delete rangeSelector.deferredYTDClick;\n                }\n                axes.forEach((axis) => {\n                    axis.updateNames();\n                    axis.setScale();\n                });\n                chart.getAxisMargins();\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartCallback(chart) {\n            let extremes, legend, alignTo, verticalAlign;\n            const rangeSelector = chart.rangeSelector, redraw = () => {\n                if (rangeSelector) {\n                    extremes = chart.xAxis[0].getExtremes();\n                    legend = chart.legend;\n                    verticalAlign = (rangeSelector &&\n                        rangeSelector.options.verticalAlign);\n                    if (isNumber(extremes.min)) {\n                        rangeSelector.render(extremes.min, extremes.max);\n                    }\n                    // Re-align the legend so that it's below the rangeselector\n                    if (legend.display &&\n                        verticalAlign === 'top' &&\n                        verticalAlign === legend.options.verticalAlign) {\n                        // Create a new alignment box for the legend.\n                        alignTo = merge(chart.spacingBox);\n                        if (legend.options.layout === 'vertical') {\n                            alignTo.y = chart.plotTop;\n                        }\n                        else {\n                            alignTo.y += rangeSelector.getHeight();\n                        }\n                        legend.group.placed = false; // Don't animate the alignment.\n                        legend.align(alignTo);\n                    }\n                }\n            };\n            if (rangeSelector) {\n                const events = find(chartDestroyEvents, (e) => e[0] === chart);\n                if (!events) {\n                    chartDestroyEvents.push([chart, [\n                            // redraw the scroller on setExtremes\n                            addEvent(chart.xAxis[0], 'afterSetExtremes', function (e) {\n                                if (rangeSelector) {\n                                    rangeSelector.render(e.min, e.max);\n                                }\n                            }),\n                            // redraw the scroller chart resize\n                            addEvent(chart, 'redraw', redraw)\n                        ]]);\n                }\n                // do it now\n                redraw();\n            }\n        }\n        /**\n         * Remove resize/afterSetExtremes at chart destroy.\n         * @private\n         */\n        function onChartDestroy() {\n            for (let i = 0, iEnd = chartDestroyEvents.length; i < iEnd; ++i) {\n                const events = chartDestroyEvents[i];\n                if (events[0] === this) {\n                    events[1].forEach((unbind) => unbind());\n                    chartDestroyEvents.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function onChartGetMargins() {\n            const rangeSelector = this.rangeSelector;\n            if (rangeSelector) {\n                const rangeSelectorHeight = rangeSelector.getHeight();\n                if (this.extraTopMargin) {\n                    this.plotTop += rangeSelectorHeight;\n                }\n                if (this.extraBottomMargin) {\n                    this.marginBottom += rangeSelectorHeight;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartRender() {\n            const chart = this, rangeSelector = chart.rangeSelector;\n            if (rangeSelector && !rangeSelector.options.floating) {\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (verticalAlign === 'bottom') {\n                    this.extraBottomMargin = true;\n                }\n                else if (verticalAlign !== 'middle') {\n                    this.extraTopMargin = true;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartUpdate(e) {\n            const chart = this, options = e.options, optionsRangeSelector = options.rangeSelector, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;\n            let rangeSelector = chart.rangeSelector;\n            if (optionsRangeSelector &&\n                optionsRangeSelector.enabled &&\n                !defined(rangeSelector) &&\n                this.options.rangeSelector) {\n                this.options.rangeSelector.enabled = true;\n                this.rangeSelector = rangeSelector = new RangeSelectorConstructor(this);\n            }\n            this.extraBottomMargin = false;\n            this.extraTopMargin = false;\n            if (rangeSelector) {\n                onChartCallback(this);\n                const verticalAlign = (optionsRangeSelector &&\n                    optionsRangeSelector.verticalAlign) || (rangeSelector.options && rangeSelector.options.verticalAlign);\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n                if (this.extraBottomMargin !== extraBottomMarginWas ||\n                    this.extraTopMargin !== extraTopMarginWas) {\n                    this.isDirtyBox = true;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorComposition = {\n            compose\n        };\n\n        return RangeSelectorComposition;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelector.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Stock/RangeSelector/RangeSelectorComposition.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function (Axis, D, H, RangeSelectorComposition, SVGElement, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { addEvent, createElement, css, defined, destroyObjectProperties, discardElement, extend, fireEvent, isNumber, merge, objectEach, pad, pick, pInt, splat } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the preferred input type based on a date format string.\n         *\n         * @private\n         * @function preferredInputType\n         */\n        function preferredInputType(format) {\n            const ms = format.indexOf('%L') !== -1;\n            if (ms) {\n                return 'text';\n            }\n            const date = ['a', 'A', 'd', 'e', 'w', 'b', 'B', 'm', 'o', 'y', 'Y']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            const time = ['H', 'k', 'I', 'l', 'M', 'S']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            if (date && time) {\n                return 'datetime-local';\n            }\n            if (date) {\n                return 'date';\n            }\n            if (time) {\n                return 'time';\n            }\n            return 'text';\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The range selector.\n         *\n         * @private\n         * @class\n         * @name Highcharts.RangeSelector\n         * @param {Highcharts.Chart} chart\n         */\n        class RangeSelector {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass, ChartClass) {\n                RangeSelectorComposition.compose(AxisClass, ChartClass, RangeSelector);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.buttons = void 0;\n                this.buttonOptions = RangeSelector.prototype.defaultButtons;\n                this.initialButtonGroupWidth = 0;\n                this.options = void 0;\n                this.chart = chart;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * The method to run when one of the buttons in the range selectors is\n             * clicked\n             *\n             * @private\n             * @function Highcharts.RangeSelector#clickButton\n             * @param {number} i\n             *        The index of the button\n             * @param {boolean} [redraw]\n             */\n            clickButton(i, redraw) {\n                const rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {}, type = rangeOptions.type, dataGrouping = rangeOptions.dataGrouping;\n                let dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568\n                baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, addOffsetMin = true;\n                // chart has no data, base series is removed\n                if (dataMin === null || dataMax === null) {\n                    return;\n                }\n                // Set the fixed range before range is altered\n                chart.fixedRange = range;\n                rangeSelector.setSelected(i);\n                // Apply dataGrouping associated to button\n                if (dataGrouping) {\n                    this.forcedDataGrouping = true;\n                    Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);\n                    this.frozenStates = rangeOptions.preserveDataGrouping;\n                }\n                // Apply range\n                if (type === 'month' || type === 'year') {\n                    if (!baseAxis) {\n                        // This is set to the user options and picked up later when the\n                        // axis is instantiated so that we know the min and max.\n                        range = rangeOptions;\n                    }\n                    else {\n                        ctx = {\n                            range: rangeOptions,\n                            max: newMax,\n                            chart: chart,\n                            dataMin: dataMin,\n                            dataMax: dataMax\n                        };\n                        newMin = baseAxis.minFromRange.call(ctx);\n                        if (isNumber(ctx.newMax)) {\n                            newMax = ctx.newMax;\n                        }\n                        // #15799: offsetMin is added in minFromRange so that it works\n                        // with pre-selected buttons as well\n                        addOffsetMin = false;\n                    }\n                    // Fixed times like minutes, hours, days\n                }\n                else if (range) {\n                    newMin = Math.max(newMax - range, dataMin);\n                    newMax = Math.min(newMin + range, dataMax);\n                    addOffsetMin = false;\n                }\n                else if (type === 'ytd') {\n                    // On user clicks on the buttons, or a delayed action running from\n                    // the beforeRender event (below), the baseAxis is defined.\n                    if (baseAxis) {\n                        // When \"ytd\" is the pre-selected button for the initial view,\n                        // its calculation is delayed and rerun in the beforeRender\n                        // event (below). When the series are initialized, but before\n                        // the chart is rendered, we have access to the xData array\n                        // (#942).\n                        if (typeof dataMax === 'undefined' ||\n                            typeof dataMin === 'undefined') {\n                            dataMin = Number.MAX_VALUE;\n                            dataMax = Number.MIN_VALUE;\n                            chart.series.forEach((series) => {\n                                // reassign it to the last item\n                                const xData = series.xData;\n                                if (xData) {\n                                    dataMin = Math.min(xData[0], dataMin);\n                                    dataMax = Math.max(xData[xData.length - 1], dataMax);\n                                }\n                            });\n                            redraw = false;\n                        }\n                        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);\n                        newMin = rangeMin = ytdExtremes.min;\n                        newMax = ytdExtremes.max;\n                        // \"ytd\" is pre-selected. We don't yet have access to processed\n                        // point and extremes data (things like pointStart and pointInterval\n                        // are missing), so we delay the process (#942)\n                    }\n                    else {\n                        rangeSelector.deferredYTDClick = i;\n                        return;\n                    }\n                }\n                else if (type === 'all' && baseAxis) {\n                    // If the navigator exist and the axis range is declared reset that\n                    // range and from now on only use the range set by a user, #14742.\n                    if (chart.navigator && chart.navigator.baseSeries[0]) {\n                        chart.navigator.baseSeries[0].xAxis.options.range = void 0;\n                    }\n                    newMin = dataMin;\n                    newMax = dataMax;\n                }\n                if (addOffsetMin && rangeOptions._offsetMin && defined(newMin)) {\n                    newMin += rangeOptions._offsetMin;\n                }\n                if (rangeOptions._offsetMax && defined(newMax)) {\n                    newMax += rangeOptions._offsetMax;\n                }\n                if (this.dropdown) {\n                    this.dropdown.selectedIndex = i + 1;\n                }\n                // Update the chart\n                if (!baseAxis) {\n                    // Axis not yet instanciated. Temporarily set min and range\n                    // options and remove them on chart load (#4317).\n                    baseXAxisOptions = splat(chart.options.xAxis)[0];\n                    rangeSetting = baseXAxisOptions.range;\n                    baseXAxisOptions.range = range;\n                    minSetting = baseXAxisOptions.min;\n                    baseXAxisOptions.min = rangeMin;\n                    addEvent(chart, 'load', function resetMinAndRange() {\n                        baseXAxisOptions.range = rangeSetting;\n                        baseXAxisOptions.min = minSetting;\n                    });\n                }\n                else {\n                    // Existing axis object. Set extremes after render time.\n                    baseAxis.setExtremes(newMin, newMax, pick(redraw, true), void 0, // auto animation\n                    {\n                        trigger: 'rangeSelectorButton',\n                        rangeSelectorButton: rangeOptions\n                    });\n                }\n                fireEvent(this, 'afterBtnClick');\n            }\n            /**\n             * Set the selected option. This method only sets the internal flag, it\n             * doesn't update the buttons or the actual zoomed range.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setSelected\n             * @param {number} [selected]\n             */\n            setSelected(selected) {\n                this.selected = this.options.selected = selected;\n            }\n            /**\n             * Initialize the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#init\n             * @param {Highcharts.Chart} chart\n             */\n            init(chart) {\n                const rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = (options.buttons || rangeSelector.defaultButtons.slice()), selectedOption = options.selected, blurInputs = function () {\n                    const minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;\n                    // #3274 in some case blur is not defined\n                    if (minInput && (minInput.blur)) {\n                        fireEvent(minInput, 'blur');\n                    }\n                    if (maxInput && (maxInput.blur)) {\n                        fireEvent(maxInput, 'blur');\n                    }\n                };\n                rangeSelector.chart = chart;\n                rangeSelector.options = options;\n                rangeSelector.buttons = [];\n                rangeSelector.buttonOptions = buttonOptions;\n                this.eventsToUnbind = [];\n                this.eventsToUnbind.push(addEvent(chart.container, 'mousedown', blurInputs));\n                this.eventsToUnbind.push(addEvent(chart, 'resize', blurInputs));\n                // Extend the buttonOptions with actual range\n                buttonOptions.forEach(rangeSelector.computeButtonRange);\n                // zoomed range based on a pre-selected button index\n                if (typeof selectedOption !== 'undefined' &&\n                    buttonOptions[selectedOption]) {\n                    this.clickButton(selectedOption, false);\n                }\n                this.eventsToUnbind.push(addEvent(chart, 'load', function () {\n                    // If a data grouping is applied to the current button, release it\n                    // when extremes change\n                    if (chart.xAxis && chart.xAxis[0]) {\n                        addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                            if (this.max - this.min !==\n                                chart.fixedRange &&\n                                e.trigger !== 'rangeSelectorButton' &&\n                                e.trigger !== 'updatedData' &&\n                                rangeSelector.forcedDataGrouping &&\n                                !rangeSelector.frozenStates) {\n                                this.setDataGrouping(false, false);\n                            }\n                        });\n                    }\n                }));\n            }\n            /**\n             * Dynamically update the range selector buttons after a new range has been\n             * set\n             *\n             * @private\n             * @function Highcharts.RangeSelector#updateButtonStates\n             */\n            updateButtonStates() {\n                const rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, // A single day in milliseconds\n                unionExtremes = (chart.scroller &&\n                    chart.scroller.getUnionExtremes()) || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;\n                let selectedExists = isNumber(selected);\n                rangeSelector.buttonOptions.forEach((rangeOptions, i) => {\n                    const range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button = buttons[i], offsetRange = rangeOptions._offsetMax -\n                        rangeOptions._offsetMin, isSelected = i === selected, \n                    // Disable buttons where the range exceeds what is allowed in\n                    // the current view\n                    isTooGreatRange = range >\n                        dataMax - dataMin, \n                    // Disable buttons where the range is smaller than the minimum\n                    // range\n                    isTooSmallRange = range < baseAxis.minRange;\n                    let state = 0, \n                    // Do not select the YTD button if not explicitly told so\n                    isYTDButNotSelected = false, \n                    // Disable the All button if we're already showing all\n                    isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;\n                    // Months and years have a variable range so we check the extremes\n                    if ((type === 'month' || type === 'year') &&\n                        (actualRange + 36e5 >=\n                            { month: 28, year: 365 }[type] * day * count - offsetRange) &&\n                        (actualRange - 36e5 <=\n                            { month: 31, year: 366 }[type] * day * count + offsetRange)) {\n                        isSameRange = true;\n                    }\n                    else if (type === 'ytd') {\n                        isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;\n                        isYTDButNotSelected = !isSelected;\n                    }\n                    else if (type === 'all') {\n                        isSameRange = (baseAxis.max - baseAxis.min >=\n                            dataMax - dataMin);\n                        isAllButAlreadyShowingAll = (!isSelected &&\n                            selectedExists &&\n                            isSameRange);\n                    }\n                    // The new zoom area happens to match the range for a button - mark\n                    // it selected. This happens when scrolling across an ordinal gap.\n                    // It can be seen in the intraday demos when selecting 1h and scroll\n                    // across the night gap.\n                    const disable = (!allButtonsEnabled &&\n                        (isTooGreatRange ||\n                            isTooSmallRange ||\n                            isAllButAlreadyShowingAll ||\n                            hasNoData));\n                    const select = ((isSelected && isSameRange) ||\n                        (isSameRange && !selectedExists && !isYTDButNotSelected) ||\n                        (isSelected && rangeSelector.frozenStates));\n                    if (disable) {\n                        state = 3;\n                    }\n                    else if (select) {\n                        selectedExists = true; // Only one button can be selected\n                        state = 2;\n                    }\n                    // If state has changed, update the button\n                    if (button.state !== state) {\n                        button.setState(state);\n                        if (dropdown) {\n                            dropdown.options[i + 1].disabled = disable;\n                            if (state === 2) {\n                                dropdown.selectedIndex = i + 1;\n                            }\n                        }\n                        // Reset (#9209)\n                        if (state === 0 && selected === i) {\n                            rangeSelector.setSelected();\n                        }\n                    }\n                });\n            }\n            /**\n             * Compute and cache the range for an individual button\n             *\n             * @private\n             * @function Highcharts.RangeSelector#computeButtonRange\n             * @param {Highcharts.RangeSelectorButtonsOptions} rangeOptions\n             */\n            computeButtonRange(rangeOptions) {\n                const type = rangeOptions.type, count = rangeOptions.count || 1, \n                // these time intervals have a fixed number of milliseconds, as\n                // opposed to month, ytd and year\n                fixedTimes = {\n                    millisecond: 1,\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 24 * 3600 * 1000,\n                    week: 7 * 24 * 3600 * 1000\n                };\n                // Store the range on the button object\n                if (fixedTimes[type]) {\n                    rangeOptions._range = fixedTimes[type] * count;\n                }\n                else if (type === 'month' || type === 'year') {\n                    rangeOptions._range = {\n                        month: 30,\n                        year: 365\n                    }[type] * 24 * 36e5 * count;\n                }\n                rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);\n                rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);\n                rangeOptions._range +=\n                    rangeOptions._offsetMax - rangeOptions._offsetMin;\n            }\n            /**\n             * Get the unix timestamp of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getInputValue\n             */\n            getInputValue(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                const options = this.chart.options\n                    .rangeSelector;\n                const time = this.chart.time;\n                if (input) {\n                    return ((input.type === 'text' && options.inputDateParser) ||\n                        this.defaultInputDateParser)(input.value, time.useUTC, time);\n                }\n                return 0;\n            }\n            /**\n             * Set the internal and displayed value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputValue\n             */\n            setInputValue(name, inputTime) {\n                const options = this.options, time = this.chart.time, input = name === 'min' ? this.minInput : this.maxInput, dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;\n                if (input) {\n                    const hcTimeAttr = input.getAttribute('data-hc-time');\n                    let updatedTime = defined(hcTimeAttr) ? Number(hcTimeAttr) : void 0;\n                    if (defined(inputTime)) {\n                        const previousTime = updatedTime;\n                        if (defined(previousTime)) {\n                            input.setAttribute('data-hc-time-previous', previousTime);\n                        }\n                        input.setAttribute('data-hc-time', inputTime);\n                        updatedTime = inputTime;\n                    }\n                    input.value = time.dateFormat((this.inputTypeFormats[input.type] ||\n                        options.inputEditDateFormat), updatedTime);\n                    if (dateBox) {\n                        dateBox.attr({\n                            text: time.dateFormat(options.inputDateFormat, updatedTime)\n                        });\n                    }\n                }\n            }\n            /**\n             * Set the min and max value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputExtremes\n             */\n            setInputExtremes(name, min, max) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    const format = this.inputTypeFormats[input.type];\n                    const time = this.chart.time;\n                    if (format) {\n                        const newMin = time.dateFormat(format, min);\n                        if (input.min !== newMin) {\n                            input.min = newMin;\n                        }\n                        const newMax = time.dateFormat(format, max);\n                        if (input.max !== newMax) {\n                            input.max = newMax;\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#showInput\n             * @param {string} name\n             */\n            showInput(name) {\n                const dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input && dateBox && this.inputGroup) {\n                    const isTextInput = input.type === 'text';\n                    const { translateX, translateY } = this.inputGroup;\n                    const { inputBoxWidth } = this.options;\n                    css(input, {\n                        width: isTextInput ?\n                            ((dateBox.width + (inputBoxWidth ? -2 : 20)) + 'px') :\n                            'auto',\n                        height: (dateBox.height - 2) + 'px',\n                        border: '2px solid silver'\n                    });\n                    if (isTextInput && inputBoxWidth) {\n                        css(input, {\n                            left: (translateX + dateBox.x) + 'px',\n                            top: translateY + 'px'\n                        });\n                        // Inputs of types date, time or datetime-local should be centered\n                        // on top of the dateBox\n                    }\n                    else {\n                        css(input, {\n                            left: Math.min(Math.round(dateBox.x +\n                                translateX -\n                                (input.offsetWidth - dateBox.width) / 2), this.chart.chartWidth - input.offsetWidth) + 'px',\n                            top: (translateY - (input.offsetHeight - dateBox.height) / 2) + 'px'\n                        });\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideInput\n             * @param {string} name\n             */\n            hideInput(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    css(input, {\n                        top: '-9999em',\n                        border: 0,\n                        width: '1px',\n                        height: '1px'\n                    });\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#defaultInputDateParser\n             */\n            defaultInputDateParser(inputDate, useUTC, time) {\n                const hasTimezone = (str) => str.length > 6 &&\n                    (str.lastIndexOf('-') === str.length - 6 ||\n                        str.lastIndexOf('+') === str.length - 6);\n                let input = inputDate.split('/').join('-').split(' ').join('T');\n                if (input.indexOf('T') === -1) {\n                    input += 'T00:00';\n                }\n                if (useUTC) {\n                    input += 'Z';\n                }\n                else if (H.isSafari && !hasTimezone(input)) {\n                    const offset = new Date(input).getTimezoneOffset() / 60;\n                    input += offset <= 0 ? `+${pad(-offset)}:00` : `-${pad(offset)}:00`;\n                }\n                let date = Date.parse(input);\n                // If the value isn't parsed directly to a value by the\n                // browser's Date.parse method, try\n                // parsing it a different way\n                if (!isNumber(date)) {\n                    const parts = inputDate.split('-');\n                    date = Date.UTC(pInt(parts[0]), pInt(parts[1]) - 1, pInt(parts[2]));\n                }\n                if (time && useUTC && isNumber(date)) {\n                    date += time.getTimezoneOffset(date);\n                }\n                return date;\n            }\n            /**\n             * Draw either the 'from' or the 'to' HTML input box of the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#drawInput\n             */\n            drawInput(name) {\n                const { chart, div, inputGroup } = this;\n                const rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang = defaultOptions.lang, isMin = name === 'min';\n                /**\n                 * @private\n                 */\n                function updateExtremes() {\n                    const { maxInput, minInput } = rangeSelector, chartAxis = chart.xAxis[0], dataAxis = chart.scroller && chart.scroller.xAxis ?\n                        chart.scroller.xAxis :\n                        chartAxis, dataMin = dataAxis.dataMin, dataMax = dataAxis.dataMax;\n                    let value = rangeSelector.getInputValue(name);\n                    if (value !== Number(input.getAttribute('data-hc-time-previous')) &&\n                        isNumber(value)) {\n                        input.setAttribute('data-hc-time-previous', value);\n                        // Validate the extremes. If it goes beyound the data min or\n                        // max, use the actual data extreme (#2438).\n                        if (isMin && maxInput && isNumber(dataMin)) {\n                            if (value > Number(maxInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value < dataMin) {\n                                value = dataMin;\n                            }\n                        }\n                        else if (minInput && isNumber(dataMax)) {\n                            if (value < Number(minInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value > dataMax) {\n                                value = dataMax;\n                            }\n                        }\n                        // Set the extremes\n                        if (typeof value !== 'undefined') { // @todo typof undefined\n                            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: 'rangeSelectorInput' });\n                        }\n                    }\n                }\n                // Create the text label\n                const text = lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'] || '';\n                const label = renderer\n                    .label(text, 0)\n                    .addClass('highcharts-range-label')\n                    .attr({\n                    padding: text ? 2 : 0,\n                    height: text ? options.inputBoxHeight : 0\n                })\n                    .add(inputGroup);\n                // Create an SVG label that shows updated date ranges and and records\n                // click events that bring in the HTML input.\n                const dateBox = renderer\n                    .label('', 0)\n                    .addClass('highcharts-range-input')\n                    .attr({\n                    padding: 2,\n                    width: options.inputBoxWidth,\n                    height: options.inputBoxHeight,\n                    'text-align': 'center'\n                })\n                    .on('click', function () {\n                    // If it is already focused, the onfocus event doesn't fire\n                    // (#3713)\n                    rangeSelector.showInput(name);\n                    rangeSelector[name + 'Input'].focus();\n                });\n                if (!chart.styledMode) {\n                    dateBox.attr({\n                        stroke: options.inputBoxBorderColor,\n                        'stroke-width': 1\n                    });\n                }\n                dateBox.add(inputGroup);\n                // Create the HTML input element. This is rendered as 1x1 pixel then set\n                // to the right size when focused.\n                const input = createElement('input', {\n                    name: name,\n                    className: 'highcharts-range-selector'\n                }, void 0, div);\n                // #14788: Setting input.type to an unsupported type throws in IE, so\n                // we need to use setAttribute instead\n                input.setAttribute('type', preferredInputType(options.inputDateFormat || '%e %b %Y'));\n                if (!chart.styledMode) {\n                    // Styles\n                    label.css(merge(chartStyle, options.labelStyle));\n                    dateBox.css(merge({\n                        color: \"#333333\" /* Palette.neutralColor80 */\n                    }, chartStyle, options.inputStyle));\n                    css(input, extend({\n                        position: 'absolute',\n                        border: 0,\n                        boxShadow: '0 0 15px rgba(0,0,0,0.3)',\n                        width: '1px',\n                        height: '1px',\n                        padding: 0,\n                        textAlign: 'center',\n                        fontSize: chartStyle.fontSize,\n                        fontFamily: chartStyle.fontFamily,\n                        top: '-9999em' // #4798\n                    }, options.inputStyle));\n                }\n                // Blow up the input box\n                input.onfocus = () => {\n                    rangeSelector.showInput(name);\n                };\n                // Hide away the input box\n                input.onblur = () => {\n                    // update extermes only when inputs are active\n                    if (input === H.doc.activeElement) { // Only when focused\n                        // Update also when no `change` event is triggered, like when\n                        // clicking inside the SVG (#4710)\n                        updateExtremes();\n                    }\n                    // #10404 - move hide and blur outside focus\n                    rangeSelector.hideInput(name);\n                    rangeSelector.setInputValue(name);\n                    input.blur(); // #4606\n                };\n                let keyDown = false;\n                // handle changes in the input boxes\n                input.onchange = () => {\n                    // Update extremes and blur input when clicking date input calendar\n                    if (!keyDown) {\n                        updateExtremes();\n                        rangeSelector.hideInput(name);\n                        input.blur();\n                    }\n                };\n                input.onkeypress = (event) => {\n                    // IE does not fire onchange on enter\n                    if (event.keyCode === 13) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeydown = (event) => {\n                    keyDown = true;\n                    // Arrow keys\n                    if (event.keyCode === 38 || event.keyCode === 40) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeyup = () => {\n                    keyDown = false;\n                };\n                return { dateBox, input, label };\n            }\n            /**\n             * Get the position of the range selector buttons and inputs. This can be\n             * overridden from outside for custom positioning.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getPosition\n             */\n            getPosition() {\n                const chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === 'top' ?\n                    chart.plotTop - chart.axisOffset[0] :\n                    0; // set offset only for varticalAlign top\n                return {\n                    buttonTop: top + options.buttonPosition.y,\n                    inputTop: top + options.inputPosition.y - 10\n                };\n            }\n            /**\n             * Get the extremes of YTD. Will choose dataMax if its value is lower than\n             * the current timestamp. Will choose dataMin if its value is higher than\n             * the timestamp for the start of current year.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getYTDExtremes\n             * @return {*}\n             * Returns min and max for the YTD\n             */\n            getYTDExtremes(dataMax, dataMin, useUTC) {\n                const time = this.chart.time, now = new time.Date(dataMax), year = time.get('FullYear', now), startOfYear = useUTC ?\n                    time.Date.UTC(year, 0, 1) : // eslint-disable-line new-cap\n                    +new time.Date(year, 0, 1), min = Math.max(dataMin, startOfYear), ts = now.getTime();\n                return {\n                    max: Math.min(dataMax || ts, ts),\n                    min\n                };\n            }\n            /**\n             * Render the range selector including the buttons and the inputs. The first\n             * time render is called, the elements are created and positioned. On\n             * subsequent calls, they are moved and updated.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#render\n             * @param {number} [min]\n             *        X axis minimum\n             * @param {number} [max]\n             *        X axis maximum\n             */\n            render(min, max) {\n                const chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, \n                // Place inputs above the container\n                inputsZIndex = pick(chartOptions.chart.style &&\n                    chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;\n                if (options.enabled === false) {\n                    return;\n                }\n                // create the elements\n                if (!rendered) {\n                    this.group = renderer.g('range-selector-group')\n                        .attr({\n                        zIndex: 7\n                    })\n                        .add();\n                    this.div = createElement('div', void 0, {\n                        position: 'relative',\n                        height: 0,\n                        zIndex: inputsZIndex\n                    });\n                    if (this.buttonOptions.length) {\n                        this.renderButtons();\n                    }\n                    // First create a wrapper outside the container in order to make\n                    // the inputs work and make export correct\n                    if (container.parentNode) {\n                        container.parentNode.insertBefore(this.div, container);\n                    }\n                    if (inputEnabled) {\n                        // Create the group to keep the inputs\n                        this.inputGroup = renderer.g('input-group').add(this.group);\n                        const minElems = this.drawInput('min');\n                        this.minDateBox = minElems.dateBox;\n                        this.minLabel = minElems.label;\n                        this.minInput = minElems.input;\n                        const maxElems = this.drawInput('max');\n                        this.maxDateBox = maxElems.dateBox;\n                        this.maxLabel = maxElems.label;\n                        this.maxInput = maxElems.input;\n                    }\n                }\n                if (inputEnabled) {\n                    // Set or reset the input values\n                    this.setInputValue('min', min);\n                    this.setInputValue('max', max);\n                    const unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chart.xAxis[0] || {};\n                    if (defined(unionExtremes.dataMin) &&\n                        defined(unionExtremes.dataMax)) {\n                        const minRange = chart.xAxis[0].minRange || 0;\n                        this.setInputExtremes('min', unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue('max')) - minRange);\n                        this.setInputExtremes('max', Math.max(unionExtremes.dataMin, this.getInputValue('min')) + minRange, unionExtremes.dataMax);\n                    }\n                    // Reflow\n                    if (this.inputGroup) {\n                        let x = 0;\n                        [\n                            this.minLabel,\n                            this.minDateBox,\n                            this.maxLabel,\n                            this.maxDateBox\n                        ].forEach((label) => {\n                            if (label) {\n                                const { width } = label.getBBox();\n                                if (width) {\n                                    label.attr({ x });\n                                    x += width + options.inputSpacing;\n                                }\n                            }\n                        });\n                    }\n                }\n                this.alignElements();\n                this.rendered = true;\n            }\n            /**\n             * Render the range buttons. This only runs the first time, later the\n             * positioning is laid out in alignElements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#renderButtons\n             */\n            renderButtons() {\n                const { buttons, chart, options } = this;\n                const lang = defaultOptions.lang;\n                const renderer = chart.renderer;\n                const buttonTheme = merge(options.buttonTheme);\n                const states = buttonTheme && buttonTheme.states;\n                // Prevent the button from resetting the width when the button state\n                // changes since we need more control over the width when collapsing\n                // the buttons\n                const width = buttonTheme.width || 28;\n                delete buttonTheme.width;\n                delete buttonTheme.states;\n                this.buttonGroup = renderer.g('range-selector-buttons').add(this.group);\n                const dropdown = this.dropdown = createElement('select', void 0, {\n                    position: 'absolute',\n                    width: '1px',\n                    height: '1px',\n                    padding: 0,\n                    border: 0,\n                    top: '-9999em',\n                    cursor: 'pointer',\n                    opacity: 0.0001\n                }, this.div);\n                // Prevent page zoom on iPhone\n                addEvent(dropdown, 'touchstart', () => {\n                    dropdown.style.fontSize = '16px';\n                });\n                // Forward events from select to button\n                [\n                    [H.isMS ? 'mouseover' : 'mouseenter'],\n                    [H.isMS ? 'mouseout' : 'mouseleave'],\n                    ['change', 'click']\n                ].forEach(([from, to]) => {\n                    addEvent(dropdown, from, () => {\n                        const button = buttons[this.currentButtonIndex()];\n                        if (button) {\n                            fireEvent(button.element, to || from);\n                        }\n                    });\n                });\n                this.zoomText = renderer\n                    .label((lang && lang.rangeSelectorZoom) || '', 0)\n                    .attr({\n                    padding: options.buttonTheme.padding,\n                    height: options.buttonTheme.height,\n                    paddingLeft: 0,\n                    paddingRight: 0\n                })\n                    .add(this.buttonGroup);\n                if (!this.chart.styledMode) {\n                    this.zoomText.css(options.labelStyle);\n                    buttonTheme['stroke-width'] = pick(buttonTheme['stroke-width'], 0);\n                }\n                createElement('option', {\n                    textContent: this.zoomText.textStr,\n                    disabled: true\n                }, void 0, dropdown);\n                this.buttonOptions.forEach((rangeOptions, i) => {\n                    createElement('option', {\n                        textContent: rangeOptions.title || rangeOptions.text\n                    }, void 0, dropdown);\n                    buttons[i] = renderer\n                        .button(rangeOptions.text, 0, 0, (e) => {\n                        // extract events from button object and call\n                        const buttonEvents = (rangeOptions.events && rangeOptions.events.click);\n                        let callDefaultEvent;\n                        if (buttonEvents) {\n                            callDefaultEvent =\n                                buttonEvents.call(rangeOptions, e);\n                        }\n                        if (callDefaultEvent !== false) {\n                            this.clickButton(i);\n                        }\n                        this.isActive = true;\n                    }, buttonTheme, states && states.hover, states && states.select, states && states.disabled)\n                        .attr({\n                        'text-align': 'center',\n                        width\n                    })\n                        .add(this.buttonGroup);\n                    if (rangeOptions.title) {\n                        buttons[i].attr('title', rangeOptions.title);\n                    }\n                });\n            }\n            /**\n             * Align the elements horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignElements\n             */\n            alignElements() {\n                const { buttonGroup, buttons, chart, group, inputGroup, options, zoomText } = this;\n                const chartOptions = chart.options;\n                const navButtonOptions = (chartOptions.exporting &&\n                    chartOptions.exporting.enabled !== false &&\n                    chartOptions.navigation &&\n                    chartOptions.navigation.buttonOptions);\n                const { buttonPosition, inputPosition, verticalAlign } = options;\n                // Get the X offset required to avoid overlapping with the exporting\n                // button. This is is used both by the buttonGroup and the inputGroup.\n                const getXOffsetForExportButton = (group, position) => {\n                    if (navButtonOptions &&\n                        this.titleCollision(chart) &&\n                        verticalAlign === 'top' &&\n                        position.align === 'right' && ((position.y -\n                        group.getBBox().height - 12) <\n                        ((navButtonOptions.y || 0) +\n                            (navButtonOptions.height || 0) +\n                            chart.spacing[0]))) {\n                        return -40;\n                    }\n                    return 0;\n                };\n                let plotLeft = chart.plotLeft;\n                if (group && buttonPosition && inputPosition) {\n                    let translateX = buttonPosition.x - chart.spacing[3];\n                    if (buttonGroup) {\n                        this.positionButtons();\n                        if (!this.initialButtonGroupWidth) {\n                            let width = 0;\n                            if (zoomText) {\n                                width += zoomText.getBBox().width + 5;\n                            }\n                            buttons.forEach((button, i) => {\n                                width += button.width;\n                                if (i !== buttons.length - 1) {\n                                    width += options.buttonSpacing;\n                                }\n                            });\n                            this.initialButtonGroupWidth = width;\n                        }\n                        plotLeft -= chart.spacing[3];\n                        this.updateButtonStates();\n                        // Detect collision between button group and exporting\n                        const xOffsetForExportButton = getXOffsetForExportButton(buttonGroup, buttonPosition);\n                        this.alignButtonGroup(xOffsetForExportButton);\n                        // Skip animation\n                        group.placed = buttonGroup.placed = chart.hasLoaded;\n                    }\n                    let xOffsetForExportButton = 0;\n                    if (inputGroup) {\n                        // Detect collision between the input group and exporting button\n                        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);\n                        if (inputPosition.align === 'left') {\n                            translateX = plotLeft;\n                        }\n                        else if (inputPosition.align === 'right') {\n                            translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);\n                        }\n                        // Update the alignment to the updated spacing box\n                        inputGroup.align({\n                            y: inputPosition.y,\n                            width: inputGroup.getBBox().width,\n                            align: inputPosition.align,\n                            // fix wrong getBBox() value on right align\n                            x: inputPosition.x + translateX - 2\n                        }, true, chart.spacingBox);\n                        // Skip animation\n                        inputGroup.placed = chart.hasLoaded;\n                    }\n                    this.handleCollision(xOffsetForExportButton);\n                    // Vertical align\n                    group.align({\n                        verticalAlign\n                    }, true, chart.spacingBox);\n                    const alignTranslateY = group.alignAttr.translateY;\n                    // Set position\n                    let groupHeight = group.getBBox().height + 20; // # 20 padding\n                    let translateY = 0;\n                    // Calculate bottom position\n                    if (verticalAlign === 'bottom') {\n                        const legendOptions = chart.legend && chart.legend.options;\n                        const legendHeight = (legendOptions &&\n                            legendOptions.verticalAlign === 'bottom' &&\n                            legendOptions.enabled &&\n                            !legendOptions.floating ?\n                            (chart.legend.legendHeight +\n                                pick(legendOptions.margin, 10)) :\n                            0);\n                        groupHeight = groupHeight + legendHeight - 20;\n                        translateY = (alignTranslateY -\n                            groupHeight -\n                            (options.floating ? 0 : options.y) -\n                            (chart.titleOffset ? chart.titleOffset[2] : 0) -\n                            10 // 10 spacing\n                        );\n                    }\n                    if (verticalAlign === 'top') {\n                        if (options.floating) {\n                            translateY = 0;\n                        }\n                        if (chart.titleOffset && chart.titleOffset[0]) {\n                            translateY = chart.titleOffset[0];\n                        }\n                        translateY += ((chart.margin[0] - chart.spacing[0]) || 0);\n                    }\n                    else if (verticalAlign === 'middle') {\n                        if (inputPosition.y === buttonPosition.y) {\n                            translateY = alignTranslateY;\n                        }\n                        else if (inputPosition.y || buttonPosition.y) {\n                            if (inputPosition.y < 0 ||\n                                buttonPosition.y < 0) {\n                                translateY -= Math.min(inputPosition.y, buttonPosition.y);\n                            }\n                            else {\n                                translateY = alignTranslateY - groupHeight;\n                            }\n                        }\n                    }\n                    group.translate(options.x, options.y + Math.floor(translateY));\n                    // Translate HTML inputs\n                    const { minInput, maxInput, dropdown } = this;\n                    if (options.inputEnabled && minInput && maxInput) {\n                        minInput.style.marginTop = group.translateY + 'px';\n                        maxInput.style.marginTop = group.translateY + 'px';\n                    }\n                    if (dropdown) {\n                        dropdown.style.marginTop = group.translateY + 'px';\n                    }\n                }\n            }\n            /**\n             * Align the button group horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignButtonGroup\n             * @param {number} xOffsetForExportButton\n             * @param {number} [width]\n             */\n            alignButtonGroup(xOffsetForExportButton, width) {\n                const { chart, options, buttonGroup, buttons } = this;\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft - chart.spacing[3];\n                let translateX = buttonPosition.x - chart.spacing[3];\n                if (buttonPosition.align === 'right') {\n                    translateX += xOffsetForExportButton - plotLeft; // #13014\n                }\n                else if (buttonPosition.align === 'center') {\n                    translateX -= plotLeft / 2;\n                }\n                if (buttonGroup) {\n                    // Align button group\n                    buttonGroup.align({\n                        y: buttonPosition.y,\n                        width: pick(width, this.initialButtonGroupWidth),\n                        align: buttonPosition.align,\n                        x: translateX\n                    }, true, chart.spacingBox);\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#positionButtons\n             */\n            positionButtons() {\n                const { buttons, chart, options, zoomText } = this;\n                const verb = chart.hasLoaded ? 'animate' : 'attr';\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft;\n                let buttonLeft = plotLeft;\n                if (zoomText && zoomText.visibility !== 'hidden') {\n                    // #8769, allow dynamically updating margins\n                    zoomText[verb]({\n                        x: pick(plotLeft + buttonPosition.x, plotLeft)\n                    });\n                    // Button start position\n                    buttonLeft += buttonPosition.x +\n                        zoomText.getBBox().width + 5;\n                }\n                for (let i = 0, iEnd = this.buttonOptions.length; i < iEnd; ++i) {\n                    if (buttons[i].visibility !== 'hidden') {\n                        buttons[i][verb]({ x: buttonLeft });\n                        // increase button position for the next button\n                        buttonLeft += buttons[i].width + options.buttonSpacing;\n                    }\n                    else {\n                        buttons[i][verb]({ x: plotLeft });\n                    }\n                }\n            }\n            /**\n             * Handle collision between the button group and the input group\n             *\n             * @private\n             * @function Highcharts.RangeSelector#handleCollision\n             *\n             * @param  {number} xOffsetForExportButton\n             *                  The X offset of the group required to make room for the\n             *                  exporting button\n             */\n            handleCollision(xOffsetForExportButton) {\n                const { chart, buttonGroup, inputGroup } = this;\n                const { buttonPosition, dropdown, inputPosition } = this.options;\n                const maxButtonWidth = () => {\n                    let buttonWidth = 0;\n                    this.buttons.forEach((button) => {\n                        const bBox = button.getBBox();\n                        if (bBox.width > buttonWidth) {\n                            buttonWidth = bBox.width;\n                        }\n                    });\n                    return buttonWidth;\n                };\n                const groupsOverlap = (buttonGroupWidth) => {\n                    if (inputGroup && buttonGroup) {\n                        const inputGroupX = (inputGroup.alignAttr.translateX +\n                            inputGroup.alignOptions.x -\n                            xOffsetForExportButton +\n                            // getBBox for detecing left margin\n                            inputGroup.getBBox().x +\n                            // 2px padding to not overlap input and label\n                            2);\n                        const inputGroupWidth = inputGroup.alignOptions.width;\n                        const buttonGroupX = buttonGroup.alignAttr.translateX +\n                            buttonGroup.getBBox().x;\n                        return (buttonGroupX + buttonGroupWidth > inputGroupX) &&\n                            (inputGroupX + inputGroupWidth > buttonGroupX) &&\n                            (buttonPosition.y <\n                                (inputPosition.y +\n                                    inputGroup.getBBox().height));\n                    }\n                    return false;\n                };\n                const moveInputsDown = () => {\n                    if (inputGroup && buttonGroup) {\n                        inputGroup.attr({\n                            translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ?\n                                0 :\n                                -xOffsetForExportButton),\n                            translateY: inputGroup.alignAttr.translateY +\n                                buttonGroup.getBBox().height + 10\n                        });\n                    }\n                };\n                if (buttonGroup) {\n                    if (dropdown === 'always') {\n                        this.collapseButtons(xOffsetForExportButton);\n                        if (groupsOverlap(maxButtonWidth())) {\n                            // Move the inputs down if there is still a collision\n                            // after collapsing the buttons\n                            moveInputsDown();\n                        }\n                        return;\n                    }\n                    if (dropdown === 'never') {\n                        this.expandButtons();\n                    }\n                }\n                // Detect collision\n                if (inputGroup && buttonGroup) {\n                    if ((inputPosition.align === buttonPosition.align) ||\n                        // 20 is minimal spacing between elements\n                        groupsOverlap(this.initialButtonGroupWidth + 20)) {\n                        if (dropdown === 'responsive') {\n                            this.collapseButtons(xOffsetForExportButton);\n                            if (groupsOverlap(maxButtonWidth())) {\n                                moveInputsDown();\n                            }\n                        }\n                        else {\n                            moveInputsDown();\n                        }\n                    }\n                    else if (dropdown === 'responsive') {\n                        this.expandButtons();\n                    }\n                }\n                else if (buttonGroup && dropdown === 'responsive') {\n                    if (this.initialButtonGroupWidth > chart.plotWidth) {\n                        this.collapseButtons(xOffsetForExportButton);\n                    }\n                    else {\n                        this.expandButtons();\n                    }\n                }\n            }\n            /**\n             * Collapse the buttons and put the select element on top.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#collapseButtons\n             * @param {number} xOffsetForExportButton\n             */\n            collapseButtons(xOffsetForExportButton) {\n                const { buttons, buttonOptions, chart, dropdown, options, zoomText } = this;\n                const userButtonTheme = (chart.userOptions.rangeSelector &&\n                    chart.userOptions.rangeSelector.buttonTheme) || {};\n                const getAttribs = (text) => ({\n                    text: text ? `${text} ▾` : '▾',\n                    width: 'auto',\n                    paddingLeft: pick(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),\n                    paddingRight: pick(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)\n                });\n                if (zoomText) {\n                    zoomText.hide();\n                }\n                let hasActiveButton = false;\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    if (button.state !== 2) {\n                        button.hide();\n                    }\n                    else {\n                        button.show();\n                        button.attr(getAttribs(rangeOptions.text));\n                        hasActiveButton = true;\n                    }\n                });\n                if (!hasActiveButton) {\n                    if (dropdown) {\n                        dropdown.selectedIndex = 0;\n                    }\n                    buttons[0].show();\n                    buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));\n                }\n                const { align } = options.buttonPosition;\n                this.positionButtons();\n                if (align === 'right' || align === 'center') {\n                    this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);\n                }\n                this.showDropdown();\n            }\n            /**\n             * Show all the buttons and hide the select element.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#expandButtons\n             */\n            expandButtons() {\n                const { buttons, buttonOptions, options, zoomText } = this;\n                this.hideDropdown();\n                if (zoomText) {\n                    zoomText.show();\n                }\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    button.show();\n                    button.attr({\n                        text: rangeOptions.text,\n                        width: options.buttonTheme.width || 28,\n                        paddingLeft: pick(options.buttonTheme.paddingLeft, 'unset'),\n                        paddingRight: pick(options.buttonTheme.paddingRight, 'unset')\n                    });\n                    if (button.state < 2) {\n                        button.setState(0);\n                    }\n                });\n                this.positionButtons();\n            }\n            /**\n             * Get the index of the visible button when the buttons are collapsed.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#currentButtonIndex\n             */\n            currentButtonIndex() {\n                const { dropdown } = this;\n                if (dropdown && dropdown.selectedIndex > 0) {\n                    return dropdown.selectedIndex - 1;\n                }\n                return 0;\n            }\n            /**\n             * Position the select element on top of the button.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#showDropdown\n             */\n            showDropdown() {\n                const { buttonGroup, buttons, chart, dropdown } = this;\n                if (buttonGroup && dropdown) {\n                    const { translateX, translateY } = buttonGroup;\n                    const bBox = buttons[this.currentButtonIndex()].getBBox();\n                    css(dropdown, {\n                        left: (chart.plotLeft + translateX) + 'px',\n                        top: (translateY + 0.5) + 'px',\n                        width: bBox.width + 'px',\n                        height: bBox.height + 'px'\n                    });\n                    this.hasVisibleDropdown = true;\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideDropdown\n             */\n            hideDropdown() {\n                const { dropdown } = this;\n                if (dropdown) {\n                    css(dropdown, {\n                        top: '-9999em',\n                        width: '1px',\n                        height: '1px'\n                    });\n                    this.hasVisibleDropdown = false;\n                }\n            }\n            /**\n             * Extracts height of range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getHeight\n             * @return {number}\n             * Returns rangeSelector height\n             */\n            getHeight() {\n                const rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y;\n                let rangeSelectorHeight = 0;\n                if (options.height) {\n                    return options.height;\n                }\n                // Align the elements before we read the height in case we're switching\n                // between wrapped and non-wrapped layout\n                this.alignElements();\n                rangeSelectorHeight = rangeSelectorGroup ?\n                    // 13px to keep back compatibility\n                    (rangeSelectorGroup.getBBox(true).height) + 13 +\n                        yPosition :\n                    0;\n                const minPosition = Math.min(inputPositionY, buttonPositionY);\n                if ((inputPositionY < 0 && buttonPositionY < 0) ||\n                    (inputPositionY > 0 && buttonPositionY > 0)) {\n                    rangeSelectorHeight += Math.abs(minPosition);\n                }\n                return rangeSelectorHeight;\n            }\n            /**\n             * Detect collision with title or subtitle\n             *\n             * @private\n             * @function Highcharts.RangeSelector#titleCollision\n             * @return {boolean}\n             * Returns collision status\n             */\n            titleCollision(chart) {\n                return !(chart.options.title.text ||\n                    chart.options.subtitle.text);\n            }\n            /**\n             * Update the range selector with new options\n             *\n             * @private\n             * @function Highcharts.RangeSelector#update\n             * @param {Highcharts.RangeSelectorOptions} options\n             */\n            update(options) {\n                const chart = this.chart;\n                merge(true, chart.options.rangeSelector, options);\n                this.destroy();\n                this.init(chart);\n                this.render();\n            }\n            /**\n             * Destroys allocated elements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#destroy\n             */\n            destroy() {\n                const rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;\n                if (rSelector.eventsToUnbind) {\n                    rSelector.eventsToUnbind.forEach((unbind) => unbind());\n                    rSelector.eventsToUnbind = void 0;\n                }\n                // Destroy elements in collections\n                destroyObjectProperties(rSelector.buttons);\n                // Clear input element events\n                if (minInput) {\n                    minInput.onfocus = minInput.onblur = minInput.onchange = null;\n                }\n                if (maxInput) {\n                    maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n                }\n                // Destroy HTML and SVG elements\n                objectEach(rSelector, function (val, key) {\n                    if (val && key !== 'chart') {\n                        if (val instanceof SVGElement) {\n                            // SVGElement\n                            val.destroy();\n                        }\n                        else if (val instanceof window.HTMLElement) {\n                            // HTML element\n                            discardElement(val);\n                        }\n                    }\n                    if (val !== RangeSelector.prototype[key]) {\n                        rSelector[key] = null;\n                    }\n                }, this);\n            }\n        }\n        extend(RangeSelector.prototype, {\n            /**\n             * The default buttons for pre-selecting time frames.\n             * @private\n             */\n            defaultButtons: [{\n                    type: 'month',\n                    count: 1,\n                    text: '1m',\n                    title: 'View 1 month'\n                }, {\n                    type: 'month',\n                    count: 3,\n                    text: '3m',\n                    title: 'View 3 months'\n                }, {\n                    type: 'month',\n                    count: 6,\n                    text: '6m',\n                    title: 'View 6 months'\n                }, {\n                    type: 'ytd',\n                    text: 'YTD',\n                    title: 'View year to date'\n                }, {\n                    type: 'year',\n                    count: 1,\n                    text: '1y',\n                    title: 'View 1 year'\n                }, {\n                    type: 'all',\n                    text: 'All',\n                    title: 'View all'\n                }],\n            /**\n             * The date formats to use when setting min, max and value on date inputs.\n             * @private\n             */\n            inputTypeFormats: {\n                'datetime-local': '%Y-%m-%dT%H:%M:%S',\n                'date': '%Y-%m-%d',\n                'time': '%H:%M:%S'\n            }\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Define the time span for the button\n         *\n         * @typedef {\"all\"|\"day\"|\"hour\"|\"millisecond\"|\"minute\"|\"month\"|\"second\"|\"week\"|\"year\"|\"ytd\"} Highcharts.RangeSelectorButtonTypeValue\n         */\n        /**\n         * Callback function to react on button clicks.\n         *\n         * @callback Highcharts.RangeSelectorClickCallbackFunction\n         *\n         * @param {global.Event} e\n         *        Event arguments.\n         *\n         * @param {boolean|undefined}\n         *        Return false to cancel the default button event.\n         */\n        /**\n         * Callback function to parse values entered in the input boxes and return a\n         * valid JavaScript time as milliseconds since 1970.\n         *\n         * @callback Highcharts.RangeSelectorParseCallbackFunction\n         *\n         * @param {string} value\n         *        Input value to parse.\n         *\n         * @return {number}\n         *         Parsed JavaScript time value.\n         */\n        (''); // keeps doclets above in JS file\n\n        return RangeSelector;\n    });\n    _registerModule(_modules, 'Accessibility/Components/RangeSelectorComponent.js', [_modules['Stock/RangeSelector/RangeSelector.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function (RangeSelector, AccessibilityComponent, ChartUtilities, Announcer, KeyboardNavigationHandler, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for the range selector.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT, getAxisRangeDescription } = ChartUtilities;\n        const { addEvent, attr } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Do we want date input navigation\n         * @private\n         */\n        function shouldRunInputNavigation(chart) {\n            return Boolean(chart.rangeSelector &&\n                chart.rangeSelector.inputGroup &&\n                chart.rangeSelector.inputGroup.element.style.visibility !== 'hidden' &&\n                chart.options.rangeSelector.inputEnabled !== false &&\n                chart.rangeSelector.minInput &&\n                chart.rangeSelector.maxInput);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The RangeSelectorComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.RangeSelectorComponent\n         */\n        class RangeSelectorComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.announcer = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the component\n             * @private\n             */\n            init() {\n                const chart = this.chart;\n                this.announcer = new Announcer(chart, 'polite');\n            }\n            /**\n             * Called on first render/updates to the chart, including options changes.\n             */\n            onChartUpdate() {\n                const chart = this.chart, component = this, rangeSelector = chart.rangeSelector;\n                if (!rangeSelector) {\n                    return;\n                }\n                this.updateSelectorVisibility();\n                this.setDropdownAttrs();\n                if (rangeSelector.buttons &&\n                    rangeSelector.buttons.length) {\n                    rangeSelector.buttons.forEach((button) => {\n                        component.setRangeButtonAttrs(button);\n                    });\n                }\n                // Make sure input boxes are accessible and focusable\n                if (rangeSelector.maxInput && rangeSelector.minInput) {\n                    ['minInput', 'maxInput'].forEach(function (key, i) {\n                        const input = rangeSelector[key];\n                        if (input) {\n                            unhideChartElementFromAT(chart, input);\n                            component.setRangeInputAttrs(input, 'accessibility.rangeSelector.' + (i ? 'max' : 'min') +\n                                'InputLabel');\n                        }\n                    });\n                }\n            }\n            /**\n             * Hide buttons from AT when showing dropdown, and vice versa.\n             * @private\n             */\n            updateSelectorVisibility() {\n                const chart = this.chart;\n                const rangeSelector = chart.rangeSelector;\n                const dropdown = (rangeSelector &&\n                    rangeSelector.dropdown);\n                const buttons = (rangeSelector &&\n                    rangeSelector.buttons ||\n                    []);\n                const hideFromAT = (el) => el.setAttribute('aria-hidden', true);\n                if (rangeSelector &&\n                    rangeSelector.hasVisibleDropdown &&\n                    dropdown) {\n                    unhideChartElementFromAT(chart, dropdown);\n                    buttons.forEach((btn) => hideFromAT(btn.element));\n                }\n                else {\n                    if (dropdown) {\n                        hideFromAT(dropdown);\n                    }\n                    buttons.forEach((btn) => unhideChartElementFromAT(chart, btn.element));\n                }\n            }\n            /**\n             * Set accessibility related attributes on dropdown element.\n             * @private\n             */\n            setDropdownAttrs() {\n                const chart = this.chart;\n                const dropdown = (chart.rangeSelector &&\n                    chart.rangeSelector.dropdown);\n                if (dropdown) {\n                    const label = chart.langFormat('accessibility.rangeSelector.dropdownLabel', { rangeTitle: chart.options.lang.rangeSelectorZoom });\n                    dropdown.setAttribute('aria-label', label);\n                    dropdown.setAttribute('tabindex', -1);\n                }\n            }\n            /**\n             * Set attrs for a range button\n             * @private\n             */\n            setRangeButtonAttrs(button) {\n                attr(button.element, {\n                    tabindex: -1,\n                    role: 'button'\n                });\n            }\n            /**\n             * Set attrs for a date input\n             * @private\n             */\n            setRangeInputAttrs(input, langKey) {\n                const chart = this.chart;\n                attr(input, {\n                    tabindex: -1,\n                    'aria-label': chart.langFormat(langKey, { chart: chart })\n                });\n            }\n            /**\n             * Handle arrow key nav\n             * @private\n             */\n            onButtonNavKbdArrowKey(keyboardNavigationHandler, keyCode) {\n                const response = keyboardNavigationHandler.response, keys = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility\n                    .keyboardNavigation.wrapAround, direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);\n                if (!didHighlight) {\n                    if (wrapAround) {\n                        keyboardNavigationHandler.init(direction);\n                        return response.success;\n                    }\n                    return response[direction > 0 ? 'next' : 'prev'];\n                }\n                return response.success;\n            }\n            /**\n             * Handle keyboard click\n             * @private\n             */\n            onButtonNavKbdClick(keyboardNavigationHandler) {\n                const response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;\n                if (!wasDisabled) {\n                    this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);\n                }\n                return response.success;\n            }\n            /**\n             * Called whenever a range selector button has been clicked, either by\n             * mouse, touch, or kbd/voice/other.\n             * @private\n             */\n            onAfterBtnClick() {\n                const chart = this.chart;\n                const axisRangeDescription = getAxisRangeDescription(chart.xAxis[0]);\n                const announcement = chart.langFormat('accessibility.rangeSelector.clickButtonAnnouncement', { chart, axisRangeDescription });\n                if (announcement) {\n                    this.announcer.announce(announcement);\n                }\n            }\n            /**\n             * Handle move between input elements with Tab key\n             * @private\n             */\n            onInputKbdMove(direction) {\n                const chart = this.chart;\n                const rangeSel = chart.rangeSelector;\n                const newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;\n                const newIxOutOfRange = newIx > 1 || newIx < 0;\n                if (newIxOutOfRange) {\n                    if (chart.accessibility) {\n                        // Ignore focus\n                        chart.accessibility.keyboardNavigation.exiting = true;\n                        chart.accessibility.keyboardNavigation.tabindexContainer\n                            .focus();\n                        return chart.accessibility.keyboardNavigation.move(direction);\n                    }\n                }\n                else if (rangeSel) {\n                    const svgEl = rangeSel[newIx ? 'maxDateBox' : 'minDateBox'];\n                    const inputEl = rangeSel[newIx ? 'maxInput' : 'minInput'];\n                    if (svgEl && inputEl) {\n                        chart.setFocusToElement(svgEl, inputEl);\n                    }\n                }\n                return true;\n            }\n            /**\n             * Init date input navigation\n             * @private\n             */\n            onInputNavInit(direction) {\n                const component = this;\n                const chart = this.chart;\n                const buttonIxToHighlight = direction > 0 ? 0 : 1;\n                const rangeSel = chart.rangeSelector;\n                const svgEl = (rangeSel &&\n                    rangeSel[buttonIxToHighlight ? 'maxDateBox' : 'minDateBox']);\n                const minInput = (rangeSel && rangeSel.minInput);\n                const maxInput = (rangeSel && rangeSel.maxInput);\n                const inputEl = buttonIxToHighlight ? maxInput : minInput;\n                chart.highlightedInputRangeIx = buttonIxToHighlight;\n                if (svgEl && minInput && maxInput) {\n                    chart.setFocusToElement(svgEl, inputEl);\n                    // Tab-press with the input focused does not propagate to chart\n                    // automatically, so we manually catch and handle it when relevant.\n                    if (this.removeInputKeydownHandler) {\n                        this.removeInputKeydownHandler();\n                    }\n                    const keydownHandler = (e) => {\n                        const isTab = (e.which || e.keyCode) === this.keyCodes.tab;\n                        if (isTab &&\n                            component.onInputKbdMove(e.shiftKey ? -1 : 1)) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                    };\n                    const minRemover = addEvent(minInput, 'keydown', keydownHandler);\n                    const maxRemover = addEvent(maxInput, 'keydown', keydownHandler);\n                    this.removeInputKeydownHandler = () => {\n                        minRemover();\n                        maxRemover();\n                    };\n                }\n            }\n            /**\n             * Terminate date input nav\n             * @private\n             */\n            onInputNavTerminate() {\n                const rangeSel = (this.chart.rangeSelector || {});\n                if (rangeSel.maxInput) {\n                    rangeSel.hideInput('max');\n                }\n                if (rangeSel.minInput) {\n                    rangeSel.hideInput('min');\n                }\n                if (this.removeInputKeydownHandler) {\n                    this.removeInputKeydownHandler();\n                    delete this.removeInputKeydownHandler;\n                }\n            }\n            /**\n             * Init range selector dropdown nav\n             * @private\n             */\n            initDropdownNav() {\n                const chart = this.chart;\n                const rangeSelector = chart.rangeSelector;\n                const dropdown = (rangeSelector && rangeSelector.dropdown);\n                if (rangeSelector && dropdown) {\n                    chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);\n                    if (this.removeDropdownKeydownHandler) {\n                        this.removeDropdownKeydownHandler();\n                    }\n                    // Tab-press with dropdown focused does not propagate to chart\n                    // automatically, so we manually catch and handle it when relevant.\n                    this.removeDropdownKeydownHandler = addEvent(dropdown, 'keydown', (e) => {\n                        const isTab = (e.which || e.keyCode) === this.keyCodes.tab, a11y = chart.accessibility;\n                        if (isTab) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                            if (a11y) {\n                                a11y.keyboardNavigation.tabindexContainer.focus();\n                                a11y.keyboardNavigation.move(e.shiftKey ? -1 : 1);\n                            }\n                        }\n                    });\n                }\n            }\n            /**\n             * Get navigation for the range selector buttons.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler} The module object.\n             */\n            getRangeSelectorButtonNavigation() {\n                const chart = this.chart;\n                const keys = this.keyCodes;\n                const component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.left, keys.right, keys.up, keys.down],\n                            function (keyCode) {\n                                return component.onButtonNavKbdArrowKey(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.enter, keys.space],\n                            function () {\n                                return component.onButtonNavKbdClick(this);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return !!(chart.rangeSelector &&\n                            chart.rangeSelector.buttons &&\n                            chart.rangeSelector.buttons.length);\n                    },\n                    init: function (direction) {\n                        const rangeSelector = chart.rangeSelector;\n                        if (rangeSelector && rangeSelector.hasVisibleDropdown) {\n                            component.initDropdownNav();\n                        }\n                        else if (rangeSelector) {\n                            const lastButtonIx = rangeSelector.buttons.length - 1;\n                            chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);\n                        }\n                    },\n                    terminate: function () {\n                        if (component.removeDropdownKeydownHandler) {\n                            component.removeDropdownKeydownHandler();\n                            delete component.removeDropdownKeydownHandler;\n                        }\n                    }\n                });\n            }\n            /**\n             * Get navigation for the range selector input boxes.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler}\n             *         The module object.\n             */\n            getRangeSelectorInputNavigation() {\n                const chart = this.chart;\n                const component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [],\n                    validate: function () {\n                        return shouldRunInputNavigation(chart);\n                    },\n                    init: function (direction) {\n                        component.onInputNavInit(direction);\n                    },\n                    terminate: function () {\n                        component.onInputNavTerminate();\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handlers for this component.\n             * @return {Array<Highcharts.KeyboardNavigationHandler>}\n             *         List of module objects.\n             */\n            getKeyboardNavigation() {\n                return [\n                    this.getRangeSelectorButtonNavigation(),\n                    this.getRangeSelectorInputNavigation()\n                ];\n            }\n            /**\n             * Remove component traces\n             */\n            destroy() {\n                if (this.removeDropdownKeydownHandler) {\n                    this.removeDropdownKeydownHandler();\n                }\n                if (this.removeInputKeydownHandler) {\n                    this.removeInputKeydownHandler();\n                }\n                if (this.announcer) {\n                    this.announcer.destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (RangeSelectorComponent) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Highlight range selector button by index.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightRangeSelectorButton\n             */\n            function chartHighlightRangeSelectorButton(ix) {\n                const buttons = (this.rangeSelector &&\n                    this.rangeSelector.buttons ||\n                    []);\n                const curHighlightedIx = this.highlightedRangeSelectorItemIx;\n                const curSelectedIx = (this.rangeSelector &&\n                    this.rangeSelector.selected);\n                // Deselect old\n                if (typeof curHighlightedIx !== 'undefined' &&\n                    buttons[curHighlightedIx] &&\n                    curHighlightedIx !== curSelectedIx) {\n                    buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);\n                }\n                // Select new\n                this.highlightedRangeSelectorItemIx = ix;\n                if (buttons[ix]) {\n                    this.setFocusToElement(buttons[ix].box, buttons[ix].element);\n                    if (ix !== curSelectedIx) {\n                        this.oldRangeSelectorItemState = buttons[ix].state;\n                        buttons[ix].setState(1);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Build compositions\n             * @private\n             */\n            function compose(ChartClass, RangeSelectorClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightRangeSelectorButton = (chartHighlightRangeSelectorButton);\n                }\n                if (U.pushUnique(composedMembers, RangeSelectorClass)) {\n                    addEvent(RangeSelector, 'afterBtnClick', rangeSelectorAfterBtnClick);\n                }\n            }\n            RangeSelectorComponent.compose = compose;\n            /**\n             * Range selector does not have destroy-setup for class instance events - so\n             * we set it on the class and call the component from here.\n             * @private\n             */\n            function rangeSelectorAfterBtnClick() {\n                const a11y = this.chart.accessibility;\n                if (a11y && a11y.components.rangeSelector) {\n                    return a11y.components.rangeSelector.onAfterBtnClick();\n                }\n            }\n        })(RangeSelectorComponent || (RangeSelectorComponent = {}));\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n\n        return RangeSelectorComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/ForcedMarkers.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Handle forcing series markers.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, merge } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ForcedMarkersComposition;\n        (function (ForcedMarkersComposition) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Compositions\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(SeriesClass) {\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    addEvent(SeriesClass, 'afterSetOptions', seriesOnAfterSetOptions);\n                    addEvent(SeriesClass, 'render', seriesOnRender);\n                    addEvent(SeriesClass, 'afterRender', seriesOnAfterRender);\n                }\n            }\n            ForcedMarkersComposition.compose = compose;\n            /**\n             * @private\n             */\n            function forceZeroOpacityMarkerOptions(options) {\n                merge(true, options, {\n                    marker: {\n                        enabled: true,\n                        states: {\n                            normal: {\n                                opacity: 0\n                            }\n                        }\n                    }\n                });\n            }\n            /**\n             * @private\n             */\n            function getPointMarkerOpacity(pointOptions) {\n                return pointOptions.marker.states &&\n                    pointOptions.marker.states.normal &&\n                    pointOptions.marker.states.normal.opacity;\n            }\n            /**\n             * @private\n             */\n            function handleForcePointMarkers(series) {\n                let i = series.points.length;\n                while (i--) {\n                    const point = series.points[i];\n                    const pointOptions = point.options;\n                    const hadForcedMarker = point.hasForcedA11yMarker;\n                    delete point.hasForcedA11yMarker;\n                    if (pointOptions.marker) {\n                        const isStillForcedMarker = hadForcedMarker &&\n                            getPointMarkerOpacity(pointOptions) === 0;\n                        if (pointOptions.marker.enabled && !isStillForcedMarker) {\n                            unforcePointMarkerOptions(pointOptions);\n                            point.hasForcedA11yMarker = false;\n                        }\n                        else if (pointOptions.marker.enabled === false) {\n                            forceZeroOpacityMarkerOptions(pointOptions);\n                            point.hasForcedA11yMarker = true;\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function hasIndividualPointMarkerOptions(series) {\n                return !!(series._hasPointMarkers &&\n                    series.points &&\n                    series.points.length);\n            }\n            /**\n             * @private\n             */\n            function isWithinDescriptionThreshold(series) {\n                const a11yOptions = series.chart.options.accessibility;\n                return series.points.length <\n                    a11yOptions.series.pointDescriptionEnabledThreshold ||\n                    a11yOptions.series\n                        .pointDescriptionEnabledThreshold === false;\n            }\n            /**\n             * Process marker graphics after render\n             * @private\n             */\n            function seriesOnAfterRender() {\n                const series = this;\n                // For styled mode the rendered graphic does not reflect the style\n                // options, and we need to add/remove classes to achieve the same.\n                if (series.chart.styledMode) {\n                    if (series.markerGroup) {\n                        series.markerGroup[series.a11yMarkersForced ? 'addClass' : 'removeClass']('highcharts-a11y-markers-hidden');\n                    }\n                    // Do we need to handle individual points?\n                    if (hasIndividualPointMarkerOptions(series)) {\n                        series.points.forEach((point) => {\n                            if (point.graphic) {\n                                point.graphic[point.hasForcedA11yMarker ?\n                                    'addClass' : 'removeClass']('highcharts-a11y-marker-hidden');\n                                point.graphic[point.hasForcedA11yMarker === false ?\n                                    'addClass' :\n                                    'removeClass']('highcharts-a11y-marker-visible');\n                            }\n                        });\n                    }\n                }\n            }\n            /**\n             * Keep track of options to reset markers to if no longer forced.\n             * @private\n             */\n            function seriesOnAfterSetOptions(e) {\n                this.resetA11yMarkerOptions = merge(e.options.marker || {}, this.userOptions.marker || {});\n            }\n            /**\n             * Keep track of forcing markers.\n             * @private\n             */\n            function seriesOnRender() {\n                const series = this, options = series.options;\n                if (shouldForceMarkers(series)) {\n                    if (options.marker && options.marker.enabled === false) {\n                        series.a11yMarkersForced = true;\n                        forceZeroOpacityMarkerOptions(series.options);\n                    }\n                    if (hasIndividualPointMarkerOptions(series)) {\n                        handleForcePointMarkers(series);\n                    }\n                }\n                else if (series.a11yMarkersForced) {\n                    delete series.a11yMarkersForced;\n                    unforceSeriesMarkerOptions(series);\n                    delete series.resetA11yMarkerOptions;\n                }\n            }\n            /**\n             * @private\n             */\n            function shouldForceMarkers(series) {\n                const chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility &&\n                    series.options.accessibility.enabled) !== false;\n                return (chartA11yEnabled &&\n                    seriesA11yEnabled &&\n                    isWithinDescriptionThreshold(series));\n            }\n            /**\n             * @private\n             */\n            function unforcePointMarkerOptions(pointOptions) {\n                merge(true, pointOptions.marker, {\n                    states: {\n                        normal: {\n                            opacity: getPointMarkerOpacity(pointOptions) || 1\n                        }\n                    }\n                });\n            }\n            /**\n             * Reset markers to normal\n             * @private\n             */\n            function unforceSeriesMarkerOptions(series) {\n                const resetMarkerOptions = series.resetA11yMarkerOptions;\n                if (resetMarkerOptions) {\n                    const originalOpactiy = resetMarkerOptions.states &&\n                        resetMarkerOptions.states.normal &&\n                        resetMarkerOptions.states.normal.opacity;\n                    series.update({\n                        marker: {\n                            enabled: resetMarkerOptions.enabled,\n                            states: {\n                                normal: { opacity: originalOpactiy }\n                            }\n                        }\n                    });\n                }\n            }\n        })(ForcedMarkersComposition || (ForcedMarkersComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ForcedMarkersComposition;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js']], function (Point, Series, SeriesRegistry, H, U, KeyboardNavigationHandler, EventProvider, ChartUtilities) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Handle keyboard navigation for series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { seriesTypes } = SeriesRegistry;\n        const { doc } = H;\n        const { defined, fireEvent } = U;\n        const { getPointFromXY, getSeriesFromName, scrollToPoint } = ChartUtilities;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Get the index of a point in a series. This is needed when using e.g. data\n         * grouping.\n         *\n         * @private\n         * @function getPointIndex\n         * @param {Highcharts.AccessibilityPoint} point\n         * The point to find index of.\n         * @return {number|undefined}\n         * The index in the series.points array of the point.\n         */\n        function getPointIndex(point) {\n            const index = point.index, points = point.series.points;\n            let i = points.length;\n            if (points[index] !== point) {\n                while (i--) {\n                    if (points[i] === point) {\n                        return i;\n                    }\n                }\n            }\n            else {\n                return index;\n            }\n        }\n        /**\n         * Determine if series navigation should be skipped\n         * @private\n         */\n        function isSkipSeries(series) {\n            const a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;\n            return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false ||\n                seriesA11yOptions.enabled === false ||\n                series.options.enableMouseTracking === false || // #8440\n                !series.visible ||\n                // Skip all points in a series where pointNavigationEnabledThreshold is\n                // reached\n                (seriesNavOptions.pointNavigationEnabledThreshold &&\n                    seriesNavOptions.pointNavigationEnabledThreshold <=\n                        series.points.length);\n        }\n        /**\n         * Determine if navigation for a point should be skipped\n         * @private\n         */\n        function isSkipPoint(point) {\n            const a11yOptions = point.series.chart.options.accessibility;\n            const pointA11yDisabled = (point.options.accessibility &&\n                point.options.accessibility.enabled === false);\n            return point.isNull &&\n                a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints ||\n                point.visible === false ||\n                point.isInside === false ||\n                pointA11yDisabled ||\n                isSkipSeries(point.series);\n        }\n        /**\n         * Get the first point that is not a skip point in this series.\n         * @private\n         */\n        function getFirstValidPointInSeries(series) {\n            const points = series.points || [], len = points.length;\n            for (let i = 0; i < len; ++i) {\n                if (!isSkipPoint(points[i])) {\n                    return points[i];\n                }\n            }\n            return null;\n        }\n        /**\n         * Get the first point that is not a skip point in this chart.\n         * @private\n         */\n        function getFirstValidPointInChart(chart) {\n            const series = chart.series || [], len = series.length;\n            for (let i = 0; i < len; ++i) {\n                if (!isSkipSeries(series[i])) {\n                    const point = getFirstValidPointInSeries(series[i]);\n                    if (point) {\n                        return point;\n                    }\n                }\n            }\n            return null;\n        }\n        /**\n         * @private\n         */\n        function highlightLastValidPointInChart(chart) {\n            const numSeries = chart.series.length;\n            let i = numSeries, res = false;\n            while (i--) {\n                chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];\n                // Highlight first valid point in the series will also\n                // look backwards. It always starts from currently\n                // highlighted point.\n                res = chart.series[i].highlightNextValidPoint();\n                if (res) {\n                    break;\n                }\n            }\n            return res;\n        }\n        /**\n         * After drilling down/up, we need to set focus to the first point for\n         * screen readers and keyboard nav.\n         * @private\n         */\n        function updateChartFocusAfterDrilling(chart) {\n            const point = getFirstValidPointInChart(chart);\n            if (point) {\n                point.highlight(false); // Do not visually highlight\n            }\n        }\n        /**\n         * Highlight the first point in chart that is not a skip point\n         * @private\n         */\n        function highlightFirstValidPointInChart(chart) {\n            delete chart.highlightedPoint;\n            const point = getFirstValidPointInChart(chart);\n            return point ? point.highlight() : false;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.SeriesKeyboardNavigation\n         */\n        class SeriesKeyboardNavigation {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart, keyCodes) {\n                this.keyCodes = keyCodes;\n                this.chart = chart;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Init the keyboard navigation\n             */\n            init() {\n                const keyboardNavigation = this, chart = this.chart, e = this.eventProvider = new EventProvider();\n                e.addEvent(Series, 'destroy', function () {\n                    return keyboardNavigation.onSeriesDestroy(this);\n                });\n                e.addEvent(chart, 'afterApplyDrilldown', function () {\n                    updateChartFocusAfterDrilling(this);\n                });\n                e.addEvent(chart, 'drilldown', function (e) {\n                    const point = e.point, series = point.series;\n                    keyboardNavigation.lastDrilledDownPoint = {\n                        x: point.x,\n                        y: point.y,\n                        seriesName: series ? series.name : ''\n                    };\n                });\n                e.addEvent(chart, 'drillupall', function () {\n                    setTimeout(function () {\n                        keyboardNavigation.onDrillupAll();\n                    }, 10);\n                });\n                // Heatmaps et al. alter z-index in setState, causing elements\n                // to lose focus\n                e.addEvent(Point, 'afterSetState', function () {\n                    const point = this;\n                    const pointEl = point.graphic && point.graphic.element;\n                    const focusedElement = doc.activeElement;\n                    // VO brings focus with it to container, causing series nav to run.\n                    // If then navigating with virtual cursor, it is possible to leave\n                    // keyboard nav module state on the data points and still activate\n                    // proxy buttons.\n                    const focusedElClassName = (focusedElement && focusedElement.getAttribute('class'));\n                    const isProxyFocused = focusedElClassName &&\n                        focusedElClassName.indexOf('highcharts-a11y-proxy-button') > -1;\n                    if (chart.highlightedPoint === point &&\n                        focusedElement !== pointEl &&\n                        !isProxyFocused &&\n                        pointEl &&\n                        pointEl.focus) {\n                        pointEl.focus();\n                    }\n                });\n            }\n            /**\n             * After drillup we want to find the point that was drilled down to and\n             * highlight it.\n             * @private\n             */\n            onDrillupAll() {\n                const last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName(chart, last.seriesName);\n                let point;\n                if (last && series && defined(last.x) && defined(last.y)) {\n                    point = getPointFromXY(series, last.x, last.y);\n                }\n                point = point || getFirstValidPointInChart(chart);\n                // Container focus can be lost on drillup due to deleted elements.\n                if (chart.container) {\n                    chart.container.focus();\n                }\n                if (point && point.highlight) {\n                    point.highlight(false); // Do not visually highlight\n                }\n            }\n            /**\n             * @private\n             */\n            getKeyboardNavigationHandler() {\n                const keyboardNavigation = this, keys = this.keyCodes, chart = this.chart, inverted = chart.inverted;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [inverted ? [keys.up, keys.down] : [keys.left, keys.right],\n                            function (keyCode) {\n                                return keyboardNavigation.onKbdSideways(this, keyCode);\n                            }],\n                        [inverted ? [keys.left, keys.right] : [keys.up, keys.down],\n                            function (keyCode) {\n                                return keyboardNavigation.onKbdVertical(this, keyCode);\n                            }],\n                        [[keys.enter, keys.space],\n                            function (keyCode, event) {\n                                const point = chart.highlightedPoint;\n                                if (point) {\n                                    event.point = point;\n                                    fireEvent(point.series, 'click', event);\n                                    point.firePointEvent('click');\n                                }\n                                return this.response.success;\n                            }],\n                        [[keys.home],\n                            function () {\n                                highlightFirstValidPointInChart(chart);\n                                return this.response.success;\n                            }],\n                        [[keys.end],\n                            function () {\n                                highlightLastValidPointInChart(chart);\n                                return this.response.success;\n                            }],\n                        [[keys.pageDown, keys.pageUp],\n                            function (keyCode) {\n                                chart.highlightAdjacentSeries(keyCode === keys.pageDown);\n                                return this.response.success;\n                            }]\n                    ],\n                    init: function () {\n                        return keyboardNavigation.onHandlerInit(this);\n                    },\n                    validate: function () {\n                        return !!getFirstValidPointInChart(chart);\n                    },\n                    terminate: function () {\n                        return keyboardNavigation.onHandlerTerminate();\n                    }\n                });\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler\n             * @param {number} keyCode\n             * @return {number}\n             * response\n             */\n            onKbdSideways(handler, keyCode) {\n                const keys = this.keyCodes, isNext = keyCode === keys.right || keyCode === keys.down;\n                return this.attemptHighlightAdjacentPoint(handler, isNext);\n            }\n            /**\n             * When keyboard navigation inits.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler The handler object\n             * @return {number}\n             * response\n             */\n            onHandlerInit(handler) {\n                const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;\n                if (kbdNavOptions.seriesNavigation.rememberPointFocus &&\n                    chart.highlightedPoint) {\n                    chart.highlightedPoint.highlight();\n                }\n                else {\n                    highlightFirstValidPointInChart(chart);\n                }\n                return handler.response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} handler\n             * @param {number} keyCode\n             * @return {number}\n             * response\n             */\n            onKbdVertical(handler, keyCode) {\n                const chart = this.chart, keys = this.keyCodes, isNext = keyCode === keys.down || keyCode === keys.right, navOptions = chart.options.accessibility.keyboardNavigation\n                    .seriesNavigation;\n                // Handle serialized mode, act like left/right\n                if (navOptions.mode && navOptions.mode === 'serialize') {\n                    return this.attemptHighlightAdjacentPoint(handler, isNext);\n                }\n                // Normal mode, move between series\n                const highlightMethod = (chart.highlightedPoint &&\n                    chart.highlightedPoint.series.keyboardMoveVertical) ?\n                    'highlightAdjacentPointVertical' :\n                    'highlightAdjacentSeries';\n                chart[highlightMethod](isNext);\n                return handler.response.success;\n            }\n            /**\n             * @private\n             */\n            onHandlerTerminate() {\n                const chart = this.chart, kbdNavOptions = chart.options.accessibility.keyboardNavigation;\n                if (chart.tooltip) {\n                    chart.tooltip.hide(0);\n                }\n                const hoverSeries = (chart.highlightedPoint && chart.highlightedPoint.series);\n                if (hoverSeries && hoverSeries.onMouseOut) {\n                    hoverSeries.onMouseOut();\n                }\n                if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {\n                    chart.highlightedPoint.onMouseOut();\n                }\n                if (!kbdNavOptions.seriesNavigation.rememberPointFocus) {\n                    delete chart.highlightedPoint;\n                }\n            }\n            /**\n             * Function that attempts to highlight next/prev point. Handles wrap around.\n             * @private\n             */\n            attemptHighlightAdjacentPoint(handler, directionIsNext) {\n                const chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation\n                    .wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);\n                if (!highlightSuccessful) {\n                    if (wrapAround && (directionIsNext ?\n                        highlightFirstValidPointInChart(chart) :\n                        highlightLastValidPointInChart(chart))) {\n                        return handler.response.success;\n                    }\n                    return handler.response[directionIsNext ? 'next' : 'prev'];\n                }\n                return handler.response.success;\n            }\n            /**\n             * @private\n             */\n            onSeriesDestroy(series) {\n                const chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint &&\n                    chart.highlightedPoint.series === series;\n                if (currentHighlightedPointDestroyed) {\n                    delete chart.highlightedPoint;\n                    if (chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            destroy() {\n                this.eventProvider.removeAddedEvents();\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (SeriesKeyboardNavigation) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Function to highlight next/previous point in chart.\n             *\n             * @private\n             * @function Highcharts.Chart#highlightAdjacentPoint\n             *\n             * @param {boolean} next\n             * Flag for the direction.\n             *\n             * @return {Highcharts.Point|boolean}\n             * Returns highlighted point on success, false on failure (no adjacent point\n             * to highlight in chosen direction).\n             */\n            function chartHighlightAdjacentPoint(next) {\n                const chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points || [], lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries &&\n                    lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1];\n                let newSeries, newPoint;\n                // If no points, return false\n                if (!series[0] || !series[0].points) {\n                    return false;\n                }\n                if (!curPoint) {\n                    // No point is highlighted yet. Try first/last point depending on\n                    // move direction\n                    newPoint = next ? series[0].points[0] : lastPoint;\n                }\n                else {\n                    // We have a highlighted point. Grab next/prev point & series.\n                    newSeries = series[curPoint.series.index + (next ? 1 : -1)];\n                    newPoint = curPoints[curPointIndex + (next ? 1 : -1)];\n                    if (!newPoint && newSeries) {\n                        // Done with this series, try next one\n                        newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];\n                    }\n                    // If there is no adjacent point, we return false\n                    if (!newPoint) {\n                        return false;\n                    }\n                }\n                // Recursively skip points\n                if (isSkipPoint(newPoint)) {\n                    // If we skip this whole series, move to the end of the series\n                    // before we recurse, just to optimize\n                    newSeries = newPoint.series;\n                    if (isSkipSeries(newSeries)) {\n                        chart.highlightedPoint = next ?\n                            newSeries.points[newSeries.points.length - 1] :\n                            newSeries.points[0];\n                    }\n                    else {\n                        // Otherwise, just move one point\n                        chart.highlightedPoint = newPoint;\n                    }\n                    // Retry\n                    return chart.highlightAdjacentPoint(next);\n                }\n                // There is an adjacent point, highlight it\n                return newPoint.highlight();\n            }\n            /**\n             * Highlight the closest point vertically.\n             * @private\n             */\n            function chartHighlightAdjacentPointVertical(down) {\n                const curPoint = this.highlightedPoint;\n                let minDistance = Infinity, bestPoint;\n                if (!defined(curPoint.plotX) || !defined(curPoint.plotY)) {\n                    return false;\n                }\n                this.series.forEach((series) => {\n                    if (isSkipSeries(series)) {\n                        return;\n                    }\n                    series.points.forEach((point) => {\n                        if (!defined(point.plotY) || !defined(point.plotX) ||\n                            point === curPoint) {\n                            return;\n                        }\n                        let yDistance = point.plotY - curPoint.plotY;\n                        const width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) +\n                            width * width * 4; // Weigh horizontal distance highly\n                        // Reverse distance number if axis is reversed\n                        if (series.yAxis && series.yAxis.reversed) {\n                            yDistance *= -1;\n                        }\n                        if (yDistance <= 0 && down || yDistance >= 0 && !down ||\n                            distance < 5 || // Points in same spot => infinite loop\n                            isSkipPoint(point)) {\n                            return;\n                        }\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            bestPoint = point;\n                        }\n                    });\n                });\n                return bestPoint ? bestPoint.highlight() : false;\n            }\n            /**\n             * Highlight next/previous series in chart. Returns false if no adjacent\n             * series in the direction, otherwise returns new highlighted point.\n             * @private\n             */\n            function chartHighlightAdjacentSeries(down) {\n                const chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1];\n                let newSeries, newPoint, adjacentNewPoint;\n                // If no point is highlighted, highlight the first/last point\n                if (!chart.highlightedPoint) {\n                    newSeries = down ? (chart.series && chart.series[0]) : lastSeries;\n                    newPoint = down ?\n                        (newSeries && newSeries.points && newSeries.points[0]) :\n                        lastPoint;\n                    return newPoint ? newPoint.highlight() : false;\n                }\n                newSeries = (chart.series[curPoint.series.index + (down ? -1 : 1)]);\n                if (!newSeries) {\n                    return false;\n                }\n                // We have a new series in this direction, find the right point\n                // Weigh xDistance as counting much higher than Y distance\n                newPoint = getClosestPoint(curPoint, newSeries, 4);\n                if (!newPoint) {\n                    return false;\n                }\n                // New series and point exists, but we might want to skip it\n                if (isSkipSeries(newSeries)) {\n                    // Skip the series\n                    newPoint.highlight();\n                    // Try recurse\n                    adjacentNewPoint = chart.highlightAdjacentSeries(down);\n                    if (!adjacentNewPoint) {\n                        // Recurse failed\n                        curPoint.highlight();\n                        return false;\n                    }\n                    // Recurse succeeded\n                    return adjacentNewPoint;\n                }\n                // Highlight the new point or any first valid point back or forwards\n                // from it\n                newPoint.highlight();\n                return newPoint.series.highlightNextValidPoint();\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, PointClass, SeriesClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.highlightAdjacentPoint = chartHighlightAdjacentPoint;\n                    chartProto.highlightAdjacentPointVertical = (chartHighlightAdjacentPointVertical);\n                    chartProto.highlightAdjacentSeries = chartHighlightAdjacentSeries;\n                }\n                if (U.pushUnique(composedMembers, PointClass)) {\n                    const pointProto = PointClass.prototype;\n                    pointProto.highlight = pointHighlight;\n                }\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    const seriesProto = SeriesClass.prototype;\n                    /**\n                     * Set for which series types it makes sense to move to the closest\n                     * point with up/down arrows, and which series types should just\n                     * move to next series.\n                     * @private\n                     */\n                    seriesProto.keyboardMoveVertical = true;\n                    [\n                        'column',\n                        'gantt',\n                        'pie'\n                    ].forEach((type) => {\n                        if (seriesTypes[type]) {\n                            seriesTypes[type].prototype.keyboardMoveVertical = false;\n                        }\n                    });\n                    seriesProto.highlightNextValidPoint = (seriesHighlightNextValidPoint);\n                }\n            }\n            SeriesKeyboardNavigation.compose = compose;\n            /**\n             * Get the point in a series that is closest (in pixel distance) to a\n             * reference point. Optionally supply weight factors for x and y directions.\n             * @private\n             */\n            function getClosestPoint(point, series, xWeight, yWeight) {\n                let minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;\n                const hasUndefinedPosition = (point) => (!(defined(point.plotX) && defined(point.plotY)));\n                if (hasUndefinedPosition(point)) {\n                    return;\n                }\n                while (i--) {\n                    dPoint = series.points[i];\n                    if (hasUndefinedPosition(dPoint)) {\n                        continue;\n                    }\n                    distance = (point.plotX - dPoint.plotX) *\n                        (point.plotX - dPoint.plotX) *\n                        (xWeight || 1) +\n                        (point.plotY - dPoint.plotY) *\n                            (point.plotY - dPoint.plotY) *\n                            (yWeight || 1);\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        minIx = i;\n                    }\n                }\n                return defined(minIx) ? series.points[minIx] : void 0;\n            }\n            /**\n             * Highlights a point (show tooltip, display hover state, focus element).\n             *\n             * @private\n             * @function Highcharts.Point#highlight\n             *\n             * @return {Highcharts.Point}\n             *         This highlighted point.\n             */\n            function pointHighlight(highlightVisually = true) {\n                const chart = this.series.chart;\n                if (!this.isNull && highlightVisually) {\n                    this.onMouseOver(); // Show the hover marker and tooltip\n                }\n                else {\n                    if (chart.tooltip) {\n                        chart.tooltip.hide(0);\n                    }\n                    // Do not call blur on the element, as it messes up the focus of the\n                    // div element of the chart\n                }\n                scrollToPoint(this);\n                // We focus only after calling onMouseOver because the state change can\n                // change z-index and mess up the element.\n                if (this.graphic) {\n                    chart.setFocusToElement(this.graphic);\n                    if (!highlightVisually && chart.focusElement) {\n                        chart.focusElement.removeFocusBorder();\n                    }\n                }\n                chart.highlightedPoint = this;\n                return this;\n            }\n            /**\n             * Highlight first valid point in a series. Returns the point if\n             * successfully highlighted, otherwise false. If there is a highlighted\n             * point in the series, use that as starting point.\n             *\n             * @private\n             * @function Highcharts.Series#highlightNextValidPoint\n             */\n            function seriesHighlightNextValidPoint() {\n                const curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ?\n                    getPointIndex(curPoint) :\n                    0, points = this.points, len = points.length;\n                if (points && len) {\n                    for (let i = start; i < len; ++i) {\n                        if (!isSkipPoint(points[i])) {\n                            return points[i].highlight();\n                        }\n                    }\n                    for (let j = start; j >= 0; --j) {\n                        if (!isSkipPoint(points[j])) {\n                            return points[j].highlight();\n                        }\n                    }\n                }\n                return false;\n            }\n        })(SeriesKeyboardNavigation || (SeriesKeyboardNavigation = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SeriesKeyboardNavigation;\n    });\n    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Components/SeriesComponent/ForcedMarkers.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js'], _modules['Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js']], function (AccessibilityComponent, ChartUtilities, ForcedMarkers, NewDataAnnouncer, SeriesDescriber, SeriesKeyboardNavigation) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for series and points.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { hideSeriesFromAT } = ChartUtilities;\n        const { describeSeries } = SeriesDescriber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The SeriesComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.SeriesComponent\n         */\n        class SeriesComponent extends AccessibilityComponent {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            static compose(ChartClass, PointClass, SeriesClass) {\n                NewDataAnnouncer.compose(SeriesClass);\n                ForcedMarkers.compose(SeriesClass);\n                SeriesKeyboardNavigation.compose(ChartClass, PointClass, SeriesClass);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Init the component.\n             */\n            init() {\n                this.newDataAnnouncer = new NewDataAnnouncer(this.chart);\n                this.newDataAnnouncer.init();\n                this.keyboardNavigation = new SeriesKeyboardNavigation(this.chart, this.keyCodes);\n                this.keyboardNavigation.init();\n                this.hideTooltipFromATWhenShown();\n                this.hideSeriesLabelsFromATWhenShown();\n            }\n            /**\n             * @private\n             */\n            hideTooltipFromATWhenShown() {\n                const component = this;\n                if (this.chart.tooltip) {\n                    this.addEvent(this.chart.tooltip.constructor, 'refresh', function () {\n                        if (this.chart === component.chart &&\n                            this.label &&\n                            this.label.element) {\n                            this.label.element.setAttribute('aria-hidden', true);\n                        }\n                    });\n                }\n            }\n            /**\n             * @private\n             */\n            hideSeriesLabelsFromATWhenShown() {\n                this.addEvent(this.chart, 'afterDrawSeriesLabels', function () {\n                    this.series.forEach(function (series) {\n                        if (series.labelBySeries) {\n                            series.labelBySeries.attr('aria-hidden', true);\n                        }\n                    });\n                });\n            }\n            /**\n             * Called on chart render. It is necessary to do this for render in case\n             * markers change on zoom/pixel density.\n             */\n            onChartRender() {\n                const chart = this.chart;\n                chart.series.forEach(function (series) {\n                    const shouldDescribeSeries = (series.options.accessibility &&\n                        series.options.accessibility.enabled) !== false &&\n                        series.visible;\n                    if (shouldDescribeSeries) {\n                        describeSeries(series);\n                    }\n                    else {\n                        hideSeriesFromAT(series);\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handler for this component.\n             * @private\n             */\n            getKeyboardNavigation() {\n                return this.keyboardNavigation.getKeyboardNavigationHandler();\n            }\n            /**\n             * Remove traces\n             * @private\n             */\n            destroy() {\n                this.newDataAnnouncer.destroy();\n                this.keyboardNavigation.destroy();\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SeriesComponent;\n    });\n    _registerModule(_modules, 'Accessibility/Components/ZoomComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function (AccessibilityComponent, CU, HU, KeyboardNavigationHandler, U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility component for chart zoom.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { unhideChartElementFromAT } = CU;\n        const { getFakeMouseEvent } = HU;\n        const { attr, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function chartHasMapZoom(chart) {\n            return !!((chart.mapView) &&\n                chart.mapNavigation &&\n                chart.mapNavigation.navButtons.length);\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The ZoomComponent class\n         *\n         * @private\n         * @class\n         * @name Highcharts.ZoomComponent\n         */\n        class ZoomComponent extends AccessibilityComponent {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.focusedMapNavButtonIx = -1;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the component\n             */\n            init() {\n                const component = this, chart = this.chart;\n                this.proxyProvider.addGroup('zoom', 'div');\n                [\n                    'afterShowResetZoom', 'afterApplyDrilldown', 'drillupall'\n                ].forEach((eventType) => {\n                    component.addEvent(chart, eventType, function () {\n                        component.updateProxyOverlays();\n                    });\n                });\n            }\n            /**\n             * Called when chart is updated\n             */\n            onChartUpdate() {\n                const chart = this.chart, component = this;\n                // Make map zoom buttons accessible\n                if (chart.mapNavigation) {\n                    chart.mapNavigation.navButtons.forEach((button, i) => {\n                        unhideChartElementFromAT(chart, button.element);\n                        component.setMapNavButtonAttrs(button.element, 'accessibility.zoom.mapZoom' + (i ? 'Out' : 'In'));\n                    });\n                }\n            }\n            /**\n             * @private\n             * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} button\n             * @param {string} labelFormatKey\n             */\n            setMapNavButtonAttrs(button, labelFormatKey) {\n                const chart = this.chart, label = chart.langFormat(labelFormatKey, { chart: chart });\n                attr(button, {\n                    tabindex: -1,\n                    role: 'button',\n                    'aria-label': label\n                });\n            }\n            /**\n             * Update the proxy overlays on every new render to ensure positions are\n             * correct.\n             */\n            onChartRender() {\n                this.updateProxyOverlays();\n            }\n            /**\n             * Update proxy overlays, recreating the buttons.\n             */\n            updateProxyOverlays() {\n                const chart = this.chart;\n                // Always start with a clean slate\n                this.proxyProvider.clearGroup('zoom');\n                if (chart.resetZoomButton) {\n                    this.createZoomProxyButton(chart.resetZoomButton, 'resetZoomProxyButton', chart.langFormat('accessibility.zoom.resetZoomButton', { chart: chart }));\n                }\n                if (chart.drillUpButton &&\n                    chart.breadcrumbs &&\n                    chart.breadcrumbs.list) {\n                    const lastBreadcrumb = chart.breadcrumbs.list[chart.breadcrumbs.list.length - 1];\n                    this.createZoomProxyButton(chart.drillUpButton, 'drillUpProxyButton', chart.langFormat('accessibility.drillUpButton', {\n                        chart: chart,\n                        buttonText: chart.breadcrumbs.getButtonText(lastBreadcrumb)\n                    }));\n                }\n            }\n            /**\n             * @private\n             * @param {Highcharts.SVGElement} buttonEl\n             * @param {string} buttonProp\n             * @param {string} label\n             */\n            createZoomProxyButton(buttonEl, buttonProp, label) {\n                this[buttonProp] = this.proxyProvider.addProxyElement('zoom', {\n                    click: buttonEl\n                }, {\n                    'aria-label': label,\n                    tabindex: -1\n                });\n            }\n            /**\n             * Get keyboard navigation handler for map zoom.\n             * @private\n             * @return {Highcharts.KeyboardNavigationHandler} The module object\n             */\n            getMapZoomNavigation() {\n                const keys = this.keyCodes, chart = this.chart, component = this;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.up, keys.down, keys.left, keys.right],\n                            function (keyCode) {\n                                return component.onMapKbdArrow(this, keyCode);\n                            }\n                        ],\n                        [\n                            [keys.tab],\n                            function (_keyCode, e) {\n                                return component.onMapKbdTab(this, e);\n                            }\n                        ],\n                        [\n                            [keys.space, keys.enter],\n                            function () {\n                                return component.onMapKbdClick(this);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        return chartHasMapZoom(chart);\n                    },\n                    init: function (direction) {\n                        return component.onMapNavInit(direction);\n                    }\n                });\n            }\n            /**\n             * Arrow key panning for maps.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context.\n             * @param {number} keyCode Key pressed.\n             * @return {number} Response code\n             */\n            onMapKbdArrow(keyboardNavigationHandler, keyCode) {\n                const chart = this.chart, keys = this.keyCodes, target = chart.container, isY = keyCode === keys.up || keyCode === keys.down, stepDirection = (keyCode === keys.left || keyCode === keys.up) ?\n                    1 : -1, granularity = 10, diff = (isY ? chart.plotHeight : chart.plotWidth) /\n                    granularity * stepDirection, \n                // Randomize since same mousedown coords twice is ignored in MapView\n                r = Math.random() * 10, startPos = {\n                    x: target.offsetLeft + chart.plotLeft + chart.plotWidth / 2 + r,\n                    y: target.offsetTop + chart.plotTop + chart.plotHeight / 2 + r\n                }, endPos = isY ? { x: startPos.x, y: startPos.y + diff } :\n                    { x: startPos.x + diff, y: startPos.y };\n                [\n                    getFakeMouseEvent('mousedown', startPos),\n                    getFakeMouseEvent('mousemove', endPos),\n                    getFakeMouseEvent('mouseup', endPos)\n                ].forEach((e) => target.dispatchEvent(e));\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler\n             * @param {global.KeyboardEvent} event\n             * @return {number} Response code\n             */\n            onMapKbdTab(keyboardNavigationHandler, event) {\n                const chart = this.chart;\n                const response = keyboardNavigationHandler.response;\n                const isBackwards = event.shiftKey;\n                const isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx ||\n                    !isBackwards && this.focusedMapNavButtonIx;\n                // Deselect old\n                chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);\n                if (isMoveOutOfRange) {\n                    if (chart.mapView) {\n                        chart.mapView.zoomBy(); // Reset zoom\n                    }\n                    return response[isBackwards ? 'prev' : 'next'];\n                }\n                // Select other button\n                this.focusedMapNavButtonIx += isBackwards ? -1 : 1;\n                const button = chart.mapNavigation.navButtons[this.focusedMapNavButtonIx];\n                chart.setFocusToElement(button.box, button.element);\n                button.setState(2);\n                return response.success;\n            }\n            /**\n             * Called on map button click.\n             * @private\n             * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler The handler context object\n             * @return {number} Response code\n             */\n            onMapKbdClick(keyboardNavigationHandler) {\n                const el = this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element;\n                this.fakeClickEvent(el);\n                return keyboardNavigationHandler.response.success;\n            }\n            /**\n             * @private\n             * @param {number} direction\n             */\n            onMapNavInit(direction) {\n                const chart = this.chart, zoomIn = chart.mapNavigation.navButtons[0], zoomOut = chart.mapNavigation.navButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;\n                chart.setFocusToElement(initialButton.box, initialButton.element);\n                initialButton.setState(2);\n                this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;\n            }\n            /**\n             * Get keyboard navigation handler for a simple chart button. Provide the\n             * button reference for the chart, and a function to call on click.\n             *\n             * @private\n             * @param {string} buttonProp The property on chart referencing the button.\n             * @return {Highcharts.KeyboardNavigationHandler} The module object\n             */\n            simpleButtonNavigation(buttonProp, proxyProp, onClick) {\n                const keys = this.keyCodes, component = this, chart = this.chart;\n                return new KeyboardNavigationHandler(chart, {\n                    keyCodeMap: [\n                        [\n                            [keys.tab, keys.up, keys.down, keys.left, keys.right],\n                            function (keyCode, e) {\n                                const isBackwards = (keyCode === keys.tab && e.shiftKey ||\n                                    keyCode === keys.left ||\n                                    keyCode === keys.up);\n                                // Arrow/tab => just move\n                                return this.response[isBackwards ? 'prev' : 'next'];\n                            }\n                        ],\n                        [\n                            [keys.space, keys.enter],\n                            function () {\n                                const res = onClick(this, chart);\n                                return pick(res, this.response.success);\n                            }\n                        ]\n                    ],\n                    validate: function () {\n                        const hasButton = (chart[buttonProp] &&\n                            chart[buttonProp].box &&\n                            component[proxyProp].buttonElement);\n                        return hasButton;\n                    },\n                    init: function () {\n                        chart.setFocusToElement(chart[buttonProp].box, component[proxyProp].buttonElement);\n                    }\n                });\n            }\n            /**\n             * Get keyboard navigation handlers for this component.\n             * @return {Array<Highcharts.KeyboardNavigationHandler>}\n             *         List of module objects\n             */\n            getKeyboardNavigation() {\n                return [\n                    this.simpleButtonNavigation('resetZoomButton', 'resetZoomProxyButton', function (_handler, chart) {\n                        chart.zoomOut();\n                    }),\n                    this.simpleButtonNavigation('drillUpButton', 'drillUpProxyButton', function (handler, chart) {\n                        chart.drillUp();\n                        return handler.response.prev;\n                    }),\n                    this.getMapZoomNavigation()\n                ];\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ZoomComponent;\n    });\n    _registerModule(_modules, 'Accessibility/HighContrastMode.js', [_modules['Core/Globals.js']], function (H) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Handling for Windows High Contrast Mode.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc, isMS, win } = H;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Detect WHCM in the browser.\n         *\n         * @function Highcharts#isHighContrastModeActive\n         * @private\n         * @return {boolean} Returns true if the browser is in High Contrast mode.\n         */\n        function isHighContrastModeActive() {\n            // Use media query on Edge, but not on IE\n            const isEdge = /(Edg)/.test(win.navigator.userAgent);\n            if (win.matchMedia && isEdge) {\n                return win.matchMedia('(-ms-high-contrast: active)').matches;\n            }\n            // Test BG image for IE\n            if (isMS && win.getComputedStyle) {\n                const testDiv = doc.createElement('div');\n                const imageSrc = 'data:image/gif;base64,' +\n                    'R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n                testDiv.style.backgroundImage = `url(${imageSrc})`; // #13071\n                doc.body.appendChild(testDiv);\n                const bi = (testDiv.currentStyle ||\n                    win.getComputedStyle(testDiv)).backgroundImage;\n                doc.body.removeChild(testDiv);\n                return bi === 'none';\n            }\n            // Other browsers use the forced-colors standard\n            return win.matchMedia && win.matchMedia('(forced-colors: active)').matches;\n        }\n        /**\n         * Force high contrast theme for the chart. The default theme is defined in\n         * a separate file.\n         *\n         * @function Highcharts#setHighContrastTheme\n         * @private\n         * @param {Highcharts.AccessibilityChart} chart The chart to set the theme of.\n         * @return {void}\n         */\n        function setHighContrastTheme(chart) {\n            // We might want to add additional functionality here in the future for\n            // storing the old state so that we can reset the theme if HC mode is\n            // disabled. For now, the user will have to reload the page.\n            chart.highContrastModeActive = true;\n            // Apply theme to chart\n            const theme = (chart.options.accessibility.highContrastTheme);\n            chart.update(theme, false);\n            // Force series colors (plotOptions is not enough)\n            chart.series.forEach(function (s) {\n                const plotOpts = theme.plotOptions[s.type] || {};\n                s.update({\n                    color: plotOpts.color || 'windowText',\n                    colors: [plotOpts.color || 'windowText'],\n                    borderColor: plotOpts.borderColor || 'window'\n                });\n                // Force point colors if existing\n                s.points.forEach(function (p) {\n                    if (p.options && p.options.color) {\n                        p.update({\n                            color: plotOpts.color || 'windowText',\n                            borderColor: plotOpts.borderColor || 'window'\n                        }, false);\n                    }\n                });\n            });\n            // The redraw for each series and after is required for 3D pie\n            // (workaround)\n            chart.redraw();\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const whcm = {\n            isHighContrastModeActive,\n            setHighContrastTheme\n        };\n\n        return whcm;\n    });\n    _registerModule(_modules, 'Accessibility/HighContrastTheme.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Default theme for Windows High Contrast Mode.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Theme\n         *\n         * */\n        const theme = {\n            chart: {\n                backgroundColor: 'window'\n            },\n            title: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            subtitle: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            colorAxis: {\n                minColor: 'windowText',\n                maxColor: 'windowText',\n                stops: []\n            },\n            colors: ['windowText'],\n            xAxis: {\n                gridLineColor: 'windowText',\n                labels: {\n                    style: {\n                        color: 'windowText'\n                    }\n                },\n                lineColor: 'windowText',\n                minorGridLineColor: 'windowText',\n                tickColor: 'windowText',\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            yAxis: {\n                gridLineColor: 'windowText',\n                labels: {\n                    style: {\n                        color: 'windowText'\n                    }\n                },\n                lineColor: 'windowText',\n                minorGridLineColor: 'windowText',\n                tickColor: 'windowText',\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            tooltip: {\n                backgroundColor: 'window',\n                borderColor: 'windowText',\n                style: {\n                    color: 'windowText'\n                }\n            },\n            plotOptions: {\n                series: {\n                    lineColor: 'windowText',\n                    fillColor: 'window',\n                    borderColor: 'windowText',\n                    edgeColor: 'windowText',\n                    borderWidth: 1,\n                    dataLabels: {\n                        connectorColor: 'windowText',\n                        color: 'windowText',\n                        style: {\n                            color: 'windowText',\n                            textOutline: 'none'\n                        }\n                    },\n                    marker: {\n                        lineColor: 'windowText',\n                        fillColor: 'windowText'\n                    }\n                },\n                pie: {\n                    color: 'window',\n                    colors: ['window'],\n                    borderColor: 'windowText',\n                    borderWidth: 1\n                },\n                boxplot: {\n                    fillColor: 'window'\n                },\n                candlestick: {\n                    lineColor: 'windowText',\n                    fillColor: 'window'\n                },\n                errorbar: {\n                    fillColor: 'window'\n                }\n            },\n            legend: {\n                backgroundColor: 'window',\n                itemStyle: {\n                    color: 'windowText'\n                },\n                itemHoverStyle: {\n                    color: 'windowText'\n                },\n                itemHiddenStyle: {\n                    color: '#555'\n                },\n                title: {\n                    style: {\n                        color: 'windowText'\n                    }\n                }\n            },\n            credits: {\n                style: {\n                    color: 'windowText'\n                }\n            },\n            drilldown: {\n                activeAxisLabelStyle: {\n                    color: 'windowText'\n                },\n                activeDataLabelStyle: {\n                    color: 'windowText'\n                }\n            },\n            navigation: {\n                buttonOptions: {\n                    symbolStroke: 'windowText',\n                    theme: {\n                        fill: 'window'\n                    }\n                }\n            },\n            rangeSelector: {\n                buttonTheme: {\n                    fill: 'window',\n                    stroke: 'windowText',\n                    style: {\n                        color: 'windowText'\n                    },\n                    states: {\n                        hover: {\n                            fill: 'window',\n                            stroke: 'windowText',\n                            style: {\n                                color: 'windowText'\n                            }\n                        },\n                        select: {\n                            fill: '#444',\n                            stroke: 'windowText',\n                            style: {\n                                color: 'windowText'\n                            }\n                        }\n                    }\n                },\n                inputBoxBorderColor: 'windowText',\n                inputStyle: {\n                    backgroundColor: 'window',\n                    color: 'windowText'\n                },\n                labelStyle: {\n                    color: 'windowText'\n                }\n            },\n            navigator: {\n                handles: {\n                    backgroundColor: 'window',\n                    borderColor: 'windowText'\n                },\n                outlineColor: 'windowText',\n                maskFill: 'transparent',\n                series: {\n                    color: 'windowText',\n                    lineColor: 'windowText'\n                },\n                xAxis: {\n                    gridLineColor: 'windowText'\n                }\n            },\n            scrollbar: {\n                barBackgroundColor: '#444',\n                barBorderColor: 'windowText',\n                buttonArrowColor: 'windowText',\n                buttonBackgroundColor: 'window',\n                buttonBorderColor: 'windowText',\n                rifleColor: 'windowText',\n                trackBackgroundColor: 'window',\n                trackBorderColor: 'windowText'\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return theme;\n    });\n    _registerModule(_modules, 'Accessibility/Options/A11yDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Default options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Formatter callback for the accessibility announcement.\n         *\n         * @callback Highcharts.AccessibilityAnnouncementFormatter\n         *\n         * @param {Array<Highcharts.Series>} updatedSeries\n         * Array of all series that received updates. If an announcement is already\n         * queued, the series that received updates for that announcement are also\n         * included in this array.\n         *\n         * @param {Highcharts.Series} [addedSeries]\n         * This is provided if {@link Highcharts.Chart#addSeries} was called, and there\n         * is a new series. In that case, this argument is a reference to the new\n         * series.\n         *\n         * @param {Highcharts.Point} [addedPoint]\n         * This is provided if {@link Highcharts.Series#addPoint} was called, and there\n         * is a new point. In that case, this argument is a reference to the new point.\n         *\n         * @return {false|string}\n         * The function should return a string with the text to announce to the user.\n         * Return empty string to not announce anything. Return `false` to use the\n         * default announcement format.\n         */\n        /**\n         * @interface Highcharts.PointAccessibilityOptionsObject\n         */ /**\n        * Provide a description of the data point, announced to screen readers.\n        * @name Highcharts.PointAccessibilityOptionsObject#description\n        * @type {string|undefined}\n        * @requires modules/accessibility\n        * @since 7.1.0\n        */ /**\n        * Enable or disable exposing the point to assistive technology\n        * @name Highcharts.PointAccessibilityOptionsObject#enabled\n        * @type {boolean|undefined}\n        * @requires modules/accessibility\n        * @since 9.0.1\n        */\n        /* *\n         * @interface Highcharts.PointOptionsObject in parts/Point.ts\n         */ /**\n        * @name Highcharts.PointOptionsObject#accessibility\n        * @type {Highcharts.PointAccessibilityOptionsObject|undefined}\n        * @requires modules/accessibility\n        * @since 7.1.0\n        */\n        /**\n         * @callback Highcharts.ScreenReaderClickCallbackFunction\n         *\n         * @param {global.MouseEvent} evt\n         *        Mouse click event\n         *\n         * @return {void}\n         */\n        /**\n         * Creates a formatted string for the screen reader module.\n         *\n         * @callback Highcharts.ScreenReaderFormatterCallbackFunction<T>\n         *\n         * @param {T} context\n         *        Context to format\n         *\n         * @return {string}\n         *         Formatted string for the screen reader module.\n         */\n        const Options = {\n            /**\n             * Options for configuring accessibility for the chart. Requires the\n             * [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n             * to be loaded. For a description of the module and information\n             * on its features, see\n             * [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).\n             *\n             * @since        5.0.0\n             * @requires     modules/accessibility\n             * @optionparent accessibility\n             */\n            accessibility: {\n                /**\n                 * Enable accessibility functionality for the chart. For more\n                 * information on how to include these features, and why this is\n                 * recommended, see [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).\n                 *\n                 * Highcharts will by default emit a warning to the console if\n                 * the [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n                 * is not loaded. Setting this option to `false` will override\n                 * and silence the warning.\n                 *\n                 * Once the module is loaded, setting this option to `false`\n                 * will disable the module for this chart.\n                 *\n                 * @since 5.0.0\n                 */\n                enabled: true,\n                /**\n                 * Accessibility options for the screen reader information sections\n                 * added before and after the chart.\n                 *\n                 * @since 8.0.0\n                 */\n                screenReaderSection: {\n                    /**\n                     * Function to run upon clicking the \"View as Data Table\" link in\n                     * the screen reader region.\n                     *\n                     * By default Highcharts will insert and set focus to a data table\n                     * representation of the chart.\n                     *\n                     * @type      {Highcharts.ScreenReaderClickCallbackFunction}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.onViewDataTableClick\n                     */\n                    /**\n                     * Function to run upon clicking the \"Play as sound\" button in\n                     * the screen reader region.\n                     *\n                     * By default Highcharts will call the `chart.sonify` function.\n                     *\n                     * @type      {Highcharts.ScreenReaderClickCallbackFunction}\n                     * @since 8.0.1\n                     * @apioption accessibility.screenReaderSection.onPlayAsSoundClick\n                     */\n                    /**\n                     * A formatter function to create the HTML contents of the hidden\n                     * screen reader information region before the chart. Receives one\n                     * argument, `chart`, referring to the chart object. Should return a\n                     * string with the HTML content of the region. By default this\n                     * returns an automatic description of the chart based on\n                     * [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.beforeChartFormatter\n                     */\n                    /**\n                     * Format for the screen reader information region before the chart.\n                     * Supported HTML tags are `<h1-6>`, `<p>`, `<div>`, `<a>`, `<ul>`,\n                     * `<ol>`, `<li>`, and `<button>`. Attributes are not supported,\n                     * except for id on `<div>`, `<a>`, and `<button>`. Id is required\n                     * on `<a>` and `<button>` in the format `<tag id=\"abcd\">`. Numbers,\n                     * lower- and uppercase letters, \"-\" and \"#\" are valid characters in\n                     * IDs.\n                     *\n                     * The headingTagName is an auto-detected heading (h1-h6) that\n                     * corresponds to the heading level below the previous heading in\n                     * the DOM.\n                     *\n                     * Set to empty string to remove the region altogether.\n                     *\n                     * @since 8.0.0\n                     */\n                    beforeChartFormat: '<{headingTagName}>{chartTitle}</{headingTagName}>' +\n                        '<div>{typeDescription}</div>' +\n                        '<div>{chartSubtitle}</div>' +\n                        '<div>{chartLongdesc}</div>' +\n                        '<div>{playAsSoundButton}</div>' +\n                        '<div>{viewTableButton}</div>' +\n                        '<div>{xAxisDescription}</div>' +\n                        '<div>{yAxisDescription}</div>' +\n                        '<div>{annotationsTitle}{annotationsList}</div>',\n                    /**\n                     * A formatter function to create the HTML contents of the hidden\n                     * screen reader information region after the chart. Analogous to\n                     * [beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}\n                     * @since 8.0.0\n                     * @apioption accessibility.screenReaderSection.afterChartFormatter\n                     */\n                    /**\n                     * Format for the screen reader information region after the chart.\n                     * Analogous to [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).\n                     *\n                     * @since 8.0.0\n                     */\n                    afterChartFormat: '{endOfChartMarker}',\n                    /**\n                     * Date format to use to describe range of datetime axes.\n                     *\n                     * For an overview of the replacement codes, see\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [point.dateFormat](#accessibility.point.dateFormat)\n                     *\n                     * @since 8.0.0\n                     */\n                    axisRangeDateFormat: '%Y-%m-%d %H:%M:%S'\n                },\n                /**\n                 * Accessibility options global to all data series. Individual series\n                 * can also have specific [accessibility options](#plotOptions.series.accessibility)\n                 * set.\n                 *\n                 * @since 8.0.0\n                 */\n                series: {\n                    /**\n                     * Formatter function to use instead of the default for series\n                     * descriptions. Receives one argument, `series`, referring to the\n                     * series to describe. Should return a string with the description\n                     * of the series for a screen reader user. If `false` is returned,\n                     * the default formatter will be used for that series.\n                     *\n                     * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)\n                     * @see [series.description](#plotOptions.series.description)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Series>}\n                     * @since 8.0.0\n                     * @apioption accessibility.series.descriptionFormatter\n                     */\n                    /**\n                     * Format to use for describing the data series group to assistive\n                     * technology - including screen readers.\n                     *\n                     * The series context and its subproperties are available under the\n                     * variable `{series}`, for example `{series.name}` for the series\n                     * name, and `{series.points.length}` for the number of data points.\n                     *\n                     * The chart context and its subproperties are available under the\n                     * variable `{chart}`, for example `{chart.series.length}` for the\n                     * number of series in the chart.\n                     *\n                     * `{seriesDescription}` refers to the automatic description of the\n                     * series type and number of points added by Highcharts by default.\n                     * `{authorDescription}` refers to the description added in\n                     * [series.description](#plotOptions.series.description) if one is\n                     * present. `{axisDescription}` refers to the description added if\n                     * the chart has multiple X or Y axes.\n                     *\n                     * Note that if [series.descriptionFormatter](#accessibility.series.descriptionFormatter)\n                     * is declared it will take precedence, and this option will be\n                     * overridden.\n                     *\n                     * @sample highcharts/accessibility/advanced-accessible\n                     *  Accessible low-medium-high chart\n                     *\n                     * @type      {string}\n                     * @since 10.1.0\n                     */\n                    descriptionFormat: '{seriesDescription}{authorDescription}{axisDescription}',\n                    /**\n                     * Whether or not to add series descriptions to charts with a single\n                     * series.\n                     *\n                     * @since 8.0.0\n                     */\n                    describeSingleSeries: false,\n                    /**\n                     * When a series contains more points than this, we no longer expose\n                     * information about individual points to screen readers.\n                     *\n                     * Set to `false` to disable.\n                     *\n                     * @type  {boolean|number}\n                     * @since 8.0.0\n                     */\n                    pointDescriptionEnabledThreshold: 200\n                },\n                /**\n                 * Options for descriptions of individual data points.\n                 *\n                 * @since 8.0.0\n                 */\n                point: {\n                    /**\n                     * Date format to use for points on datetime axes when describing\n                     * them to screen reader users.\n                     *\n                     * Defaults to the same format as in tooltip.\n                     *\n                     * For an overview of the replacement codes, see\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [dateFormatter](#accessibility.point.dateFormatter)\n                     *\n                     * @type      {string}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.dateFormat\n                     */\n                    /**\n                     * Formatter function to determine the date/time format used with\n                     * points on datetime axes when describing them to screen reader\n                     * users. Receives one argument, `point`, referring to the point\n                     * to describe. Should return a date format string compatible with\n                     * [dateFormat](/class-reference/Highcharts.Time#dateFormat).\n                     *\n                     * @see [dateFormat](#accessibility.point.dateFormat)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.dateFormatter\n                     */\n                    /**\n                     * Prefix to add to the values in the point descriptions. Uses\n                     * [tooltip.valuePrefix](#tooltip.valuePrefix) if not defined.\n                     *\n                     * @type        {string}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valuePrefix\n                     */\n                    /**\n                     * Suffix to add to the values in the point descriptions. Uses\n                     * [tooltip.valueSuffix](#tooltip.valueSuffix) if not defined.\n                     *\n                     * @type        {string}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valueSuffix\n                     */\n                    /**\n                     * Decimals to use for the values in the point descriptions. Uses\n                     * [tooltip.valueDecimals](#tooltip.valueDecimals) if not defined.\n                     *\n                     * @type        {number}\n                     * @since 8.0.0\n                     * @apioption   accessibility.point.valueDecimals\n                     */\n                    /**\n                     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n                     * to use instead of the default for point descriptions.\n                     *\n                     * The context of the format string is the point instance.\n                     *\n                     * As opposed to [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat),\n                     * this option replaces the whole description.\n                     *\n                     * @type      {string}\n                     * @since 11.1.0\n                     * @sample highcharts/demo/advanced-accessible\n                     *      Description format\n                     * @apioption accessibility.point.descriptionFormat\n                     */\n                    /**\n                     * Formatter function to use instead of the default for point\n                     * descriptions.\n                     *\n                     * Receives one argument, `point`, referring to the point to\n                     * describe. Should return a string with the description of the\n                     * point for a screen reader user. If `false` is returned, the\n                     * default formatter will be used for that point.\n                     *\n                     * Note: Prefer using [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)\n                     * instead if possible, as default functionality such as describing\n                     * annotations will be preserved.\n                     *\n                     * @see [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)\n                     * @see [point.accessibility.description](#series.line.data.accessibility.description)\n                     *\n                     * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n                     * @since 8.0.0\n                     * @apioption accessibility.point.descriptionFormatter\n                     */\n                    /**\n                     * Format to use for describing the values of data points\n                     * to assistive technology - including screen readers.\n                     * The point context is available as `{point}`.\n                     *\n                     * Other available context variables include `{index}`, `{value}`, and `{xDescription}`.\n                     *\n                     * Additionally, the series name, annotation info, and\n                     * description added in `point.accessibility.description`\n                     * is added by default if relevant. To override this, use the\n                     * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n                     * option.\n                     *\n                     * @see [point.accessibility.description](#series.line.data.accessibility.description)\n                     * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n                     *\n                     * @type      {string}\n                     * @since 8.0.1\n                     */\n                    valueDescriptionFormat: '{xDescription}{separator}{value}.',\n                    /**\n                     * Whether or not to describe points with the value `null` to\n                     * assistive technology, such as screen readers.\n                     *\n                     * @sample {highmaps} maps/demo/all-areas-as-null\n                     *         Accessible map with null points\n                     *\n                     * @type      {boolean}\n                     * @since 10.1.0\n                     */\n                    describeNull: true\n                },\n                /**\n                 * Amount of landmarks/regions to create for screen reader users. More\n                 * landmarks can make navigation with screen readers easier, but can\n                 * be distracting if there are lots of charts on the page. Three modes\n                 * are available:\n                 *  - `all`: Adds regions for all series, legend, information\n                 *      region.\n                 *  - `one`: Adds a single landmark per chart.\n                 *  - `disabled`: No landmarks are added.\n                 *\n                 * @since 7.1.0\n                 * @validvalue [\"all\", \"one\", \"disabled\"]\n                 */\n                landmarkVerbosity: 'all',\n                /**\n                 * Link the chart to an HTML element describing the contents of the\n                 * chart.\n                 *\n                 * It is always recommended to describe charts using visible text, to\n                 * improve SEO as well as accessibility for users with disabilities.\n                 * This option lets an HTML element with a description be linked to the\n                 * chart, so that screen reader users can connect the two.\n                 *\n                 * By setting this option to a string, Highcharts runs the string as an\n                 * HTML selector query on the entire document. If there is only a single\n                 * match, this element is linked to the chart. The content of the linked\n                 * element will be included in the chart description for screen reader\n                 * users.\n                 *\n                 * By default, the chart looks for an adjacent sibling element with the\n                 * `highcharts-description` class.\n                 *\n                 * The feature can be disabled by setting the option to an empty string,\n                 * or overridden by providing the\n                 * [accessibility.description](#accessibility.description) option.\n                 * Alternatively, the HTML element to link can be passed in directly as\n                 * an HTML node.\n                 *\n                 * If you need the description to be part of the exported image,\n                 * consider using the [caption](#caption) feature.\n                 *\n                 * If you need the description to be hidden visually, use the\n                 * [accessibility.description](#accessibility.description) option.\n                 *\n                 * @see [caption](#caption)\n                 * @see [description](#accessibility.description)\n                 * @see [typeDescription](#accessibility.typeDescription)\n                 *\n                 * @sample highcharts/accessibility/accessible-line\n                 *         Accessible line chart\n                 *\n                 * @type  {string|Highcharts.HTMLDOMElement}\n                 * @since 8.0.0\n                 */\n                linkedDescription: '*[data-highcharts-chart=\"{index}\"] + .highcharts-description',\n                /**\n                 * A hook for adding custom components to the accessibility module.\n                 * Should be an object mapping component names to instances of classes\n                 * inheriting from the Highcharts.AccessibilityComponent base class.\n                 * Remember to add the component to the\n                 * [keyboardNavigation.order](#accessibility.keyboardNavigation.order)\n                 * for the keyboard navigation to be usable.\n                 *\n                 * @sample highcharts/accessibility/custom-component\n                 *         Custom accessibility component\n                 *\n                 * @type      {*}\n                 * @since     7.1.0\n                 * @apioption accessibility.customComponents\n                 */\n                /**\n                 * Theme to apply to the chart when Windows High Contrast Mode is\n                 * detected. By default, a high contrast theme matching the high\n                 * contrast system system colors is used.\n                 *\n                 * @type      {*}\n                 * @since     7.1.3\n                 * @apioption accessibility.highContrastTheme\n                 */\n                /**\n                 * A text description of the chart.\n                 *\n                 * **Note: Prefer using [linkedDescription](#accessibility.linkedDescription)\n                 * or [caption](#caption.text) instead.**\n                 *\n                 * If the Accessibility module is loaded, this option is included by\n                 * default as a long description of the chart in the hidden screen\n                 * reader information region.\n                 *\n                 * Note: Since Highcharts now supports captions and linked descriptions,\n                 * it is preferred to define the description using those methods, as a\n                 * visible caption/description benefits all users. If the\n                 * `accessibility.description` option is defined, the linked description\n                 * is ignored, and the caption is hidden from screen reader users.\n                 *\n                 * @see [linkedDescription](#accessibility.linkedDescription)\n                 * @see [caption](#caption)\n                 * @see [typeDescription](#accessibility.typeDescription)\n                 *\n                 * @type      {string}\n                 * @since     5.0.0\n                 * @apioption accessibility.description\n                 */\n                /**\n                 * A text description of the chart type.\n                 *\n                 * If the Accessibility module is loaded, this will be included in the\n                 * description of the chart in the screen reader information region.\n                 *\n                 * Highcharts will by default attempt to guess the chart type, but for\n                 * more complex charts it is recommended to specify this property for\n                 * clarity.\n                 *\n                 * @type      {string}\n                 * @since     5.0.0\n                 * @apioption accessibility.typeDescription\n                 */\n                /**\n                 * Options for keyboard navigation.\n                 *\n                 * @declare Highcharts.KeyboardNavigationOptionsObject\n                 * @since   5.0.0\n                 */\n                keyboardNavigation: {\n                    /**\n                     * Enable keyboard navigation for the chart.\n                     *\n                     * @since 5.0.0\n                     */\n                    enabled: true,\n                    /**\n                     * Options for the focus border drawn around elements while\n                     * navigating through them.\n                     *\n                     * @sample highcharts/accessibility/custom-focus\n                     *         Custom focus ring\n                     *\n                     * @declare Highcharts.KeyboardNavigationFocusBorderOptionsObject\n                     * @since   6.0.3\n                     */\n                    focusBorder: {\n                        /**\n                         * Enable/disable focus border for chart.\n                         *\n                         * @since 6.0.3\n                         */\n                        enabled: true,\n                        /**\n                         * Hide the browser's default focus indicator.\n                         *\n                         * @since 6.0.4\n                         */\n                        hideBrowserFocusOutline: true,\n                        /**\n                         * Style options for the focus border drawn around elements\n                         * while navigating through them. Note that some browsers in\n                         * addition draw their own borders for focused elements. These\n                         * automatic borders cannot be styled by Highcharts.\n                         *\n                         * In styled mode, the border is given the\n                         * `.highcharts-focus-border` class.\n                         *\n                         * @type    {Highcharts.CSSObject}\n                         * @since   6.0.3\n                         */\n                        style: {\n                            /** @internal */\n                            color: \"#334eff\" /* Palette.highlightColor80 */,\n                            /** @internal */\n                            lineWidth: 2,\n                            /** @internal */\n                            borderRadius: 3\n                        },\n                        /**\n                         * Focus border margin around the elements.\n                         *\n                         * @since 6.0.3\n                         */\n                        margin: 2\n                    },\n                    /**\n                     * Order of tab navigation in the chart. Determines which elements\n                     * are tabbed to first. Available elements are: `series`, `zoom`,\n                     * `rangeSelector`, `chartMenu`, `legend` and `container`. In\n                     * addition, any custom components can be added here. Adding\n                     * `container` first in order will make the keyboard focus stop on\n                     * the chart container first, requiring the user to tab again to\n                     * enter the chart.\n                     *\n                     * @type  {Array<string>}\n                     * @since 7.1.0\n                     */\n                    order: ['series', 'zoom', 'rangeSelector', 'legend', 'chartMenu'],\n                    /**\n                     * Whether or not to wrap around when reaching the end of arrow-key\n                     * navigation for an element in the chart.\n                     * @since 7.1.0\n                     */\n                    wrapAround: true,\n                    /**\n                     * Options for the keyboard navigation of data points and series.\n                     *\n                     * @declare Highcharts.KeyboardNavigationSeriesNavigationOptionsObject\n                     * @since 8.0.0\n                     */\n                    seriesNavigation: {\n                        /**\n                         * Set the keyboard navigation mode for the chart. Can be\n                         * \"normal\" or \"serialize\". In normal mode, left/right arrow\n                         * keys move between points in a series, while up/down arrow\n                         * keys move between series. Up/down navigation acts\n                         * intelligently to figure out which series makes sense to move\n                         * to from any given point.\n                         *\n                         * In \"serialize\" mode, points are instead navigated as a single\n                         * list. Left/right behaves as in \"normal\" mode. Up/down arrow\n                         * keys will behave like left/right. This can be useful for\n                         * unifying navigation behavior with/without screen readers\n                         * enabled.\n                         *\n                         * @type       {string}\n                         * @default    normal\n                         * @since 8.0.0\n                         * @validvalue [\"normal\", \"serialize\"]\n                         * @apioption  accessibility.keyboardNavigation.seriesNavigation.mode\n                         */\n                        /**\n                         * Skip null points when navigating through points with the\n                         * keyboard.\n                         *\n                         * @since 8.0.0\n                         */\n                        skipNullPoints: true,\n                        /**\n                         * When a series contains more points than this, we no longer\n                         * allow keyboard navigation for it.\n                         *\n                         * Set to `false` to disable.\n                         *\n                         * @type  {boolean|number}\n                         * @since 8.0.0\n                         */\n                        pointNavigationEnabledThreshold: false,\n                        /**\n                         * Remember which point was focused even after navigating away\n                         * from the series, so that when navigating back to the series\n                         * you start at the last focused point.\n                         *\n                         * @type  {boolean}\n                         * @since 10.1.0\n                         */\n                        rememberPointFocus: false\n                    }\n                },\n                /**\n                 * Options for announcing new data to screen reader users. Useful\n                 * for dynamic data applications and drilldown.\n                 *\n                 * Keep in mind that frequent announcements will not be useful to\n                 * users, as they won't have time to explore the new data. For these\n                 * applications, consider making snapshots of the data accessible, and\n                 * do the announcements in batches.\n                 *\n                 * @declare Highcharts.AccessibilityAnnounceNewDataOptionsObject\n                 * @since   7.1.0\n                 */\n                announceNewData: {\n                    /**\n                     * Optional formatter callback for the announcement. Receives\n                     * up to three arguments. The first argument is always an array\n                     * of all series that received updates. If an announcement is\n                     * already queued, the series that received updates for that\n                     * announcement are also included in this array. The second\n                     * argument is provided if `chart.addSeries` was called, and\n                     * there is a new series. In that case, this argument is a\n                     * reference to the new series. The third argument, similarly,\n                     * is provided if `series.addPoint` was called, and there is a\n                     * new point. In that case, this argument is a reference to the\n                     * new point.\n                     *\n                     * The function should return a string with the text to announce\n                     * to the user. Return empty string to not announce anything.\n                     * Return `false` to use the default announcement format.\n                     *\n                     * @sample highcharts/accessibility/custom-dynamic\n                     *         High priority live alerts\n                     *\n                     * @type      {Highcharts.AccessibilityAnnouncementFormatter}\n                     * @apioption accessibility.announceNewData.announcementFormatter\n                     */\n                    /**\n                     * Enable announcing new data to screen reader users\n                     * @sample highcharts/accessibility/accessible-dynamic\n                     *         Dynamic data accessible\n                     */\n                    enabled: false,\n                    /**\n                     * Minimum interval between announcements in milliseconds. If\n                     * new data arrives before this amount of time has passed, it is\n                     * queued for announcement. If another new data event happens\n                     * while an announcement is queued, the queued announcement is\n                     * dropped, and the latest announcement is queued instead. Set\n                     * to 0 to allow all announcements, but be warned that frequent\n                     * announcements are disturbing to users.\n                     */\n                    minAnnounceInterval: 5000,\n                    /**\n                     * Choose whether or not the announcements should interrupt the\n                     * screen reader. If not enabled, the user will be notified once\n                     * idle. It is recommended not to enable this setting unless\n                     * there is a specific reason to do so.\n                     */\n                    interruptUser: false\n                }\n            },\n            /**\n             * Accessibility options for a data point.\n             *\n             * @declare   Highcharts.PointAccessibilityOptionsObject\n             * @since     7.1.0\n             * @apioption series.line.data.accessibility\n             */\n            /**\n             * Provide a description of the data point, announced to screen readers.\n             *\n             * @type      {string}\n             * @since     7.1.0\n             * @apioption series.line.data.accessibility.description\n             */\n            /**\n             * Set to false to disable accessibility functionality for a specific point.\n             * The point will not be included in keyboard navigation, and will not be\n             * exposed to assistive technology.\n             *\n             * @type      {boolean}\n             * @since 9.0.1\n             * @apioption series.line.data.accessibility.enabled\n             */\n            /**\n             * Accessibility options for a series.\n             *\n             * @declare    Highcharts.SeriesAccessibilityOptionsObject\n             * @since      7.1.0\n             * @requires   modules/accessibility\n             * @apioption  plotOptions.series.accessibility\n             */\n            /**\n             * Enable/disable accessibility functionality for a specific series.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.enabled\n             */\n            /**\n             * Provide a description of the series, announced to screen readers.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.description\n             */\n            /**\n             * Format to use for describing the data series group to assistive\n             * technology - including screen readers.\n             *\n             * @see [series.descriptionFormat](#accessibility.series.descriptionFormat)\n             * @type       {string}\n             * @since 11.0.0\n             * @apioption  plotOptions.series.accessibility.descriptionFormat\n             */\n            /**\n             * Expose only the series element to screen readers, not its points.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.exposeAsGroupOnly\n             */\n            /**\n             * Point accessibility options for a series.\n             *\n             * @extends    accessibility.point\n             * @since 9.3.0\n             * @requires   modules/accessibility\n             * @apioption  plotOptions.series.accessibility.point\n             */\n            /**\n             * Formatter function to use instead of the default for point\n             * descriptions. Same as `accessibility.point.descriptionFormatter`, but\n             * applies to a series instead of the whole chart.\n             *\n             * Note: Prefer using [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)\n             * instead if possible, as default functionality such as describing\n             * annotations will be preserved.\n             *\n             * @see [accessibility.point.valueDescriptionFormat](#plotOptions.series.accessibility.point.valueDescriptionFormat)\n             * @see [point.accessibility.description](#series.line.data.accessibility.description)\n             * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)\n             *\n             * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}\n             * @since 9.3.0\n             * @apioption plotOptions.series.accessibility.point.descriptionFormatter\n             */\n            /**\n             * Keyboard navigation for a series\n             *\n             * @declare    Highcharts.SeriesAccessibilityKeyboardNavigationOptionsObject\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.keyboardNavigation\n             */\n            /**\n             * Enable/disable keyboard navigation support for a specific series.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  plotOptions.series.accessibility.keyboardNavigation.enabled\n             */\n            /**\n             * Accessibility options for an annotation label.\n             *\n             * @declare    Highcharts.AnnotationLabelAccessibilityOptionsObject\n             * @since 8.0.1\n             * @requires   modules/accessibility\n             * @apioption  annotations.labelOptions.accessibility\n             */\n            /**\n             * Description of an annotation label for screen readers and other assistive\n             * technology.\n             *\n             * @type       {string}\n             * @since 8.0.1\n             * @apioption  annotations.labelOptions.accessibility.description\n             */\n            /**\n             * Accessibility options for an axis. Requires the accessibility module.\n             *\n             * @declare    Highcharts.AxisAccessibilityOptionsObject\n             * @since      7.1.0\n             * @requires   modules/accessibility\n             * @apioption  xAxis.accessibility\n             */\n            /**\n             * Enable axis accessibility features, including axis information in the\n             * screen reader information region. If this is disabled on the xAxis, the\n             * x values are not exposed to screen readers for the individual data points\n             * by default.\n             *\n             * @type       {boolean}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.enabled\n             */\n            /**\n             * Description for an axis to expose to screen reader users.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.description\n             */\n            /**\n             * Range description for an axis. Overrides the default range description.\n             * Set to empty to disable range description for this axis.\n             *\n             * @type       {string}\n             * @since      7.1.0\n             * @apioption  xAxis.accessibility.rangeDescription\n             */\n            /**\n             * @optionparent legend\n             */\n            legend: {\n                /**\n                 * Accessibility options for the legend. Requires the Accessibility\n                 * module.\n                 *\n                 * @since     7.1.0\n                 * @requires  modules/accessibility\n                 */\n                accessibility: {\n                    /**\n                     * Enable accessibility support for the legend.\n                     *\n                     * @since  7.1.0\n                     */\n                    enabled: true,\n                    /**\n                     * Options for keyboard navigation for the legend.\n                     *\n                     * @since     7.1.0\n                     * @requires  modules/accessibility\n                     */\n                    keyboardNavigation: {\n                        /**\n                         * Enable keyboard navigation for the legend.\n                         *\n                         * @see [accessibility.keyboardNavigation](#accessibility.keyboardNavigation.enabled)\n                         *\n                         * @since  7.1.0\n                         */\n                        enabled: true\n                    }\n                }\n            },\n            /**\n             * @optionparent exporting\n             */\n            exporting: {\n                /**\n                 * Accessibility options for the exporting menu. Requires the\n                 * Accessibility module.\n                 *\n                 * @since    7.1.0\n                 * @requires modules/accessibility\n                 */\n                accessibility: {\n                    /**\n                     * Enable accessibility support for the export menu.\n                     *\n                     * @since 7.1.0\n                     */\n                    enabled: true\n                }\n            }\n        };\n\n        return Options;\n    });\n    _registerModule(_modules, 'Accessibility/Options/LangDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Default lang/i18n options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        const langOptions = {\n            /**\n             * Configure the accessibility strings in the chart. Requires the\n             * [accessibility module](https://code.highcharts.com/modules/accessibility.js)\n             * to be loaded. For a description of the module and information on its\n             * features, see\n             * [Highcharts Accessibility](https://www.highcharts.com/docs/chart-concepts/accessibility).\n             *\n             * The lang options use [Format Strings](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#format-strings)\n             * with variables that are replaced at run time. These variables should be\n             * used when available, to avoid duplicating text that is defined elsewhere.\n             *\n             * For more dynamic control over the accessibility functionality, see\n             * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter),\n             * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),\n             * and\n             * [accessibility.screenReaderSection.beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).\n             *\n             * @since        6.0.6\n             * @optionparent lang.accessibility\n             */\n            accessibility: {\n                /**\n                 * @deprecated 10.2.1\n                 * @type       {string}\n                 * @apioption  lang.accessibility.resetZoomButton\n                 */\n                /**\n                 * Default title of the chart for assistive technology, for charts\n                 * without a chart title.\n                 */\n                defaultChartTitle: 'Chart',\n                /**\n                 * Accessible label for the chart container HTML element.\n                 * `{title}` refers to the chart title.\n                 */\n                chartContainerLabel: '{title}. Highcharts interactive chart.',\n                /**\n                 * Accessible label for the chart SVG element.\n                 * `{chartTitle}` refers to the chart title.\n                 */\n                svgContainerLabel: 'Interactive chart',\n                /**\n                 * Accessible label for the drill-up button.\n                 * `{buttonText}` refers to the visual text on the button.\n                 */\n                drillUpButton: '{buttonText}',\n                /**\n                 * Accessible label for the chart credits.\n                 * `{creditsStr}` refers to the visual text in the credits.\n                 */\n                credits: 'Chart credits: {creditsStr}',\n                /**\n                 * Thousands separator to use when formatting numbers for screen\n                 * readers. Note that many screen readers will not handle space as a\n                 * thousands separator, and will consider \"11 700\" as two numbers.\n                 *\n                 * Set to `null` to use the separator defined in\n                 * [lang.thousandsSep](lang.thousandsSep).\n                 *\n                 * @since 7.1.0\n                 */\n                thousandsSep: ',',\n                /**\n                 * Title element text for the chart SVG element. Leave this\n                 * empty to disable adding the title element. Browsers will display\n                 * this content when hovering over elements in the chart. Assistive\n                 * technology may use this element to label the chart.\n                 *\n                 * @since 6.0.8\n                 */\n                svgContainerTitle: '',\n                /**\n                 * Set a label on the container wrapping the SVG.\n                 *\n                 * @see [chartContainerLabel](#lang.accessibility.chartContainerLabel)\n                 *\n                 * @since 8.0.0\n                 */\n                graphicContainerLabel: '',\n                /**\n                 * Language options for the screen reader information sections added\n                 * before and after the charts.\n                 *\n                 * @since 8.0.0\n                 */\n                screenReaderSection: {\n                    beforeRegionLabel: '',\n                    afterRegionLabel: '',\n                    /**\n                     * Language options for annotation descriptions.\n                     *\n                     * @since 8.0.1\n                     */\n                    annotations: {\n                        heading: 'Chart annotations summary',\n                        descriptionSinglePoint: ('{annotationText}. Related to {annotationPoint}'),\n                        descriptionMultiplePoints: ('{annotationText}. Related to {annotationPoint}' +\n                            '{#each additionalAnnotationPoints}' +\n                            ', also related to {this}' +\n                            '{/each}'),\n                        descriptionNoPoints: '{annotationText}'\n                    },\n                    /**\n                     * Label for the end of the chart. Announced by screen readers.\n                     *\n                     * @since 8.0.0\n                     */\n                    endOfChartMarker: 'End of interactive chart.'\n                },\n                /**\n                 * Language options for sonification.\n                 *\n                 * @since 8.0.1\n                 */\n                sonification: {\n                    playAsSoundButtonText: 'Play as sound, {chartTitle}',\n                    playAsSoundClickAnnouncement: 'Play'\n                },\n                /**\n                 * Language options for accessibility of the legend.\n                 *\n                 * @since 8.0.0\n                 */\n                legend: {\n                    /**\n                     * Accessible label for the legend, for charts where there is no\n                     * legend title defined.\n                     */\n                    legendLabelNoTitle: 'Toggle series visibility, {chartTitle}',\n                    /**\n                     * Accessible label for the legend, for charts where there is a\n                     * legend title defined. `{legendTitle}` refers to the visual text\n                     * in the legend title.\n                     */\n                    legendLabel: 'Chart legend: {legendTitle}',\n                    /**\n                     * Accessible label for individual legend items. `{itemName}` refers\n                     * to the visual text in the legend for that item.\n                     */\n                    legendItem: 'Show {itemName}'\n                },\n                /**\n                 * Chart and map zoom accessibility language options.\n                 *\n                 * @since 8.0.0\n                 */\n                zoom: {\n                    mapZoomIn: 'Zoom chart',\n                    mapZoomOut: 'Zoom out chart',\n                    resetZoomButton: 'Reset zoom'\n                },\n                /**\n                 * Range selector language options for accessibility.\n                 *\n                 * @since 8.0.0\n                 */\n                rangeSelector: {\n                    dropdownLabel: '{rangeTitle}',\n                    minInputLabel: 'Select start date.',\n                    maxInputLabel: 'Select end date.',\n                    clickButtonAnnouncement: 'Viewing {axisRangeDescription}'\n                },\n                /**\n                 * Accessibility language options for the data table.\n                 *\n                 * @since 8.0.0\n                 */\n                table: {\n                    viewAsDataTableButtonText: 'View as data table, {chartTitle}',\n                    tableSummary: 'Table representation of chart.'\n                },\n                /**\n                 * Default announcement for new data in charts. If addPoint or\n                 * addSeries is used, and only one series/point is added, the\n                 * `newPointAnnounce` and `newSeriesAnnounce` strings are used.\n                 * The `...Single` versions will be used if there is only one chart\n                 * on the page, and the `...Multiple` versions will be used if there\n                 * are multiple charts on the page. For all other new data events,\n                 * the `newDataAnnounce` string will be used.\n                 *\n                 * @since 7.1.0\n                 */\n                announceNewData: {\n                    newDataAnnounce: 'Updated data for chart {chartTitle}',\n                    newSeriesAnnounceSingle: 'New data series: {seriesDesc}',\n                    newPointAnnounceSingle: 'New data point: {pointDesc}',\n                    newSeriesAnnounceMultiple: 'New data series in chart {chartTitle}: {seriesDesc}',\n                    newPointAnnounceMultiple: 'New data point in chart {chartTitle}: {pointDesc}'\n                },\n                /**\n                 * Descriptions of lesser known series types. The relevant\n                 * description is added to the screen reader information region\n                 * when these series types are used.\n                 *\n                 * @since 6.0.6\n                 */\n                seriesTypeDescriptions: {\n                    boxplot: 'Box plot charts are typically used to display ' +\n                        'groups of statistical data. Each data point in the ' +\n                        'chart can have up to 5 values: minimum, lower quartile, ' +\n                        'median, upper quartile, and maximum.',\n                    arearange: 'Arearange charts are line charts displaying a ' +\n                        'range between a lower and higher value for each point.',\n                    areasplinerange: 'These charts are line charts displaying a ' +\n                        'range between a lower and higher value for each point.',\n                    bubble: 'Bubble charts are scatter charts where each data ' +\n                        'point also has a size value.',\n                    columnrange: 'Columnrange charts are column charts ' +\n                        'displaying a range between a lower and higher value for ' +\n                        'each point.',\n                    errorbar: 'Errorbar series are used to display the ' +\n                        'variability of the data.',\n                    funnel: 'Funnel charts are used to display reduction of data ' +\n                        'in stages.',\n                    pyramid: 'Pyramid charts consist of a single pyramid with ' +\n                        'item heights corresponding to each point value.',\n                    waterfall: 'A waterfall chart is a column chart where each ' +\n                        'column contributes towards a total end value.'\n                },\n                /**\n                 * Chart type description strings. This is added to the chart\n                 * information region.\n                 *\n                 * If there is only a single series type used in the chart, we use\n                 * the format string for the series type, or default if missing.\n                 * There is one format string for cases where there is only a single\n                 * series in the chart, and one for multiple series of the same\n                 * type.\n                 *\n                 * @since 6.0.6\n                 */\n                chartTypes: {\n                    /* eslint-disable max-len */\n                    emptyChart: 'Empty chart',\n                    mapTypeDescription: 'Map of {mapTitle} with {numSeries} data series.',\n                    unknownMap: 'Map of unspecified region with {numSeries} data series.',\n                    combinationChart: 'Combination chart with {numSeries} data series.',\n                    defaultSingle: 'Chart with {numPoints} data ' +\n                        '{#eq numPoints 1}point{else}points{/eq}.',\n                    defaultMultiple: 'Chart with {numSeries} data series.',\n                    splineSingle: 'Line chart with {numPoints} data ' +\n                        '{#eq numPoints 1}point{else}points{/eq}.',\n                    splineMultiple: 'Line chart with {numSeries} lines.',\n                    lineSingle: 'Line chart with {numPoints} data ' +\n                        '{#eq numPoints 1}point{else}points{/eq}.',\n                    lineMultiple: 'Line chart with {numSeries} lines.',\n                    columnSingle: 'Bar chart with {numPoints} ' +\n                        '{#eq numPoints 1}bar{else}bars{/eq}.',\n                    columnMultiple: 'Bar chart with {numSeries} data series.',\n                    barSingle: 'Bar chart with {numPoints} ' +\n                        '{#eq numPoints 1}bar{else}bars{/eq}.',\n                    barMultiple: 'Bar chart with {numSeries} data series.',\n                    pieSingle: 'Pie chart with {numPoints} ' +\n                        '{#eq numPoints 1}slice{else}slices{/eq}.',\n                    pieMultiple: 'Pie chart with {numSeries} pies.',\n                    scatterSingle: 'Scatter chart with {numPoints} ' +\n                        '{#eq numPoints 1}point{else}points{/eq}.',\n                    scatterMultiple: 'Scatter chart with {numSeries} data series.',\n                    boxplotSingle: 'Boxplot with {numPoints} ' +\n                        '{#eq numPoints 1}box{else}boxes{/eq}.',\n                    boxplotMultiple: 'Boxplot with {numSeries} data series.',\n                    bubbleSingle: 'Bubble chart with {numPoints} ' +\n                        '{#eq numPoints 1}bubbles{else}bubble{/eq}.',\n                    bubbleMultiple: 'Bubble chart with {numSeries} data series.'\n                },\n                /**\n                 * Axis description format strings.\n                 *\n                 * @since 6.0.6\n                 */\n                axis: {\n                    /* eslint-disable max-len */\n                    xAxisDescriptionSingular: 'The chart has 1 X axis displaying {names[0]}. {ranges[0]}',\n                    xAxisDescriptionPlural: 'The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.',\n                    yAxisDescriptionSingular: 'The chart has 1 Y axis displaying {names[0]}. {ranges[0]}',\n                    yAxisDescriptionPlural: 'The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.',\n                    timeRangeDays: 'Data range: {range} days.',\n                    timeRangeHours: 'Data range: {range} hours.',\n                    timeRangeMinutes: 'Data range: {range} minutes.',\n                    timeRangeSeconds: 'Data range: {range} seconds.',\n                    rangeFromTo: 'Data ranges from {rangeFrom} to {rangeTo}.',\n                    rangeCategories: 'Data range: {numCategories} categories.'\n                },\n                /**\n                 * Exporting menu format strings for accessibility module.\n                 *\n                 * @since 6.0.6\n                 */\n                exporting: {\n                    chartMenuLabel: 'Chart menu',\n                    menuButtonLabel: 'View chart menu, {chartTitle}'\n                },\n                /**\n                 * Lang configuration for different series types. For more dynamic\n                 * control over the series element descriptions, see\n                 * [accessibility.seriesDescriptionFormatter](#accessibility.seriesDescriptionFormatter).\n                 *\n                 * @since 6.0.6\n                 */\n                series: {\n                    /**\n                     * Lang configuration for the series main summary. Each series\n                     * type has two modes:\n                     *\n                     * 1. This series type is the only series type used in the\n                     *    chart\n                     *\n                     * 2. This is a combination chart with multiple series types\n                     *\n                     * If a definition does not exist for the specific series type\n                     * and mode, the 'default' lang definitions are used.\n                     *\n                     * Chart and its subproperties can be accessed with the `{chart}` variable.\n                     * The series and its subproperties can be accessed with the `{series}` variable.\n                     *\n                     * The series index (starting from 1) can be accessed with the `{seriesNumber}` variable.\n                     *\n                     * @since 6.0.6\n                     */\n                    summary: {\n                        /* eslint-disable max-len */\n                        'default': '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        defaultCombination: '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        line: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        lineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        spline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        splineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        column: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',\n                        columnCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',\n                        bar: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',\n                        barCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',\n                        pie: '{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.',\n                        pieCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.',\n                        scatter: '{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.',\n                        scatterCombination: '{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.',\n                        boxplot: '{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.',\n                        boxplotCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.',\n                        bubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',\n                        bubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',\n                        map: '{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.',\n                        mapCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.',\n                        mapline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        maplineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',\n                        mapbubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',\n                        mapbubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.'\n                    },\n                    /**\n                     * User supplied description text. This is added in the point\n                     * comment description by default if present.\n                     *\n                     * `{description}` refers to the value given in\n                     * [point.accessibility.description](#series.line.data.accessibility.description).\n                     *\n                     * @since 6.0.6\n                     */\n                    description: '{description}',\n                    /**\n                     * xAxis description for series if there are multiple xAxes in\n                     * the chart.\n                     *\n                     * @since 6.0.6\n                     */\n                    xAxisDescription: 'X axis, {name}',\n                    /**\n                     * yAxis description for series if there are multiple yAxes in\n                     * the chart.\n                     *\n                     * @since 6.0.6\n                     */\n                    yAxisDescription: 'Y axis, {name}',\n                    /**\n                     * Description for the value of null points.\n                     *\n                     * @since 8.0.0\n                     */\n                    nullPointValue: 'No value',\n                    /**\n                     * Description for annotations on a point, as it is made available\n                     * to assistive technology.\n                     *\n                     * @since 8.0.1\n                     */\n                    pointAnnotationsDescription: '{#each annotations}' +\n                        'Annotation: {this}{/each}'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return langOptions;\n    });\n    _registerModule(_modules, 'Accessibility/Options/DeprecatedOptions.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Default options for accessibility.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* eslint-disable max-len */\n        /*\n         *  List of deprecated options:\n         *\n         *  chart.description -> accessibility.description\n         *  chart.typeDescription -> accessibility.typeDescription\n         *  series.description -> series.accessibility.description\n         *  series.exposeElementToA11y -> series.accessibility.exposeAsGroupOnly\n         *  series.pointDescriptionFormatter ->\n         *      series.accessibility.pointDescriptionFormatter\n         *  series.accessibility.pointDescriptionFormatter ->\n         *      series.accessibility.point.descriptionFormatter\n         *  series.skipKeyboardNavigation ->\n         *      series.accessibility.keyboardNavigation.enabled\n         *  point.description -> point.accessibility.description !!!! WARNING: No longer deprecated and handled, removed for HC8.\n         *  axis.description -> axis.accessibility.description\n         *\n         *  accessibility.pointDateFormat -> accessibility.point.dateFormat\n         *  accessibility.addTableShortcut -> Handled by screenReaderSection.beforeChartFormat\n         *  accessibility.pointDateFormatter -> accessibility.point.dateFormatter\n         *  accessibility.pointDescriptionFormatter -> accessibility.point.descriptionFormatter\n         *  accessibility.pointDescriptionThreshold -> accessibility.series.pointDescriptionEnabledThreshold\n         *  accessibility.pointNavigationThreshold -> accessibility.keyboardNavigation.seriesNavigation.pointNavigationEnabledThreshold\n         *  accessibility.pointValueDecimals -> accessibility.point.valueDecimals\n         *  accessibility.pointValuePrefix -> accessibility.point.valuePrefix\n         *  accessibility.pointValueSuffix -> accessibility.point.valueSuffix\n         *  accessibility.screenReaderSectionFormatter -> accessibility.screenReaderSection.beforeChartFormatter\n         *  accessibility.describeSingleSeries -> accessibility.series.describeSingleSeries\n         *  accessibility.seriesDescriptionFormatter -> accessibility.series.descriptionFormatter\n         *  accessibility.onTableAnchorClick -> accessibility.screenReaderSection.onViewDataTableClick\n         *  accessibility.axisRangeDateFormat -> accessibility.screenReaderSection.axisRangeDateFormat\n         *  accessibility.keyboardNavigation.skipNullPoints -> accessibility.keyboardNavigation.seriesNavigation.skipNullPoints\n         *  accessibility.keyboardNavigation.mode -> accessibility.keyboardNavigation.seriesNavigation.mode\n         *\n         *  lang.accessibility.chartHeading -> no longer used, remove\n         *  lang.accessibility.legendItem -> lang.accessibility.legend.legendItem\n         *  lang.accessibility.legendLabel -> lang.accessibility.legend.legendLabel\n         *  lang.accessibility.mapZoomIn -> lang.accessibility.zoom.mapZoomIn\n         *  lang.accessibility.mapZoomOut -> lang.accessibility.zoom.mapZoomOut\n         *  lang.accessibility.resetZoomButton -> lang.accessibility.zoom.resetZoomButton\n         *  lang.accessibility.screenReaderRegionLabel -> lang.accessibility.screenReaderSection.beforeRegionLabel\n         *  lang.accessibility.rangeSelectorButton -> lang.accessibility.rangeSelector.buttonText\n         *  lang.accessibility.rangeSelectorMaxInput -> lang.accessibility.rangeSelector.maxInputLabel\n         *  lang.accessibility.rangeSelectorMinInput -> lang.accessibility.rangeSelector.minInputLabel\n         *  lang.accessibility.svgContainerEnd -> lang.accessibility.screenReaderSection.endOfChartMarker\n         *  lang.accessibility.viewAsDataTable -> lang.accessibility.table.viewAsDataTableButtonText\n         *  lang.accessibility.tableSummary -> lang.accessibility.table.tableSummary\n         *\n         */\n        /* eslint-enable max-len */\n        const { error, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Set a new option on a root prop, where the option is defined as an array of\n         * suboptions.\n         * @private\n         * @param root\n         * @param {Array<string>} optionAsArray\n         * @param {*} val\n         * @return {void}\n         */\n        function traverseSetOption(root, optionAsArray, val) {\n            let opt = root, prop, i = 0;\n            for (; i < optionAsArray.length - 1; ++i) {\n                prop = optionAsArray[i];\n                opt = opt[prop] = pick(opt[prop], {});\n            }\n            opt[optionAsArray[optionAsArray.length - 1]] = val;\n        }\n        /**\n         * If we have a clear root option node for old and new options and a mapping\n         * between, we can use this generic function for the copy and warn logic.\n         */\n        function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {\n            /**\n             * @private\n             */\n            function getChildProp(root, propAsArray) {\n                return propAsArray.reduce(function (acc, cur) {\n                    return acc[cur];\n                }, root);\n            }\n            const rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);\n            Object.keys(mapToNewOptions).forEach(function (oldOptionKey) {\n                const val = rootOld[oldOptionKey];\n                if (typeof val !== 'undefined') {\n                    traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);\n                    error(32, false, chart, {\n                        [rootOldAsArray.join('.') + '.' + oldOptionKey]: (rootNewAsArray.join('.') + '.' +\n                            mapToNewOptions[oldOptionKey].join('.'))\n                    });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedChartOptions(chart) {\n            const chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};\n            ['description', 'typeDescription'].forEach(function (prop) {\n                if (chartOptions[prop]) {\n                    a11yOptions[prop] = chartOptions[prop];\n                    error(32, false, chart, { [`chart.${prop}`]: `use accessibility.${prop}` });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedAxisOptions(chart) {\n            chart.axes.forEach(function (axis) {\n                const opts = axis.options;\n                if (opts && opts.description) {\n                    opts.accessibility = opts.accessibility || {};\n                    opts.accessibility.description = opts.description;\n                    error(32, false, chart, {\n                        'axis.description': 'use axis.accessibility.description'\n                    });\n                }\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedSeriesOptions(chart) {\n            // Map of deprecated series options. New options are defined as\n            // arrays of paths under series.options.\n            const oldToNewSeriesOptions = {\n                description: ['accessibility', 'description'],\n                exposeElementToA11y: ['accessibility', 'exposeAsGroupOnly'],\n                pointDescriptionFormatter: [\n                    'accessibility', 'point', 'descriptionFormatter'\n                ],\n                skipKeyboardNavigation: [\n                    'accessibility', 'keyboardNavigation', 'enabled'\n                ],\n                'accessibility.pointDescriptionFormatter': [\n                    'accessibility', 'point', 'descriptionFormatter'\n                ]\n            };\n            chart.series.forEach(function (series) {\n                // Handle series wide options\n                Object.keys(oldToNewSeriesOptions).forEach(function (oldOption) {\n                    let optionVal = series.options[oldOption];\n                    // Special case\n                    if (oldOption === 'accessibility.pointDescriptionFormatter') {\n                        optionVal = (series.options.accessibility &&\n                            series.options.accessibility\n                                .pointDescriptionFormatter);\n                    }\n                    if (typeof optionVal !== 'undefined') {\n                        // Set the new option\n                        traverseSetOption(series.options, oldToNewSeriesOptions[oldOption], \n                        // Note that skipKeyboardNavigation has inverted option\n                        // value, since we set enabled rather than disabled\n                        oldOption === 'skipKeyboardNavigation' ?\n                            !optionVal : optionVal);\n                        error(32, false, chart, {\n                            [`series.${oldOption}`]: ('series.' +\n                                oldToNewSeriesOptions[oldOption].join('.'))\n                        });\n                    }\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedTopLevelAccessibilityOptions(chart) {\n            deprecateFromOptionsMap(chart, ['accessibility'], ['accessibility'], {\n                pointDateFormat: ['point', 'dateFormat'],\n                pointDateFormatter: ['point', 'dateFormatter'],\n                pointDescriptionFormatter: ['point', 'descriptionFormatter'],\n                pointDescriptionThreshold: ['series',\n                    'pointDescriptionEnabledThreshold'],\n                pointNavigationThreshold: ['keyboardNavigation', 'seriesNavigation',\n                    'pointNavigationEnabledThreshold'],\n                pointValueDecimals: ['point', 'valueDecimals'],\n                pointValuePrefix: ['point', 'valuePrefix'],\n                pointValueSuffix: ['point', 'valueSuffix'],\n                screenReaderSectionFormatter: ['screenReaderSection',\n                    'beforeChartFormatter'],\n                describeSingleSeries: ['series', 'describeSingleSeries'],\n                seriesDescriptionFormatter: ['series', 'descriptionFormatter'],\n                onTableAnchorClick: ['screenReaderSection', 'onViewDataTableClick'],\n                axisRangeDateFormat: ['screenReaderSection', 'axisRangeDateFormat']\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedKeyboardNavigationOptions(chart) {\n            deprecateFromOptionsMap(chart, ['accessibility', 'keyboardNavigation'], ['accessibility', 'keyboardNavigation', 'seriesNavigation'], {\n                skipNullPoints: ['skipNullPoints'],\n                mode: ['mode']\n            });\n        }\n        /**\n         * @private\n         */\n        function copyDeprecatedLangOptions(chart) {\n            deprecateFromOptionsMap(chart, ['lang', 'accessibility'], ['lang', 'accessibility'], {\n                legendItem: ['legend', 'legendItem'],\n                legendLabel: ['legend', 'legendLabel'],\n                mapZoomIn: ['zoom', 'mapZoomIn'],\n                mapZoomOut: ['zoom', 'mapZoomOut'],\n                resetZoomButton: ['zoom', 'resetZoomButton'],\n                screenReaderRegionLabel: ['screenReaderSection',\n                    'beforeRegionLabel'],\n                rangeSelectorButton: ['rangeSelector', 'buttonText'],\n                rangeSelectorMaxInput: ['rangeSelector', 'maxInputLabel'],\n                rangeSelectorMinInput: ['rangeSelector', 'minInputLabel'],\n                svgContainerEnd: ['screenReaderSection', 'endOfChartMarker'],\n                viewAsDataTable: ['table', 'viewAsDataTableButtonText'],\n                tableSummary: ['table', 'tableSummary']\n            });\n        }\n        /**\n         * Copy options that are deprecated over to new options. Logs warnings to\n         * console if deprecated options are used.\n         *\n         * @private\n         */\n        function copyDeprecatedOptions(chart) {\n            copyDeprecatedChartOptions(chart);\n            copyDeprecatedAxisOptions(chart);\n            if (chart.series) {\n                copyDeprecatedSeriesOptions(chart);\n            }\n            copyDeprecatedTopLevelAccessibilityOptions(chart);\n            copyDeprecatedKeyboardNavigationOptions(chart);\n            copyDeprecatedLangOptions(chart);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return copyDeprecatedOptions;\n    });\n    _registerModule(_modules, 'Accessibility/Accessibility.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/A11yI18n.js'], _modules['Accessibility/Components/ContainerComponent.js'], _modules['Accessibility/FocusBorder.js'], _modules['Accessibility/Components/InfoRegionsComponent.js'], _modules['Accessibility/KeyboardNavigation.js'], _modules['Accessibility/Components/LegendComponent.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/ProxyProvider.js'], _modules['Accessibility/Components/RangeSelectorComponent.js'], _modules['Accessibility/Components/SeriesComponent/SeriesComponent.js'], _modules['Accessibility/Components/ZoomComponent.js'], _modules['Accessibility/HighContrastMode.js'], _modules['Accessibility/HighContrastTheme.js'], _modules['Accessibility/Options/A11yDefaults.js'], _modules['Accessibility/Options/LangDefaults.js'], _modules['Accessibility/Options/DeprecatedOptions.js']], function (D, H, U, HU, A11yI18n, ContainerComponent, FocusBorder, InfoRegionsComponent, KeyboardNavigation, LegendComponent, MenuComponent, NewDataAnnouncer, ProxyProvider, RangeSelectorComponent, SeriesComponent, ZoomComponent, whcm, highContrastTheme, defaultOptionsA11Y, defaultLangOptions, copyDeprecatedOptions) {\n        /* *\n         *\n         *  (c) 2009-2021 Øystein Moseng\n         *\n         *  Accessibility module for Highcharts\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { doc } = H;\n        const { addEvent, extend, fireEvent, merge } = U;\n        const { removeElement } = HU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Accessibility class\n         *\n         * @private\n         * @requires module:modules/accessibility\n         *\n         * @class\n         * @name Highcharts.Accessibility\n         *\n         * @param {Highcharts.Chart} chart\n         * Chart object\n         */\n        class Accessibility {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.components = void 0;\n                this.keyboardNavigation = void 0;\n                this.proxyProvider = void 0;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Initialize the accessibility class\n             * @private\n             * @param {Highcharts.Chart} chart\n             *        Chart object\n             */\n            init(chart) {\n                this.chart = chart;\n                // Abort on old browsers\n                if (!doc.addEventListener) {\n                    this.zombie = true;\n                    this.components = {};\n                    chart.renderTo.setAttribute('aria-hidden', true);\n                    return;\n                }\n                // Copy over any deprecated options that are used. We could do this on\n                // every update, but it is probably not needed.\n                copyDeprecatedOptions(chart);\n                this.proxyProvider = new ProxyProvider(this.chart);\n                this.initComponents();\n                this.keyboardNavigation = new KeyboardNavigation(chart, this.components);\n            }\n            /**\n             * @private\n             */\n            initComponents() {\n                const chart = this.chart;\n                const proxyProvider = this.proxyProvider;\n                const a11yOptions = chart.options.accessibility;\n                this.components = {\n                    container: new ContainerComponent(),\n                    infoRegions: new InfoRegionsComponent(),\n                    legend: new LegendComponent(),\n                    chartMenu: new MenuComponent(),\n                    rangeSelector: new RangeSelectorComponent(),\n                    series: new SeriesComponent(),\n                    zoom: new ZoomComponent()\n                };\n                if (a11yOptions.customComponents) {\n                    extend(this.components, a11yOptions.customComponents);\n                }\n                const components = this.components;\n                this.getComponentOrder().forEach(function (componentName) {\n                    components[componentName].initBase(chart, proxyProvider);\n                    components[componentName].init();\n                });\n            }\n            /**\n             * Get order to update components in.\n             * @private\n             */\n            getComponentOrder() {\n                if (!this.components) {\n                    return []; // For zombie accessibility object on old browsers\n                }\n                if (!this.components.series) {\n                    return Object.keys(this.components);\n                }\n                const componentsExceptSeries = Object.keys(this.components)\n                    .filter((c) => c !== 'series');\n                // Update series first, so that other components can read accessibility\n                // info on points.\n                return ['series'].concat(componentsExceptSeries);\n            }\n            /**\n             * Update all components.\n             */\n            update() {\n                const components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;\n                fireEvent(chart, 'beforeA11yUpdate');\n                // Update the chart type list as this is used by multiple modules\n                chart.types = this.getChartTypes();\n                // Update proxies. We don't update proxy positions since most likely we\n                // need to recreate the proxies on update.\n                const kbdNavOrder = a11yOptions.keyboardNavigation.order;\n                this.proxyProvider.updateGroupOrder(kbdNavOrder);\n                // Update markup\n                this.getComponentOrder().forEach(function (componentName) {\n                    components[componentName].onChartUpdate();\n                    fireEvent(chart, 'afterA11yComponentUpdate', {\n                        name: componentName,\n                        component: components[componentName]\n                    });\n                });\n                // Update keyboard navigation\n                this.keyboardNavigation.update(kbdNavOrder);\n                // Handle high contrast mode\n                if (!chart.highContrastModeActive && // Only do this once\n                    whcm.isHighContrastModeActive()) {\n                    whcm.setHighContrastTheme(chart);\n                }\n                fireEvent(chart, 'afterA11yUpdate', {\n                    accessibility: this\n                });\n            }\n            /**\n             * Destroy all elements.\n             */\n            destroy() {\n                const chart = this.chart || {};\n                // Destroy components\n                const components = this.components;\n                Object.keys(components).forEach(function (componentName) {\n                    components[componentName].destroy();\n                    components[componentName].destroyBase();\n                });\n                // Destroy proxy provider\n                if (this.proxyProvider) {\n                    this.proxyProvider.destroy();\n                }\n                // Remove announcer container\n                if (chart.announcerContainer) {\n                    removeElement(chart.announcerContainer);\n                }\n                // Kill keyboard nav\n                if (this.keyboardNavigation) {\n                    this.keyboardNavigation.destroy();\n                }\n                // Hide container from screen readers if it exists\n                if (chart.renderTo) {\n                    chart.renderTo.setAttribute('aria-hidden', true);\n                }\n                // Remove focus border if it exists\n                if (chart.focusElement) {\n                    chart.focusElement.removeFocusBorder();\n                }\n            }\n            /**\n             * Return a list of the types of series we have in the chart.\n             * @private\n             */\n            getChartTypes() {\n                const types = {};\n                this.chart.series.forEach(function (series) {\n                    types[series.type] = 1;\n                });\n                return Object.keys(types);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (Accessibility) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            Accessibility.i18nFormat = A11yI18n.i18nFormat;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Destroy with chart.\n             * @private\n             */\n            function chartOnDestroy() {\n                if (this.accessibility) {\n                    this.accessibility.destroy();\n                }\n            }\n            /**\n             * Handle updates to the module and send render updates to components.\n             * @private\n             */\n            function chartOnRender() {\n                // Update/destroy\n                if (this.a11yDirty && this.renderTo) {\n                    delete this.a11yDirty;\n                    this.updateA11yEnabled();\n                }\n                const a11y = this.accessibility;\n                if (a11y && !a11y.zombie) {\n                    a11y.proxyProvider.updateProxyElementPositions();\n                    a11y.getComponentOrder().forEach(function (componentName) {\n                        a11y.components[componentName].onChartRender();\n                    });\n                }\n            }\n            /**\n             * Update with chart/series/point updates.\n             * @private\n             */\n            function chartOnUpdate(e) {\n                // Merge new options\n                const newOptions = e.options.accessibility;\n                if (newOptions) {\n                    // Handle custom component updating specifically\n                    if (newOptions.customComponents) {\n                        this.options.accessibility.customComponents =\n                            newOptions.customComponents;\n                        delete newOptions.customComponents;\n                    }\n                    merge(true, this.options.accessibility, newOptions);\n                    // Recreate from scratch\n                    if (this.accessibility && this.accessibility.destroy) {\n                        this.accessibility.destroy();\n                        delete this.accessibility;\n                    }\n                }\n                // Mark dirty for update\n                this.a11yDirty = true;\n            }\n            /**\n             * @private\n             */\n            function chartUpdateA11yEnabled() {\n                let a11y = this.accessibility;\n                const accessibilityOptions = this.options.accessibility;\n                if (accessibilityOptions && accessibilityOptions.enabled) {\n                    if (a11y && !a11y.zombie) {\n                        a11y.update();\n                    }\n                    else {\n                        this.accessibility = a11y = new Accessibility(this);\n                        if (a11y && !a11y.zombie) {\n                            a11y.update();\n                        }\n                    }\n                }\n                else if (a11y) {\n                    // Destroy if after update we have a11y and it is disabled\n                    if (a11y.destroy) {\n                        a11y.destroy();\n                    }\n                    delete this.accessibility;\n                }\n                else {\n                    // Just hide container\n                    this.renderTo.setAttribute('aria-hidden', true);\n                }\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, LegendClass, PointClass, SeriesClass, SVGElementClass, RangeSelectorClass) {\n                // ordered:\n                KeyboardNavigation.compose(ChartClass);\n                NewDataAnnouncer.compose(SeriesClass);\n                LegendComponent.compose(ChartClass, LegendClass);\n                MenuComponent.compose(ChartClass);\n                SeriesComponent.compose(ChartClass, PointClass, SeriesClass);\n                // RangeSelector\n                A11yI18n.compose(ChartClass);\n                FocusBorder.compose(ChartClass, SVGElementClass);\n                if (RangeSelectorClass) {\n                    RangeSelectorComponent.compose(ChartClass, RangeSelectorClass);\n                }\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    const chartProto = ChartClass.prototype;\n                    chartProto.updateA11yEnabled = chartUpdateA11yEnabled;\n                    addEvent(ChartClass, 'destroy', chartOnDestroy);\n                    addEvent(ChartClass, 'render', chartOnRender);\n                    addEvent(ChartClass, 'update', chartOnUpdate);\n                    // Mark dirty for update\n                    ['addSeries', 'init'].forEach((event) => {\n                        addEvent(ChartClass, event, function () {\n                            this.a11yDirty = true;\n                        });\n                    });\n                    // Direct updates (events happen after render)\n                    ['afterApplyDrilldown', 'drillupall'].forEach((event) => {\n                        addEvent(ChartClass, event, function chartOnAfterDrilldown() {\n                            const a11y = this.accessibility;\n                            if (a11y && !a11y.zombie) {\n                                a11y.update();\n                            }\n                        });\n                    });\n                }\n                if (U.pushUnique(composedMembers, PointClass)) {\n                    addEvent(PointClass, 'update', pointOnUpdate);\n                }\n                if (U.pushUnique(composedMembers, SeriesClass)) {\n                    // Mark dirty for update\n                    ['update', 'updatedData', 'remove'].forEach((event) => {\n                        addEvent(SeriesClass, event, function () {\n                            if (this.chart.accessibility) {\n                                this.chart.a11yDirty = true;\n                            }\n                        });\n                    });\n                }\n            }\n            Accessibility.compose = compose;\n            /**\n             * Mark dirty for update.\n             * @private\n             */\n            function pointOnUpdate() {\n                if (this.series.chart.accessibility) {\n                    this.series.chart.a11yDirty = true;\n                }\n            }\n        })(Accessibility || (Accessibility = {}));\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // Add default options\n        merge(true, defaultOptions, defaultOptionsA11Y, {\n            accessibility: {\n                highContrastTheme: highContrastTheme\n            },\n            lang: defaultLangOptions\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Accessibility;\n    });\n    _registerModule(_modules, 'masters/modules/accessibility.src.js', [_modules['Core/Globals.js'], _modules['Accessibility/Accessibility.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function (Highcharts, Accessibility, AccessibilityComponent, ChartUtilities, HTMLUtilities, KeyboardNavigationHandler, SeriesDescriber) {\n\n        const G = Highcharts;\n        G.i18nFormat = Accessibility.i18nFormat;\n        G.A11yChartUtilities = ChartUtilities;\n        G.A11yHTMLUtilities = HTMLUtilities;\n        G.AccessibilityComponent = AccessibilityComponent;\n        G.KeyboardNavigationHandler = KeyboardNavigationHandler;\n        G.SeriesAccessibilityDescriber = SeriesDescriber;\n        Accessibility.compose(G.Chart, G.Legend, G.Point, G.Series, G.SVGElement, G.RangeSelector);\n\n    });\n}));"],
  "mappings": "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",
  "names": ["factory", "module", "exports", "define", "amd", "Highcharts", "undefined", "_registerModule", "obj", "path", "args", "fn", "hasOwnProperty", "apply", "CustomEvent", "window", "dispatchEvent", "detail", "_modules", "H", "U", "cloneMouseEvent", "e", "win", "MouseEvent", "type", "doc", "createEvent", "evt", "initMouseEvent", "bubbles", "cancelable", "view", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget", "getFakeMouseEvent", "position", "pos", "x", "y", "composed", "buttons", "simulatedEventTarget", "css", "EventTarget", "HTMLUtilities", "addClass", "el", "className", "classList", "add", "indexOf", "cloneTouchEvent", "touchListToTouchArray", "l", "touchArray", "i", "length", "item", "push", "TouchEvent", "newEvent", "touches", "targetTouches", "changedTouches", "defaultPrevented", "preventDefault", "fakeEvt", "escapeStringForHTML", "str", "replace", "getElement", "id", "getElementById", "getHeadingTagNameForElement", "element", "getIncreasedHeadingLevel", "tagName", "headingLevel", "parseInt", "slice", "Math", "min", "newLevel", "getHeadingRecursive", "sibling", "previousSibling", "test", "prevSiblingsHeading", "parent", "parentElement", "parentTagName", "removeChildNodes", "lastChild", "removeChild", "removeClass", "remove", "RegExp", "removeElement", "parentNode", "reverseChildNodes", "node", "childNodes", "appendChild", "stripHTMLTagsFromString", "visuallyHideElement", "width", "height", "overflow", "whiteSpace", "clip", "marginTop", "filter", "opacity", "F", "format", "getNestedProperty", "pick", "A11yI18nComposition", "formatExtendedStatement", "statement", "ctx", "eachStart", "pluralStart", "indexStart", "indexEnd", "eachEnd", "preEach", "substring", "postEach", "eachArguments", "eachStatement", "split", "lenArg", "Number", "result", "arr", "isNaN", "len", "pluralEnd", "pluralArguments", "pluralStatement", "num", "trim", "arrayName", "ix", "val", "i18nFormat", "formatString", "context", "chart", "getFirstBracketStatement", "sourceStr", "offset", "startBracket", "endBracket", "begin", "end", "tokens", "bracketRes", "constRes", "cursor", "value", "forEach", "token", "reduce", "acc", "cur", "langFormat", "langKey", "keys", "options", "lang", "composedMembers", "compose", "ChartClass", "pushUnique", "prototype", "HU", "fireEventOnWrappedOrUnwrappedElement", "eventObject", "hcEvents", "fireEvent", "getAxisTimeLengthDesc", "axis", "range", "rangeUnit", "Seconds", "dataMax", "max", "dataMin", "Minutes", "Hours", "Days", "unit", "rangeValue", "toFixed", "getAxisFromToDescription", "dateRangeFormat", "accessibility", "screenReaderSection", "axisRangeDateFormat", "extremes", "key", "dateTime", "time", "dateFormat", "toString", "rangeFrom", "rangeTo", "getSeriesFirstPointElement", "series", "points", "firstPointWithGraphic", "find", "p", "graphic", "getSeriesA11yElement", "firstPointEl", "graph", "group", "unhideChartElementFromAT", "setAttribute", "renderTo", "body", "Array", "call", "hasAttribute", "stripHTMLTags", "defined", "ChartUtilities", "getChartTitle", "title", "text", "getAxisDescription", "_a", "_b", "description", "axisTitle", "textStr", "categories", "getAxisRangeDescription", "axisOptions", "rangeDescription", "a", "numCategories", "getPointFromXY", "res", "getSeriesFromName", "name", "s", "hideSeriesFromAT", "seriesEl", "scrollToPoint", "point", "xAxis", "yAxis", "scrollbar", "to", "from", "axisStart", "toPixels", "axisEnd", "c", "coll", "pointPos", "updatePosition", "trigger", "DOMEvent", "DOMElementProvider", "elements", "createElement", "arguments", "addEvent", "EventProvider", "eventRemovers", "remover", "CU", "extend", "AccessibilityComponent", "proxyProvider", "keyCodes", "eventProvider", "domElementProvider", "left", "right", "up", "down", "enter", "space", "esc", "tab", "pageUp", "pageDown", "home", "fakeEvent", "destroyCreatedElements", "removeAddedEvents", "init", "getKeyboardNavigation", "onChartUpdate", "onChartRender", "destroy", "KeyboardNavigationHandler", "keyCodeMap", "validate", "terminate", "response", "success", "prev", "next", "noHandler", "fail", "keyCode", "which", "handlerCodeSet", "codeSet", "ContainerComponent", "handleSVGTitleElement", "setSVGContainerLabel", "setGraphicContainerAttrs", "setRenderToAttrs", "makeCreditsAccessible", "titleId", "index", "titleContents", "chartTitle", "titleElement", "svgTitleElement", "createElementNS", "textContent", "insertBefore", "firstChild", "svgContainerLabel", "renderer", "box", "label", "container", "shouldHaveLandmark", "landmarkVerbosity", "containerLabel", "credits", "creditsStr", "a11y", "keyboardNavigation", "tabindexContainer", "focus", "SVGLabel", "FocusBorderComposition", "chartRenderFocusBorder", "focusElement", "focusBorderOptions", "focusBorder", "removeFocusBorder", "enabled", "addFocusBorder", "margin", "stroke", "style", "color", "strokeWidth", "lineWidth", "r", "borderRadius", "chartSetFocusToElement", "svgElement", "browserFocusElement", "focusin", "hideBrowserFocusOutline", "outline", "renderFocusBorder", "svgElementAddDestroyFocusBorderHook", "focusBorderDestroyHook", "origDestroy", "el.destroy", "svgElementAddFocusBorder", "attribs", "bb", "getBBox", "pad", "parentGroup", "scaleX", "scaleY", "scaleBoth", "abs", "translateX", "translateY", "borderPosX", "borderPosY", "borderWidth", "borderHeight", "isLabel", "nodeName", "isRotated", "rotation", "posYCorrection", "posXCorrection", "attr", "attrX", "attrY", "correction", "temp", "rect", "zIndex", "styledMode", "avgElementAddUpdateFocusBorderHooks", "updateParams", "focusBorderUpdateHooks", "svgElementBorderUpdateTriggers", "origSetter", "setterKey", "_defaultSetter", "ret", "svgElementRemoveFocusBorder", "svgElementRemoveUpdateFocusBorderHooks", "Object", "SVGElementClass", "chartProto", "setFocusToElement", "svgElementProto", "AST", "Announcer", "announceRegion", "addAnnounceRegion", "message", "setElementHTML", "clearAnnouncementRegionTimer", "clearTimeout", "setTimeout", "innerHTML", "emptyHTML", "chartContainer", "announcerContainer", "createAnnouncerContainer", "div", "getChartAnnotationLabels", "annotations", "visible", "concat", "labels", "getLabelText", "getAnnotationLabelDescription", "a11yDesc", "labelText", "pointValueDescriptions", "map", "valDesc", "valueDescription", "getAttribute", "seriesName", "desc", "numPoints", "langFormatStr", "annotationText", "annotation", "annotationPoint", "additionalAnnotationPoints", "getAnnotationListItems", "AnnotationsA11y", "getAnnotationsInfoHTML", "annotationItems", "join", "getPointAnnotationTexts", "pointLabels", "A11yI18n", "getTypeDescription", "types", "firstType", "firstSeries", "formatContext", "numSeries", "mapTitle", "mapView", "geoMap", "typeExplaination", "multi", "InfoRegionsComponent", "announcer", "screenReaderSections", "component", "initRegionsDefinitions", "onDataTableCreated", "wasHidden", "dataTableDiv", "focusDataTable", "before", "buildContent", "formatter", "beforeChartFormatter", "defaultBeforeChartFormatter", "insertIntoDOM", "afterInserted", "sonifyButtonId", "initSonifyButton", "dataTableButtonId", "initDataTableButton", "after", "afterChartFormatter", "defaultAfterChartFormatter", "nextSibling", "updateExitAnchor", "linkedDescriptionElement", "getLinkedDescriptionElement", "setLinkedDescriptionAttrs", "regionKey", "updateScreenReaderSection", "linkedDescOption", "linkedDescription", "query", "queryMatch", "querySelectorAll", "region", "content", "sectionDiv", "hiddenDiv", "setScreenReaderSectionAttribs", "sectionId", "beforeChartFormat", "axesDesc", "getAxesDescription", "shouldHaveSonifyBtn", "sonify", "sonification", "annotationsList", "annotationsTitleStr", "headingTagName", "typeDescription", "getTypeDescriptionText", "chartSubtitle", "getSubtitleText", "chartLongdesc", "getLongdescText", "xAxisDescription", "yAxisDescription", "playAsSoundButton", "getSonifyButtonText", "viewTableButton", "getCSV", "getDataTableButtonText", "annotationsTitle", "formattedString", "afterChartFormat", "endOfChartMarker", "getEndOfChartMarkerText", "chartOptions", "captionOptions", "caption", "captionText", "getLinkedDescription", "buttonId", "buttonText", "subtitle", "markerText", "viewDataTableButton", "attributes", "tree", "tabindex", "summary", "tableDiv", "table", "getElementsByTagName", "sonifyButton", "defaultHandler", "stopPropagation", "announceMsg", "announce", "removeAttribute", "onclick", "el.onclick", "onPlayAsSoundClick", "tableButtonId", "tableId", "onViewDataTableClick", "viewData", "shouldDescribeColl", "collectionKey", "defaultCondition", "axes", "hasNoMap", "hasCartesian", "hasCartesianSeries", "showXAxes", "angular", "showYAxes", "getAxisDescriptionText", "names", "ranges", "numAxes", "Chart", "MenuComponent", "onMenuShown", "onMenuHidden", "createProxyGroup", "menu", "exportContextMenu", "setExportButtonExpandedState", "addAccessibleContextMenuAttribs", "stateStr", "exportButtonProxy", "buttonElement", "focusEl", "clearGroup", "proxyMenuButton", "exportingGroup", "buttonEl", "exportSVGElements", "exportingOpts", "exporting", "exportButton", "addProxyElement", "click", "contextButtonTitle", "addGroup", "exportList", "exportDivElements", "children", "parentDiv", "role", "onKbdPrevious", "onKbdNext", "onKbdClick", "proxy", "svgEl", "hideExportMenu", "keyboardNavigationHandler", "a11yOptions", "highlightedExportItemIx", "highlightExportItem", "wrapAround", "highlightLastExportItem", "curHighlightedItem", "exportButtonElement", "openMenu", "fakeClickEvent", "chartShowExportMenu", "chartHideExportMenu", "onmouseout", "hideMenu", "chartHighlightExportItem", "listItem", "curHighlighted", "hasSVGFocusSupport", "onmouseover", "chartHighlightLastExportItem", "showExportMenu", "KeyboardNavigation", "components", "currentModuleIx", "NaN", "exitAnchor", "modules", "ep", "update", "onKeydown", "onFocus", "eventName", "onMouseUp", "isClickingChart", "order", "keyboardOptions", "updateContainerTabindex", "componentName", "navModules", "removeExitAnchor", "endMarker", "endMarkerId", "makeElementAnExitAnchor", "createExitAnchor", "direction", "curModule", "newModule", "move", "exiting", "focusComesFromChart", "contains", "tabbingInBackwards", "getFirstValidModuleIx", "keyboardReset", "target", "curMod", "ev", "event", "curNavModule", "run", "shouldHaveTabindex", "curTabindex", "chartTabindex", "addExitAnchorEventsToEl", "comingInBackwards", "mod", "chartDismissPopupContent", "tooltip", "hide", "documentOnKeydown", "charts", "dismissPopupContent", "A", "Legend", "shouldDoLegendA11y", "items", "legend", "allItems", "legendA11yOptions", "unsupportedColorAxis", "colorAxis", "some", "dataClasses", "setLegendItemHoverState", "hoverActive", "legendItem", "setState", "animObject", "isNumber", "syncTimeout", "LegendComponent", "highlightedLegendItemIx", "proxyGroup", "recreateProxies", "updateGroupProxyElementPositions", "updateLegendItemProxyVisibility", "highlightLegendItem", "updateProxyPositionForItem", "globalAnimation", "duration", "curPage", "currentPage", "clipHeight", "a11yProxyElement", "hasPages", "pages", "proxyEl", "itemPage", "pageIx", "h", "round", "visibility", "removeProxies", "newPageIx", "refreshPosition", "focusedElement", "activeElement", "shouldRestoreFocus", "addLegendProxyGroup", "proxyLegendItems", "updateLegendTitle", "removeGroup", "legendTitle", "legendLabel", "updateGroupAttrs", "proxyLegendItem", "itemLabel", "itemName", "visual", "onKbdArrowKey", "highlightAdjacentLegendPage", "shouldHaveLegendNavigation", "numItems", "display", "chartHighlightLegendItem", "oldIx", "itemToHighlight", "scroll", "legendItemProp", "proxyBtn", "legendOnAfterColorizeItem", "LegendClass", "findFirstPointWithGraphic", "sourcePointIndex", "data", "hasMorePointsThanDescriptionThreshold", "threshold", "pointDescriptionEnabledThreshold", "shouldSetScreenReaderPropsOnPoints", "seriesA11yOptions", "exposeAsGroupOnly", "shouldSetKeyboardNavPropsOnPoints", "seriesNavOptions", "seriesNavigation", "pointNavigationEnabledThreshold", "pointNumberToString", "a11yPointOptions", "seriesA11yPointOptions", "tooltipOptions", "numberFormat", "valueDecimals", "decimalPoint", "thousandsSep", "getSeriesDescriptionText", "descOpt", "getSeriesAxisDescriptionText", "axisCollection", "getPointArrayMapValueDescription", "prefix", "suffix", "pre", "suf", "pointArrayMap", "propDesc", "defaultPointDescriptionFormatter", "shouldExposeSeriesName", "pointValueDescriptionFormat", "valueDescriptionFormat", "showXDescription", "dateXAxis", "tooltipDateFormat", "getXDateFormat", "dateTimeLabelFormats", "dateFormatter", "t", "pointCategory", "category", "canUseId", "fallback", "timeDesc", "xDesc", "a11yPointOpts", "seriesA11yPointOpts", "valuePrefix", "valueSuffix", "fallbackDesc", "isNull", "f", "xDescription", "separator", "userDescText", "seriesNameText", "valText", "annotationsDesc", "describePointsInSeries", "setScreenReaderProps", "setKeyboardProps", "shouldDescribeNullPoints", "describeNull", "isSunburst", "is", "shouldDescribeNull", "firstGraphic", "mockPos", "plotX", "plotY", "mock", "fill", "mockElement", "hasMockGraphic", "pointA11yDisabled", "pointEl", "_c", "seriesPointA11yOptions", "isString", "descriptionFormat", "descriptionFormatter", "defaultSeriesDescriptionFormatter", "chartTypes", "shouldDescribeAxis", "seriesNumber", "xAxisInfo", "yAxisInfo", "summaryContext", "combinationSuffix", "axisDescription", "formatStr", "seriesDescription", "authorDescription", "SeriesDescriber", "describeSeries", "is3d", "hasMultipleSeries", "describeSingleSeriesOption", "describeSingleSeries", "exposeAsGroupOnlyOption", "b", "options3d", "findPointInDataArray", "candidates", "candidate", "getUniqueSeries", "arrayA", "arrayB", "uniqueSeries", "NewDataAnnouncer", "dirty", "allSeries", "lastAnnouncementTime", "announceType", "announceNewData", "interruptUser", "addEventListeners", "onSeriesAdded", "announceDirtyData", "hasDirty", "newSeries", "newPoint", "queueAnnouncement", "dirtySeries", "annOptions", "now", "Date", "minAnnounceInterval", "queuedAnnouncement", "buildAnnouncementMessage", "queuedAnnouncementTimer", "announcementFormatter", "formatterRes", "multiple", "seriesDesc", "pointDesc", "seriesOnAddPoint", "newDataAnnouncer", "seriesOnUpdatedData", "SeriesClass", "merge", "ProxyElement", "groupType", "isListItem", "wrapperEl", "btnEl", "hideButtonVisually", "listStyle", "updateTarget", "getTargetPosition", "fakeEventObject", "updateCSSClassName", "attrs", "getTargetAttr", "addProxyEventsToButton", "bBox", "top", "groupDiv", "noTooltipOnGroup", "noTooltipOnTarget", "evtType", "isTouchEvent", "clonedEvent", "passive", "backgroundColor", "padding", "clickTarget", "clickTargetElement", "posElement", "getBoundingClientRect", "rectEl", "chartPos", "pointer", "getChartPosition", "bottom", "ProxyProvider", "groups", "groupOrder", "beforeChartProxyPosContainer", "createProxyPosContainer", "afterChartProxyPosContainer", "groupKey", "Error", "proxyContainerElement", "proxyElements", "existingGroup", "groupElement", "proxyContainer", "updateGroupOrder", "groupKeys", "isDOMOrderGroupOrder", "seriesIx", "beforeKeys", "afterKeys", "posContainer", "updatePosContainerPositions", "updateProxyElementPositions", "bind", "classNamePostfix", "getGroupKeyFromElement", "allGroups", "getChildrenGroupOrder", "childrenOrder", "domOrder", "getCurrentGroupOrderInDOM", "groupOrderWithGroups", "forExport", "rendererSVGEl", "RangeSelectorDefaults", "rangeSelectorZoom", "rangeSelectorFrom", "rangeSelectorTo", "rangeSelector", "allButtonsEnabled", "buttonSpacing", "dropdown", "verticalAlign", "buttonTheme", "floating", "inputBoxBorderColor", "inputBoxHeight", "inputBoxWidth", "inputDateFormat", "inputDateParser", "inputEditDateFormat", "inputEnabled", "inputPosition", "align", "inputSpacing", "selected", "buttonPosition", "inputStyle", "fontSize", "labelStyle", "D", "axisMinFromRange", "rangeOptions", "getTrueRange", "base", "count", "timeName", "date", "basePeriod", "get", "set", "getTime", "fixedRange", "MIN_VALUE", "newMax", "MAX_VALUE", "_offsetMin", "onChartAfterGetContainer", "RangeSelectorConstructor", "onChartBeforeRender", "deferredYTDClick", "clickButton", "updateNames", "setScale", "getAxisMargins", "render", "extraBottomMargin", "extraTopMargin", "onChartCallback", "alignTo", "redraw", "getExtremes", "spacingBox", "layout", "plotTop", "getHeight", "placed", "chartDestroyEvents", "events", "onChartDestroy", "iEnd", "unbind", "splice", "onChartGetMargins", "rangeSelectorHeight", "marginBottom", "optionsRangeSelector", "extraBottomMarginWas", "extraTopMarginWas", "isDirtyBox", "defaultOptions", "setOptions", "RangeSelectorComposition", "AxisClass", "RangeSelectorClass", "minFromRange", "callbacks", "Axis", "SVGElement", "preferredInputType", "char", "destroyObjectProperties", "discardElement", "objectEach", "pInt", "splat", "RangeSelector", "buttonOptions", "defaultButtons", "initialButtonGroupWidth", "baseAxis", "unionExtremes", "scroller", "getUnionExtremes", "dataGrouping", "newMin", "baseXAxisOptions", "_range", "rangeMin", "minSetting", "rangeSetting", "addOffsetMin", "setSelected", "forcedDataGrouping", "setDataGrouping", "frozenStates", "preserveDataGrouping", "xData", "ytdExtremes", "getYTDExtremes", "useUTC", "navigator", "baseSeries", "_offsetMax", "selectedIndex", "setExtremes", "rangeSelectorButton", "resetMinAndRange", "selectedOption", "blurInputs", "minInput", "maxInput", "blur", "eventsToUnbind", "computeButtonRange", "actualRange", "hasNoData", "hasVisibleSeries", "ytdMin", "ytdMax", "selectedExists", "offsetRange", "isSelected", "isTooGreatRange", "isTooSmallRange", "minRange", "state", "isYTDButNotSelected", "isAllButAlreadyShowingAll", "isSameRange", "day", "month", "year", "disable", "select", "disabled", "fixedTimes", "millisecond", "second", "minute", "hour", "week", "offsetMin", "offsetMax", "input", "defaultInputDateParser", "inputTime", "dateBox", "minDateBox", "maxDateBox", "hcTimeAttr", "updatedTime", "previousTime", "inputTypeFormats", "inputGroup", "isTextInput", "border", "offsetWidth", "chartWidth", "offsetHeight", "inputDate", "isSafari", "d", "lastIndexOf", "getTimezoneOffset", "parse", "parts", "UTC", "updateExtremes", "chartAxis", "dataAxis", "getInputValue", "isMin", "chartStyle", "on", "showInput", "boxShadow", "textAlign", "fontFamily", "onfocus", "onblur", "hideInput", "setInputValue", "keyDown", "onchange", "onkeypress", "onkeydown", "onkeyup", "axisOffset", "buttonTop", "inputTop", "startOfYear", "ts", "inputsZIndex", "rendered", "g", "renderButtons", "minElems", "drawInput", "minLabel", "maxElems", "maxLabel", "setInputExtremes", "alignElements", "states", "buttonGroup", "isMS", "currentButtonIndex", "zoomText", "paddingLeft", "paddingRight", "buttonEvents", "callDefaultEvent", "isActive", "hover", "navButtonOptions", "navigation", "getXOffsetForExportButton", "titleCollision", "spacing", "plotLeft", "positionButtons", "updateButtonStates", "xOffsetForExportButton", "alignButtonGroup", "hasLoaded", "handleCollision", "alignTranslateY", "alignAttr", "groupHeight", "legendHeight", "legendOptions", "titleOffset", "translate", "floor", "verb", "buttonLeft", "maxButtonWidth", "buttonWidth", "groupsOverlap", "buttonGroupWidth", "inputGroupX", "alignOptions", "inputGroupWidth", "buttonGroupX", "moveInputsDown", "collapseButtons", "expandButtons", "plotWidth", "userButtonTheme", "userOptions", "getAttribs", "hasActiveButton", "show", "showDropdown", "hideDropdown", "hasVisibleDropdown", "rangeSelectorGroup", "yPosition", "buttonPositionY", "inputPositionY", "minPosition", "rSelector", "HTMLElement", "RangeSelectorComponent", "updateSelectorVisibility", "setDropdownAttrs", "setRangeButtonAttrs", "setRangeInputAttrs", "btn", "rangeTitle", "highlightRangeSelectorButton", "highlightedRangeSelectorItemIx", "didHighlight", "oldRangeSelectorItemState", "axisRangeDescription", "announcement", "rangeSel", "newIx", "highlightedInputRangeIx", "inputEl", "buttonIxToHighlight", "removeInputKeydownHandler", "keydownHandler", "onInputKbdMove", "minRemover", "maxRemover", "removeDropdownKeydownHandler", "onButtonNavKbdArrowKey", "onButtonNavKbdClick", "initDropdownNav", "lastButtonIx", "onInputNavInit", "onInputNavTerminate", "getRangeSelectorButtonNavigation", "getRangeSelectorInputNavigation", "chartHighlightRangeSelectorButton", "curHighlightedIx", "curSelectedIx", "rangeSelectorAfterBtnClick", "onAfterBtnClick", "ForcedMarkersComposition", "forceZeroOpacityMarkerOptions", "marker", "normal", "getPointMarkerOpacity", "pointOptions", "seriesOnAfterRender", "markerGroup", "a11yMarkersForced", "_hasPointMarkers", "hasForcedA11yMarker", "seriesOnAfterSetOptions", "resetA11yMarkerOptions", "seriesOnRender", "seriesA11yEnabled", "hadForcedMarker", "isStillForcedMarker", "resetMarkerOptions", "Point", "Series", "SeriesRegistry", "getPointIndex", "isSkipSeries", "seriesKbdNavOptions", "enableMouseTracking", "isSkipPoint", "skipNullPoints", "isInside", "getFirstValidPointInChart", "highlightLastValidPointInChart", "highlightedPoint", "highlightNextValidPoint", "highlightFirstValidPointInChart", "highlight", "seriesTypes", "SeriesKeyboardNavigation", "onSeriesDestroy", "lastDrilledDownPoint", "onDrillupAll", "focusedElClassName", "isProxyFocused", "last", "inverted", "onKbdSideways", "onKbdVertical", "firePointEvent", "highlightAdjacentSeries", "onHandlerInit", "onHandlerTerminate", "handler", "attemptHighlightAdjacentPoint", "rememberPointFocus", "isNext", "navOptions", "mode", "keyboardMoveVertical", "kbdNavOptions", "hoverSeries", "onMouseOut", "directionIsNext", "highlightAdjacentPoint", "highlightSuccessful", "chartHighlightAdjacentPoint", "curPoint", "curPointIndex", "curPoints", "lastSeries", "lastPoint", "chartHighlightAdjacentPointVertical", "minDistance", "Infinity", "bestPoint", "yDistance", "distance", "reversed", "chartHighlightAdjacentSeries", "getClosestPoint", "adjacentNewPoint", "xWeight", "yWeight", "minIx", "hasUndefinedPosition", "dPoint", "pointHighlight", "highlightVisually", "onMouseOver", "seriesHighlightNextValidPoint", "start", "j", "PointClass", "highlightAdjacentPointVertical", "seriesProto", "ForcedMarkers", "SeriesComponent", "hideTooltipFromATWhenShown", "hideSeriesLabelsFromATWhenShown", "constructor", "labelBySeries", "getKeyboardNavigationHandler", "ZoomComponent", "focusedMapNavButtonIx", "eventType", "updateProxyOverlays", "mapNavigation", "navButtons", "setMapNavButtonAttrs", "labelFormatKey", "resetZoomButton", "createZoomProxyButton", "drillUpButton", "breadcrumbs", "list", "getButtonText", "lastBreadcrumb", "buttonProp", "onMapKbdArrow", "_keyCode", "onMapKbdTab", "onMapKbdClick", "onMapNavInit", "isY", "diff", "plotHeight", "granularity", "random", "startPos", "offsetLeft", "offsetTop", "endPos", "isMoveOutOfRange", "isBackwards", "zoomBy", "zoomIn", "zoomOut", "initialButton", "proxyProp", "onClick", "simpleButtonNavigation", "_handler", "drillUp", "getMapZoomNavigation", "whcm", "isHighContrastModeActive", "isEdge", "userAgent", "matchMedia", "matches", "getComputedStyle", "testDiv", "backgroundImage", "bi", "currentStyle", "setHighContrastTheme", "highContrastModeActive", "theme", "highContrastTheme", "plotOpts", "plotOptions", "colors", "borderColor", "minColor", "maxColor", "stops", "gridLineColor", "lineColor", "minorGridLineColor", "tickColor", "fillColor", "edgeColor", "dataLabels", "connectorColor", "textOutline", "pie", "boxplot", "candlestick", "errorbar", "itemStyle", "itemHoverStyle", "itemHiddenStyle", "drilldown", "activeAxisLabelStyle", "activeDataLabelStyle", "symbolStroke", "handles", "outlineColor", "maskFill", "barBackgroundColor", "barBorderColor", "buttonArrowColor", "buttonBackgroundColor", "buttonBorderColor", "rifleColor", "trackBackgroundColor", "trackBorderColor", "Options", "langOptions", "defaultChartTitle", "chartContainerLabel", "svgContainerTitle", "graphicContainerLabel", "beforeRegionLabel", "afterRegionLabel", "heading", "descriptionSinglePoint", "descriptionMultiplePoints", "descriptionNoPoints", "playAsSoundButtonText", "playAsSoundClickAnnouncement", "legendLabelNoTitle", "zoom", "mapZoomIn", "mapZoomOut", "dropdownLabel", "minInputLabel", "maxInputLabel", "clickButtonAnnouncement", "viewAsDataTableButtonText", "tableSummary", "newDataAnnounce", "newSeriesAnnounceSingle", "newPointAnnounceSingle", "newSeriesAnnounceMultiple", "newPointAnnounceMultiple", "seriesTypeDescriptions", "arearange", "areasplinerange", "bubble", "columnrange", "funnel", "pyramid", "waterfall", "emptyChart", "mapTypeDescription", "unknownMap", "combinationChart", "defaultSingle", "defaultMultiple", "splineSingle", "splineMultiple", "lineSingle", "lineMultiple", "columnSingle", "columnMultiple", "barSingle", "barMultiple", "pieSingle", "pieMultiple", "scatterSingle", "scatterMultiple", "boxplotSingle", "boxplotMultiple", "bubbleSingle", "bubbleMultiple", "xAxisDescriptionSingular", "xAxisDescriptionPlural", "yAxisDescriptionSingular", "yAxisDescriptionPlural", "timeRangeDays", "timeRangeHours", "timeRangeMinutes", "timeRangeSeconds", "rangeFromTo", "rangeCategories", "chartMenuLabel", "menuButtonLabel", "defaultCombination", "line", "lineCombination", "spline", "splineCombination", "column", "columnCombination", "bar", "barCombination", "pieCombination", "scatter", "scatterCombination", "boxplotCombination", "bubbleCombination", "mapCombination", "mapline", "maplineCombination", "mapbubble", "mapbubbleCombination", "nullPointValue", "pointAnnotationsDescription", "traverseSetOption", "root", "optionAsArray", "prop", "opt", "deprecateFromOptionsMap", "rootOldAsArray", "rootNewAsArray", "mapToNewOptions", "getChildProp", "propAsArray", "rootOld", "rootNew", "oldOptionKey", "error", "copyDeprecatedChartOptions", "copyDeprecatedAxisOptions", "opts", "copyDeprecatedSeriesOptions", "oldToNewSeriesOptions", "exposeElementToA11y", "pointDescriptionFormatter", "skipKeyboardNavigation", "oldOption", "optionVal", "copyDeprecatedOptions", "pointDateFormat", "pointDateFormatter", "pointDescriptionThreshold", "pointNavigationThreshold", "pointValueDecimals", "pointValuePrefix", "pointValueSuffix", "screenReaderSectionFormatter", "seriesDescriptionFormatter", "onTableAnchorClick", "screenReaderRegionLabel", "rangeSelectorMaxInput", "rangeSelectorMinInput", "svgContainerEnd", "viewAsDataTable", "FocusBorder", "defaultOptionsA11Y", "defaultLangOptions", "Accessibility", "addEventListener", "initComponents", "zombie", "infoRegions", "chartMenu", "customComponents", "getComponentOrder", "initBase", "componentsExceptSeries", "getChartTypes", "kbdNavOrder", "destroyBase", "chartOnDestroy", "chartOnRender", "a11yDirty", "updateA11yEnabled", "chartOnUpdate", "newOptions", "chartUpdateA11yEnabled", "accessibilityOptions", "pointOnUpdate", "chartOnAfterDrilldown", "A11yChartUtilities", "A11yHTMLUtilities", "SeriesAccessibilityDescriber"]
}
