import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/highmaps.js
var require_highmaps = __commonJS({
  "node_modules/highcharts/highmaps.js"(exports, module) {
    (function(X, K) {
      "object" === typeof module && module.exports ? (K["default"] = K, module.exports = X.document ? K(X) : K) : "function" === typeof define && define.amd ? define("highcharts/highmaps", function() {
        return K(X);
      }) : (X.Highcharts && X.Highcharts.error(16, true), X.Highcharts = K(X));
    })("undefined" !== typeof window ? window : exports, function(X) {
      function K(a2, x, G, I) {
        a2.hasOwnProperty(x) || (a2[x] = I.apply(null, G), "function" === typeof CustomEvent && X.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: x, module: a2[x] } })));
      }
      var a = {};
      K(a, "Core/Globals.js", [], function() {
        var a2;
        (function(a3) {
          a3.SVG_NS = "http://www.w3.org/2000/svg";
          a3.product = "Highcharts";
          a3.version = "11.1.0";
          a3.win = "undefined" !== typeof X ? X : {};
          a3.doc = a3.win.document;
          a3.svg = a3.doc && a3.doc.createElementNS && !!a3.doc.createElementNS(a3.SVG_NS, "svg").createSVGRect;
          a3.userAgent = a3.win.navigator && a3.win.navigator.userAgent || "";
          a3.isChrome = -1 !== a3.userAgent.indexOf("Chrome");
          a3.isFirefox = -1 !== a3.userAgent.indexOf("Firefox");
          a3.isMS = /(edge|msie|trident)/i.test(a3.userAgent) && !a3.win.opera;
          a3.isSafari = !a3.isChrome && -1 !== a3.userAgent.indexOf("Safari");
          a3.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a3.userAgent);
          a3.isWebKit = -1 !== a3.userAgent.indexOf("AppleWebKit");
          a3.deg2rad = 2 * Math.PI / 360;
          a3.hasBidiBug = a3.isFirefox && 4 > parseInt(a3.userAgent.split("Firefox/")[1], 10);
          a3.hasTouch = !!a3.win.TouchEvent;
          a3.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
          a3.noop = function() {
          };
          a3.supportsPassiveEvents = function() {
            let r = false;
            if (!a3.isMS) {
              const x = Object.defineProperty({}, "passive", { get: function() {
                r = true;
              } });
              a3.win.addEventListener && a3.win.removeEventListener && (a3.win.addEventListener("testPassive", a3.noop, x), a3.win.removeEventListener("testPassive", a3.noop, x));
            }
            return r;
          }();
          a3.charts = [];
          a3.dateFormats = {};
          a3.seriesTypes = {};
          a3.symbolSizes = {};
          a3.chartCount = 0;
        })(a2 || (a2 = {}));
        "";
        return a2;
      });
      K(a, "Core/Utilities.js", [a["Core/Globals.js"]], function(a2) {
        function r(m, b2, d2, c2) {
          const w = b2 ? "Highcharts error" : "Highcharts warning";
          32 === m && (m = `${w}: Deprecated member`);
          const g2 = t(m);
          let l2 = g2 ? `${w} #${m}: www.highcharts.com/errors/${m}/` : m.toString();
          if ("undefined" !== typeof c2) {
            let m2 = "";
            g2 && (l2 += "?");
            C(c2, function(b3, d3) {
              m2 += `
 - ${d3}: ${b3}`;
              g2 && (l2 += encodeURI(d3) + "=" + encodeURI(b3));
            });
            l2 += m2;
          }
          e(a2, "displayError", { chart: d2, code: m, message: l2, params: c2 }, function() {
            if (b2)
              throw Error(l2);
            z.console && -1 === r.messages.indexOf(l2) && console.warn(l2);
          });
          r.messages.push(l2);
        }
        function G(m, b2) {
          return parseInt(m, b2 || 10);
        }
        function I(m) {
          return "string" === typeof m;
        }
        function y(m) {
          m = Object.prototype.toString.call(m);
          return "[object Array]" === m || "[object Array Iterator]" === m;
        }
        function A(m, b2) {
          return !!m && "object" === typeof m && (!b2 || !y(m));
        }
        function F(m) {
          return A(m) && "number" === typeof m.nodeType;
        }
        function D(m) {
          const b2 = m && m.constructor;
          return !(!A(m, true) || F(m) || !b2 || !b2.name || "Object" === b2.name);
        }
        function t(m) {
          return "number" === typeof m && !isNaN(m) && Infinity > m && -Infinity < m;
        }
        function q(m) {
          return "undefined" !== typeof m && null !== m;
        }
        function k(m, b2, d2) {
          const e2 = I(b2) && !q(d2);
          let w;
          const c2 = (b3, d3) => {
            q(b3) ? m.setAttribute(d3, b3) : e2 ? (w = m.getAttribute(d3)) || "class" !== d3 || (w = m.getAttribute(d3 + "Name")) : m.removeAttribute(d3);
          };
          I(b2) ? c2(d2, b2) : C(b2, c2);
          return w;
        }
        function p(m) {
          return y(m) ? m : [m];
        }
        function n(m, b2) {
          let d2;
          m || (m = {});
          for (d2 in b2)
            m[d2] = b2[d2];
          return m;
        }
        function h() {
          const m = arguments, b2 = m.length;
          for (let d2 = 0; d2 < b2; d2++) {
            const b3 = m[d2];
            if ("undefined" !== typeof b3 && null !== b3)
              return b3;
          }
        }
        function f(m, b2) {
          a2.isMS && !a2.svg && b2 && q(b2.opacity) && (b2.filter = `alpha(opacity=${100 * b2.opacity})`);
          n(m.style, b2);
        }
        function c(m) {
          return Math.pow(10, Math.floor(Math.log(m) / Math.LN10));
        }
        function g(m, b2) {
          return 1e14 < m ? m : parseFloat(m.toPrecision(b2 || 14));
        }
        function B(m, b2, d2) {
          let e2;
          if ("width" === b2)
            return b2 = Math.min(m.offsetWidth, m.scrollWidth), d2 = m.getBoundingClientRect && m.getBoundingClientRect().width, d2 < b2 && d2 >= b2 - 1 && (b2 = Math.floor(d2)), Math.max(0, b2 - (B(m, "padding-left", true) || 0) - (B(m, "padding-right", true) || 0));
          if ("height" === b2)
            return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - (B(m, "padding-top", true) || 0) - (B(m, "padding-bottom", true) || 0));
          if (m = z.getComputedStyle(m, void 0))
            e2 = m.getPropertyValue(b2), h(d2, "opacity" !== b2) && (e2 = G(e2));
          return e2;
        }
        function C(b2, d2, e2) {
          for (const m in b2)
            Object.hasOwnProperty.call(
              b2,
              m
            ) && d2.call(e2 || b2[m], b2[m], m, b2);
        }
        function E(b2, d2, e2) {
          function m(m2, d3) {
            const e3 = b2.removeEventListener;
            e3 && e3.call(b2, m2, d3, false);
          }
          function c2(e3) {
            let w2, c3;
            b2.nodeName && (d2 ? (w2 = {}, w2[d2] = true) : w2 = e3, C(w2, function(b3, d3) {
              if (e3[d3])
                for (c3 = e3[d3].length; c3--; )
                  m(d3, e3[d3][c3].fn);
            }));
          }
          var w = "function" === typeof b2 && b2.prototype || b2;
          if (Object.hasOwnProperty.call(w, "hcEvents")) {
            const b3 = w.hcEvents;
            d2 ? (w = b3[d2] || [], e2 ? (b3[d2] = w.filter(function(b4) {
              return e2 !== b4.fn;
            }), m(d2, e2)) : (c2(b3), b3[d2] = [])) : (c2(b3), delete w.hcEvents);
          }
        }
        function e(b2, d2, e2, c2) {
          e2 = e2 || {};
          if (v.createEvent && (b2.dispatchEvent || b2.fireEvent && b2 !== a2)) {
            var m = v.createEvent("Events");
            m.initEvent(d2, true, true);
            e2 = n(m, e2);
            b2.dispatchEvent ? b2.dispatchEvent(e2) : b2.fireEvent(d2, e2);
          } else if (b2.hcEvents) {
            e2.target || n(e2, { preventDefault: function() {
              e2.defaultPrevented = true;
            }, target: b2, type: d2 });
            m = [];
            let c3 = b2, w = false;
            for (; c3.hcEvents; )
              Object.hasOwnProperty.call(c3, "hcEvents") && c3.hcEvents[d2] && (m.length && (w = true), m.unshift.apply(m, c3.hcEvents[d2])), c3 = Object.getPrototypeOf(c3);
            w && m.sort((b3, m2) => b3.order - m2.order);
            m.forEach((m2) => {
              false === m2.fn.call(b2, e2) && e2.preventDefault();
            });
          }
          c2 && !e2.defaultPrevented && c2.call(b2, e2);
        }
        const { charts: l, doc: v, win: z } = a2;
        (r || (r = {})).messages = [];
        Math.easeInOutSine = function(b2) {
          return -0.5 * (Math.cos(Math.PI * b2) - 1);
        };
        var u = Array.prototype.find ? function(b2, d2) {
          return b2.find(d2);
        } : function(b2, d2) {
          let m;
          const e2 = b2.length;
          for (m = 0; m < e2; m++)
            if (d2(b2[m], m))
              return b2[m];
        };
        C({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(b2, d2) {
          a2[d2] = function(m) {
            r(32, false, void 0, { [`Highcharts.${d2}`]: `use Array.${b2}` });
            return Array.prototype[b2].apply(m, [].slice.call(
              arguments,
              1
            ));
          };
        });
        let b;
        const d = function() {
          const m = Math.random().toString(36).substring(2, 9) + "-";
          let d2 = 0;
          return function() {
            return "highcharts-" + (b ? "" : m) + d2++;
          };
        }();
        z.jQuery && (z.jQuery.fn.highcharts = function() {
          const b2 = [].slice.call(arguments);
          if (this[0])
            return b2[0] ? (new a2[I(b2[0]) ? b2.shift() : "Chart"](this[0], b2[0], b2[1]), this) : l[k(this[0], "data-highcharts-chart")];
        });
        u = { addEvent: function(b2, d2, e2, c2 = {}) {
          var m = "function" === typeof b2 && b2.prototype || b2;
          Object.hasOwnProperty.call(m, "hcEvents") || (m.hcEvents = {});
          m = m.hcEvents;
          a2.Point && b2 instanceof a2.Point && b2.series && b2.series.chart && (b2.series.chart.runTrackerClick = true);
          const l2 = b2.addEventListener;
          l2 && l2.call(b2, d2, e2, a2.supportsPassiveEvents ? { passive: void 0 === c2.passive ? -1 !== d2.indexOf("touch") : c2.passive, capture: false } : false);
          m[d2] || (m[d2] = []);
          m[d2].push({ fn: e2, order: "number" === typeof c2.order ? c2.order : Infinity });
          m[d2].sort((b3, m2) => b3.order - m2.order);
          return function() {
            E(b2, d2, e2);
          };
        }, arrayMax: function(b2) {
          let m = b2.length, d2 = b2[0];
          for (; m--; )
            b2[m] > d2 && (d2 = b2[m]);
          return d2;
        }, arrayMin: function(b2) {
          let m = b2.length, d2 = b2[0];
          for (; m--; )
            b2[m] < d2 && (d2 = b2[m]);
          return d2;
        }, attr: k, clamp: function(b2, d2, e2) {
          return b2 > d2 ? b2 < e2 ? b2 : e2 : d2;
        }, clearTimeout: function(b2) {
          q(b2) && clearTimeout(b2);
        }, correctFloat: g, createElement: function(b2, d2, e2, c2, l2) {
          b2 = v.createElement(b2);
          d2 && n(b2, d2);
          l2 && f(b2, { padding: "0", border: "none", margin: "0" });
          e2 && f(b2, e2);
          c2 && c2.appendChild(b2);
          return b2;
        }, css: f, defined: q, destroyObjectProperties: function(b2, d2) {
          C(b2, function(m, e2) {
            m && m !== d2 && m.destroy && m.destroy();
            delete b2[e2];
          });
        }, diffObjects: function(b2, d2, e2, c2) {
          function m(b3, d3, l3, g2) {
            const J = e2 ? d3 : b3;
            C(b3, function(e3, w) {
              if (!g2 && c2 && -1 < c2.indexOf(w) && d3[w]) {
                e3 = p(e3);
                l3[w] = [];
                for (let b4 = 0; b4 < Math.max(e3.length, d3[w].length); b4++)
                  d3[w][b4] && (void 0 === e3[b4] ? l3[w][b4] = d3[w][b4] : (l3[w][b4] = {}, m(e3[b4], d3[w][b4], l3[w][b4], g2 + 1)));
              } else if (A(e3, true) && !e3.nodeType)
                l3[w] = y(e3) ? [] : {}, m(e3, d3[w] || {}, l3[w], g2 + 1), 0 !== Object.keys(l3[w]).length || "colorAxis" === w && 0 === g2 || delete l3[w];
              else if (b3[w] !== d3[w] || w in b3 && !(w in d3))
                l3[w] = J[w];
            });
          }
          const l2 = {};
          m(b2, d2, l2, 0);
          return l2;
        }, discardElement: function(b2) {
          b2 && b2.parentElement && b2.parentElement.removeChild(b2);
        }, erase: function(b2, d2) {
          let m = b2.length;
          for (; m--; )
            if (b2[m] === d2) {
              b2.splice(m, 1);
              break;
            }
        }, error: r, extend: n, extendClass: function(b2, d2) {
          const m = function() {
          };
          m.prototype = new b2();
          n(m.prototype, d2);
          return m;
        }, find: u, fireEvent: e, getClosestDistance: function(b2, d2) {
          const m = !d2;
          let e2, c2, l2, g2;
          b2.forEach((b3) => {
            if (1 < b3.length)
              for (g2 = c2 = b3.length - 1; 0 < g2; g2--)
                l2 = b3[g2] - b3[g2 - 1], 0 > l2 && !m ? (null === d2 || void 0 === d2 ? void 0 : d2(), d2 = void 0) : l2 && ("undefined" === typeof e2 || l2 < e2) && (e2 = l2);
          });
          return e2;
        }, getMagnitude: c, getNestedProperty: function(b2, d2) {
          for (b2 = b2.split("."); b2.length && q(d2); ) {
            const m = b2.shift();
            if ("undefined" === typeof m || "__proto__" === m)
              return;
            if ("this" === m) {
              let b3;
              A(d2) && (b3 = d2["@this"]);
              return null !== b3 && void 0 !== b3 ? b3 : d2;
            }
            d2 = d2[m];
            if (!q(d2) || "function" === typeof d2 || "number" === typeof d2.nodeType || d2 === z)
              return;
          }
          return d2;
        }, getStyle: B, inArray: function(b2, d2, e2) {
          r(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
          return d2.indexOf(b2, e2);
        }, insertItem: function(b2, d2) {
          const m = b2.options.index, e2 = d2.length;
          let c2;
          for (c2 = b2.options.isInternal ? e2 : 0; c2 < e2 + 1; c2++)
            if (!d2[c2] || t(m) && m < h(d2[c2].options.index, d2[c2]._i) || d2[c2].options.isInternal) {
              d2.splice(
                c2,
                0,
                b2
              );
              break;
            }
          return c2;
        }, isArray: y, isClass: D, isDOMElement: F, isFunction: function(b2) {
          return "function" === typeof b2;
        }, isNumber: t, isObject: A, isString: I, keys: function(b2) {
          r(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
          return Object.keys(b2);
        }, merge: function() {
          let b2, d2 = arguments, e2 = {};
          const c2 = function(b3, d3) {
            "object" !== typeof b3 && (b3 = {});
            C(d3, function(m, e3) {
              "__proto__" !== e3 && "constructor" !== e3 && (!A(m, true) || D(m) || F(m) ? b3[e3] = d3[e3] : b3[e3] = c2(b3[e3] || {}, m));
            });
            return b3;
          };
          true === d2[0] && (e2 = d2[1], d2 = Array.prototype.slice.call(d2, 2));
          const l2 = d2.length;
          for (b2 = 0; b2 < l2; b2++)
            e2 = c2(e2, d2[b2]);
          return e2;
        }, normalizeTickInterval: function(b2, d2, e2, l2, v2) {
          let m = b2;
          e2 = h(e2, c(b2));
          const w = b2 / e2;
          d2 || (d2 = v2 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === l2 && (1 === e2 ? d2 = d2.filter(function(b3) {
            return 0 === b3 % 1;
          }) : 0.1 >= e2 && (d2 = [1 / e2])));
          for (l2 = 0; l2 < d2.length && !(m = d2[l2], v2 && m * e2 >= b2 || !v2 && w <= (d2[l2] + (d2[l2 + 1] || d2[l2])) / 2); l2++)
            ;
          return m = g(m * e2, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: C, offset: function(b2) {
          const d2 = v.documentElement;
          b2 = b2.parentElement || b2.parentNode ? b2.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return { top: b2.top + (z.pageYOffset || d2.scrollTop) - (d2.clientTop || 0), left: b2.left + (z.pageXOffset || d2.scrollLeft) - (d2.clientLeft || 0), width: b2.width, height: b2.height };
        }, pad: function(b2, d2, e2) {
          return Array((d2 || 2) + 1 - String(b2).replace("-", "").length).join(e2 || "0") + b2;
        }, pick: h, pInt: G, pushUnique: function(b2, d2) {
          return 0 > b2.indexOf(d2) && !!b2.push(d2);
        }, relativeLength: function(b2, d2, e2) {
          return /%$/.test(b2) ? d2 * parseFloat(b2) / 100 + (e2 || 0) : parseFloat(b2);
        }, removeEvent: E, splat: p, stableSort: function(b2, d2) {
          const e2 = b2.length;
          let m, c2;
          for (c2 = 0; c2 < e2; c2++)
            b2[c2].safeI = c2;
          b2.sort(function(b3, e3) {
            m = d2(b3, e3);
            return 0 === m ? b3.safeI - e3.safeI : m;
          });
          for (c2 = 0; c2 < e2; c2++)
            delete b2[c2].safeI;
        }, syncTimeout: function(b2, d2, e2) {
          if (0 < d2)
            return setTimeout(b2, d2, e2);
          b2.call(0, e2);
          return -1;
        }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: d, useSerialIds: function(d2) {
          return b = h(d2, b);
        }, wrap: function(b2, d2, e2) {
          const m = b2[d2];
          b2[d2] = function() {
            const b3 = arguments, d3 = this;
            return e2.apply(this, [function() {
              return m.apply(
                d3,
                arguments.length ? arguments : b3
              );
            }].concat([].slice.call(arguments)));
          };
        } };
        "";
        return u;
      });
      K(a, "Core/Chart/ChartDefaults.js", [], function() {
        return {
          alignThresholds: false,
          panning: { enabled: false, type: "x" },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } },
          reflow: true,
          type: "line",
          zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        };
      });
      K(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { isNumber: r, merge: I, pInt: y } = x;
        class A {
          static parse(a3) {
            return a3 ? new A(a3) : A.None;
          }
          constructor(r2) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = r2;
            const D = a2.Color;
            if (D && D !== A)
              return new D(r2);
            this.init(r2);
          }
          init(a3) {
            let D;
            let t;
            if ("object" === typeof a3 && "undefined" !== typeof a3.stops)
              this.stops = a3.stops.map((k2) => new A(k2[1]));
            else if ("string" === typeof a3) {
              this.input = a3 = A.names[a3.toLowerCase()] || a3;
              if ("#" === a3.charAt(0)) {
                var q = a3.length;
                var k = parseInt(a3.substr(1), 16);
                7 === q ? D = [(k & 16711680) >> 16, (k & 65280) >> 8, k & 255, 1] : 4 === q && (D = [(k & 3840) >> 4 | (k & 3840) >> 8, (k & 240) >> 4 | k & 240, (k & 15) << 4 | k & 15, 1]);
              }
              if (!D)
                for (k = A.parsers.length; k-- && !D; )
                  t = A.parsers[k], (q = t.regex.exec(a3)) && (D = t.parse(q));
            }
            D && (this.rgba = D);
          }
          get(a3) {
            const D = this.input, t = this.rgba;
            if ("object" === typeof D && "undefined" !== typeof this.stops) {
              const q = I(D);
              q.stops = [].slice.call(q.stops);
              this.stops.forEach((k, p) => {
                q.stops[p] = [
                  q.stops[p][0],
                  k.get(a3)
                ];
              });
              return q;
            }
            return t && r(t[0]) ? "rgb" === a3 || !a3 && 1 === t[3] ? "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" : "a" === a3 ? `${t[3]}` : "rgba(" + t.join(",") + ")" : D;
          }
          brighten(a3) {
            const D = this.rgba;
            if (this.stops)
              this.stops.forEach(function(t) {
                t.brighten(a3);
              });
            else if (r(a3) && 0 !== a3)
              for (let t = 0; 3 > t; t++)
                D[t] += y(255 * a3), 0 > D[t] && (D[t] = 0), 255 < D[t] && (D[t] = 255);
            return this;
          }
          setOpacity(a3) {
            this.rgba[3] = a3;
            return this;
          }
          tweenTo(a3, D) {
            const t = this.rgba, q = a3.rgba;
            if (!r(t[0]) || !r(q[0]))
              return a3.input || "none";
            a3 = 1 !== q[3] || 1 !== t[3];
            return (a3 ? "rgba(" : "rgb(") + Math.round(q[0] + (t[0] - q[0]) * (1 - D)) + "," + Math.round(q[1] + (t[1] - q[1]) * (1 - D)) + "," + Math.round(q[2] + (t[2] - q[2]) * (1 - D)) + (a3 ? "," + (q[3] + (t[3] - q[3]) * (1 - D)) : "") + ")";
          }
        }
        A.names = { white: "#ffffff", black: "#000000" };
        A.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(a3) {
          return [y(a3[1]), y(a3[2]), y(a3[3]), parseFloat(a3[4], 10)];
        } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(a3) {
          return [
            y(a3[1]),
            y(a3[2]),
            y(a3[3]),
            1
          ];
        } }];
        A.None = new A("");
        "";
        return A;
      });
      K(a, "Core/Color/Palettes.js", [], function() {
        return { colors: "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(" ") };
      });
      K(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { win: r } = a2, { defined: I, error: y, extend: A, isObject: F, merge: D, objectEach: t, pad: q, pick: k, splat: p, timeUnits: n } = x, h = a2.isSafari && r.Intl && r.Intl.DateTimeFormat.prototype.formatRange, f = a2.isSafari && r.Intl && !r.Intl.DateTimeFormat.prototype.formatRange;
        class c {
          constructor(c2) {
            this.options = {};
            this.variableTimezone = this.useUTC = false;
            this.Date = r.Date;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(c2);
          }
          get(c2, f2) {
            if (this.variableTimezone || this.timezoneOffset) {
              const g = f2.getTime(), h2 = g - this.getTimezoneOffset(f2);
              f2.setTime(h2);
              c2 = f2["getUTC" + c2]();
              f2.setTime(g);
              return c2;
            }
            return this.useUTC ? f2["getUTC" + c2]() : f2["get" + c2]();
          }
          set(c2, f2, C) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === c2 || "Seconds" === c2 || "Minutes" === c2 && 0 === this.getTimezoneOffset(f2) % 36e5)
                return f2["setUTC" + c2](C);
              var g = this.getTimezoneOffset(f2);
              g = f2.getTime() - g;
              f2.setTime(g);
              f2["setUTC" + c2](C);
              c2 = this.getTimezoneOffset(f2);
              g = f2.getTime() + c2;
              return f2.setTime(g);
            }
            return this.useUTC || h && "FullYear" === c2 ? f2["setUTC" + c2](C) : f2["set" + c2](C);
          }
          update(c2 = {}) {
            const g = k(c2.useUTC, true);
            this.options = c2 = D(true, this.options, c2);
            this.Date = c2.Date || r.Date || Date;
            this.timezoneOffset = (this.useUTC = g) && c2.timezoneOffset || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.variableTimezone = g && !(!c2.getTimezoneOffset && !c2.timezone);
          }
          makeTime(c2, h2, C, n2, e, l) {
            let g, z, u;
            this.useUTC ? (g = this.Date.UTC.apply(0, arguments), z = this.getTimezoneOffset(g), g += z, u = this.getTimezoneOffset(g), z !== u ? g += u - z : z - 36e5 !== this.getTimezoneOffset(g - 36e5) || f || (g -= 36e5)) : g = new this.Date(c2, h2, k(C, 1), k(n2, 0), k(e, 0), k(l, 0)).getTime();
            return g;
          }
          timezoneOffsetFunction() {
            const c2 = this, f2 = this.options, h2 = f2.getTimezoneOffset, k2 = f2.moment || r.moment;
            if (!this.useUTC)
              return function(e) {
                return 6e4 * new Date(e.toString()).getTimezoneOffset();
              };
            if (f2.timezone) {
              if (k2)
                return function(e) {
                  return 6e4 * -k2.tz(e, f2.timezone).utcOffset();
                };
              y(25);
            }
            return this.useUTC && h2 ? function(e) {
              return 6e4 * h2(e.valueOf());
            } : function() {
              return 6e4 * (c2.timezoneOffset || 0);
            };
          }
          dateFormat(c2, f2, h2) {
            if (!I(f2) || isNaN(f2))
              return a2.defaultOptions.lang && a2.defaultOptions.lang.invalidDate || "";
            c2 = k(c2, "%Y-%m-%d %H:%M:%S");
            const g = this;
            var e = new this.Date(f2);
            const l = this.get("Hours", e), v = this.get("Day", e), z = this.get("Date", e), u = this.get("Month", e), b = this.get("FullYear", e), d = a2.defaultOptions.lang, m = d && d.weekdays, w = d && d.shortWeekdays;
            e = A({ a: w ? w[v] : m[v].substr(0, 3), A: m[v], d: q(z), e: q(z, 2, " "), w: v, b: d.shortMonths[u], B: d.months[u], m: q(u + 1), o: u + 1, y: b.toString().substr(2, 2), Y: b, H: q(l), k: l, I: q(l % 12 || 12), l: l % 12 || 12, M: q(this.get("Minutes", e)), p: 12 > l ? "AM" : "PM", P: 12 > l ? "am" : "pm", S: q(e.getSeconds()), L: q(Math.floor(f2 % 1e3), 3) }, a2.dateFormats);
            t(e, function(b2, d2) {
              for (; -1 !== c2.indexOf("%" + d2); )
                c2 = c2.replace("%" + d2, "function" === typeof b2 ? b2.call(g, f2) : b2);
            });
            return h2 ? c2.substr(0, 1).toUpperCase() + c2.substr(1) : c2;
          }
          resolveDTLFormat(c2) {
            return F(c2, true) ? c2 : (c2 = p(c2), {
              main: c2[0],
              from: c2[1],
              to: c2[2]
            });
          }
          getTimeTicks(c2, f2, h2, E) {
            const e = this, l = [], g = {};
            var z = new e.Date(f2);
            const u = c2.unitRange, b = c2.count || 1;
            let d;
            E = k(E, 1);
            if (I(f2)) {
              e.set("Milliseconds", z, u >= n.second ? 0 : b * Math.floor(e.get("Milliseconds", z) / b));
              u >= n.second && e.set("Seconds", z, u >= n.minute ? 0 : b * Math.floor(e.get("Seconds", z) / b));
              u >= n.minute && e.set("Minutes", z, u >= n.hour ? 0 : b * Math.floor(e.get("Minutes", z) / b));
              u >= n.hour && e.set("Hours", z, u >= n.day ? 0 : b * Math.floor(e.get("Hours", z) / b));
              u >= n.day && e.set("Date", z, u >= n.month ? 1 : Math.max(1, b * Math.floor(e.get(
                "Date",
                z
              ) / b)));
              if (u >= n.month) {
                e.set("Month", z, u >= n.year ? 0 : b * Math.floor(e.get("Month", z) / b));
                var m = e.get("FullYear", z);
              }
              u >= n.year && e.set("FullYear", z, m - m % b);
              u === n.week && (m = e.get("Day", z), e.set("Date", z, e.get("Date", z) - m + E + (m < E ? -7 : 0)));
              m = e.get("FullYear", z);
              E = e.get("Month", z);
              const c3 = e.get("Date", z), v = e.get("Hours", z);
              f2 = z.getTime();
              !e.variableTimezone && e.useUTC || !I(h2) || (d = h2 - f2 > 4 * n.month || e.getTimezoneOffset(f2) !== e.getTimezoneOffset(h2));
              f2 = z.getTime();
              for (z = 1; f2 < h2; )
                l.push(f2), f2 = u === n.year ? e.makeTime(m + z * b, 0) : u === n.month ? e.makeTime(m, E + z * b) : !d || u !== n.day && u !== n.week ? d && u === n.hour && 1 < b ? e.makeTime(m, E, c3, v + z * b) : f2 + u * b : e.makeTime(m, E, c3 + z * b * (u === n.day ? 1 : 7)), z++;
              l.push(f2);
              u <= n.hour && 1e4 > l.length && l.forEach(function(b2) {
                0 === b2 % 18e5 && "000000000" === e.dateFormat("%H%M%S%L", b2) && (g[b2] = "day");
              });
            }
            l.info = A(c2, { higherRanks: g, totalRange: u * b });
            return l;
          }
          getDateFormat(c2, f2, h2, k2) {
            const e = this.dateFormat("%m-%d %H:%M:%S.%L", f2), l = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
            let g, z = "millisecond";
            for (g in n) {
              if (c2 === n.week && +this.dateFormat(
                "%w",
                f2
              ) === h2 && "00:00:00.000" === e.substr(6)) {
                g = "week";
                break;
              }
              if (n[g] > c2) {
                g = z;
                break;
              }
              if (l[g] && e.substr(l[g]) !== "01-01 00:00:00.000".substr(l[g]))
                break;
              "week" !== g && (z = g);
            }
            return this.resolveDTLFormat(k2[g]).main;
          }
        }
        "";
        return c;
      });
      K(a, "Core/Defaults.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palettes.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A) {
        const { isTouchDevice: r, svg: D } = G, { merge: t } = A, q = {
          colors: I.colors,
          symbols: [
            "circle",
            "diamond",
            "square",
            "triangle",
            "triangle-down"
          ],
          lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " },
          global: {},
          time: {
            Date: void 0,
            getTimezoneOffset: void 0,
            timezone: void 0,
            timezoneOffset: 0,
            useUTC: true
          },
          chart: a2,
          title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 },
          subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 },
          caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" },
          plotOptions: {},
          legend: {
            enabled: true,
            align: "center",
            alignColumns: true,
            className: "highcharts-no-tooltip",
            layout: "horizontal",
            itemMarginBottom: 2,
            itemMarginTop: 2,
            labelFormatter: function() {
              return this.name;
            },
            borderColor: "#999999",
            borderRadius: 0,
            navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" },
            itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" },
            itemHoverStyle: { color: "#000000" },
            itemHiddenStyle: { color: "#666666", textDecoration: "line-through" },
            shadow: false,
            itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" },
            squareSymbol: true,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: { style: { fontSize: "0.8em", fontWeight: "bold" } }
          },
          loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } },
          tooltip: {
            enabled: true,
            animation: D,
            borderRadius: 3,
            dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" },
            footerFormat: "",
            headerShape: "callout",
            hideDelay: 500,
            padding: 8,
            shape: "callout",
            shared: false,
            snap: r ? 25 : 10,
            headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
            backgroundColor: "#ffffff",
            borderWidth: void 0,
            shadow: true,
            stickOnContact: false,
            style: { color: "#333333", cursor: "default", fontSize: "0.8em" },
            useHTML: false
          },
          credits: {
            enabled: true,
            href: "https://www.highcharts.com?credits",
            position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 },
            style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" },
            text: "Highcharts.com"
          }
        };
        q.chart.styledMode = false;
        "";
        const k = new y(q.time);
        a2 = { defaultOptions: q, defaultTime: k, getOptions: function() {
          return q;
        }, setOptions: function(a3) {
          t(true, q, a3);
          if (a3.time || a3.global)
            G.time ? G.time.update(t(q.global, q.time, a3.global, a3.time)) : G.time = k;
          return q;
        } };
        "";
        return a2;
      });
      K(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { parse: r } = a2, { win: y } = x, { isNumber: A, objectEach: F } = G;
        class D {
          constructor(a3, q, k) {
            this.pos = NaN;
            this.options = q;
            this.elem = a3;
            this.prop = k;
          }
          dSetter() {
            var a3 = this.paths;
            const q = a3 && a3[0];
            a3 = a3 && a3[1];
            const k = this.now || 0;
            let p = [];
            if (1 !== k && q && a3)
              if (q.length === a3.length && 1 > k)
                for (let n = 0; n < a3.length; n++) {
                  const h = q[n], f = a3[n], c = [];
                  for (let g = 0; g < f.length; g++) {
                    const B = h[g], C = f[g];
                    A(B) && A(C) && ("A" !== f[0] || 4 !== g && 5 !== g) ? c[g] = B + k * (C - B) : c[g] = C;
                  }
                  p.push(c);
                }
              else
                p = a3;
            else
              p = this.toD || [];
            this.elem.attr("d", p, void 0, true);
          }
          update() {
            const a3 = this.elem, q = this.prop, k = this.now, p = this.options.step;
            if (this[q + "Setter"])
              this[q + "Setter"]();
            else
              a3.attr ? a3.element && a3.attr(q, k, null, true) : a3.style[q] = k + this.unit;
            p && p.call(a3, k, this);
          }
          run(a3, q, k) {
            const p = this, n = p.options, h = function(c2) {
              return h.stopped ? false : p.step(c2);
            }, f = y.requestAnimationFrame || function(c2) {
              setTimeout(c2, 13);
            }, c = function() {
              for (let c2 = 0; c2 < D.timers.length; c2++)
                D.timers[c2]() || D.timers.splice(c2--, 1);
              D.timers.length && f(c);
            };
            a3 !== q || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = a3, this.end = q, this.unit = k, this.now = this.start, this.pos = 0, h.elem = this.elem, h.prop = this.prop, h() && 1 === D.timers.push(h) && f(c)) : (delete n.curAnim[this.prop], n.complete && 0 === Object.keys(n.curAnim).length && n.complete.call(this.elem));
          }
          step(a3) {
            const q = +/* @__PURE__ */ new Date(), k = this.options, p = this.elem, n = k.complete, h = k.duration, f = k.curAnim;
            let c;
            p.attr && !p.element ? a3 = false : a3 || q >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), c = f[this.prop] = true, F(f, function(g) {
              true !== g && (c = false);
            }), c && n && n.call(p), a3 = false) : (this.pos = k.easing((q - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a3 = true);
            return a3;
          }
          initPath(a3, q, k) {
            function p(e, l) {
              for (; e.length < C; ) {
                var g2 = e[0];
                const f2 = l[C - e.length];
                f2 && "M" === g2[0] && (e[0] = "C" === f2[0] ? ["C", g2[1], g2[2], g2[1], g2[2], g2[1], g2[2]] : ["L", g2[1], g2[2]]);
                e.unshift(g2);
                c && (g2 = e.pop(), e.push(e[e.length - 1], g2));
              }
            }
            function n(e, l) {
              for (; e.length < C; )
                if (l = e[Math.floor(e.length / g) - 1].slice(), "C" === l[0] && (l[1] = l[5], l[2] = l[6]), c) {
                  const c2 = e[Math.floor(e.length / g)].slice();
                  e.splice(e.length / 2, 0, l, c2);
                } else
                  e.push(l);
            }
            const h = a3.startX, f = a3.endX;
            k = k.slice();
            const c = a3.isArea, g = c ? 2 : 1;
            let B, C, E;
            q = q && q.slice();
            if (!q)
              return [
                k,
                k
              ];
            if (h && f && f.length) {
              for (a3 = 0; a3 < h.length; a3++)
                if (h[a3] === f[0]) {
                  B = a3;
                  break;
                } else if (h[0] === f[f.length - h.length + a3]) {
                  B = a3;
                  E = true;
                  break;
                } else if (h[h.length - 1] === f[f.length - h.length + a3]) {
                  B = h.length - a3;
                  break;
                }
              "undefined" === typeof B && (q = []);
            }
            q.length && A(B) && (C = k.length + B * g, E ? (p(q, k), n(k, q)) : (p(k, q), n(q, k)));
            return [q, k];
          }
          fillSetter() {
            D.prototype.strokeSetter.apply(this, arguments);
          }
          strokeSetter() {
            this.elem.attr(this.prop, r(this.start).tweenTo(r(this.end), this.pos), void 0, true);
          }
        }
        D.timers = [];
        return D;
      });
      K(
        a,
        "Core/Animation/AnimationUtilities.js",
        [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]],
        function(a2, x) {
          function r(k2) {
            return t(k2) ? q({ duration: 500, defer: 0 }, k2) : { duration: k2 ? 500 : 0, defer: 0 };
          }
          function I(k2, h) {
            let f = a2.timers.length;
            for (; f--; )
              a2.timers[f].elem !== k2 || h && h !== a2.timers[f].prop || (a2.timers[f].stopped = true);
          }
          const { defined: y, getStyle: A, isArray: F, isNumber: D, isObject: t, merge: q, objectEach: k, pick: p } = x;
          return { animate: function(n, h, f) {
            let c, g = "", B, C, E;
            t(f) || (E = arguments, f = { duration: E[2], easing: E[3], complete: E[4] });
            D(f.duration) || (f.duration = 400);
            f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;
            f.curAnim = q(h);
            k(h, function(e, l) {
              I(n, l);
              C = new a2(n, f, l);
              B = void 0;
              "d" === l && F(h.d) ? (C.paths = C.initPath(n, n.pathArray, h.d), C.toD = h.d, c = 0, B = 1) : n.attr ? c = n.attr(l) : (c = parseFloat(A(n, l)) || 0, "opacity" !== l && (g = "px"));
              B || (B = e);
              "string" === typeof B && B.match("px") && (B = B.replace(/px/g, ""));
              C.run(c, B, g);
            });
          }, animObject: r, getDeferredAnimation: function(k2, h, f) {
            const c = r(h);
            let g = 0, B = 0;
            (f ? [f] : k2.series).forEach((f2) => {
              f2 = r(f2.options.animation);
              g = h && y(h.defer) ? c.defer : Math.max(g, f2.duration + f2.defer);
              B = Math.min(c.duration, f2.duration);
            });
            k2.renderer.forExport && (g = 0);
            return { defer: Math.max(0, g - B), duration: Math.min(g, B) };
          }, setAnimation: function(k2, h) {
            h.renderer.globalAnimation = p(k2, h.options.chart.animation, true);
          }, stop: I };
        }
      );
      K(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { SVG_NS: r, win: I } = a2, { attr: y, createElement: A, css: F, error: D, isFunction: t, isString: q, objectEach: k, splat: p } = x;
        ({ trustedTypes: x } = I);
        const n = x && t(x.createPolicy) && x.createPolicy("highcharts", { createHTML: (c2) => c2 });
        x = n ? n.createHTML("") : "";
        try {
          var h = !!new DOMParser().parseFromString(x, "text/html");
        } catch (g) {
          h = false;
        }
        const f = h;
        class c {
          static filterUserAttributes(g) {
            k(g, (f2, h2) => {
              let k2 = true;
              -1 === c.allowedAttributes.indexOf(h2) && (k2 = false);
              -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(h2) && (k2 = q(f2) && c.allowedReferences.some((e) => 0 === f2.indexOf(e)));
              k2 || (D(33, false, void 0, { "Invalid attribute in config": `${h2}` }), delete g[h2]);
              q(f2) && g[h2] && (g[h2] = f2.replace(
                /</g,
                "&lt;"
              ));
            });
            return g;
          }
          static parseStyle(c2) {
            return c2.split(";").reduce((c3, g) => {
              g = g.split(":").map((e) => e.trim());
              const f2 = g.shift();
              f2 && g.length && (c3[f2.replace(/-([a-z])/g, (e) => e[1].toUpperCase())] = g.join(":"));
              return c3;
            }, {});
          }
          static setElementHTML(g, f2) {
            g.innerHTML = c.emptyHTML;
            f2 && new c(f2).addToDOM(g);
          }
          constructor(c2) {
            this.nodes = "string" === typeof c2 ? this.parseMarkup(c2) : c2;
          }
          addToDOM(g) {
            function f2(g2, h2) {
              let e;
              p(g2).forEach(function(l) {
                var g3 = l.tagName;
                const z = l.textContent ? a2.doc.createTextNode(l.textContent) : void 0, u = c.bypassHTMLFiltering;
                let b;
                if (g3)
                  if ("#text" === g3)
                    b = z;
                  else if (-1 !== c.allowedTags.indexOf(g3) || u) {
                    g3 = a2.doc.createElementNS("svg" === g3 ? r : h2.namespaceURI || r, g3);
                    const d = l.attributes || {};
                    k(l, function(b2, e2) {
                      "tagName" !== e2 && "attributes" !== e2 && "children" !== e2 && "style" !== e2 && "textContent" !== e2 && (d[e2] = b2);
                    });
                    y(g3, u ? d : c.filterUserAttributes(d));
                    l.style && F(g3, l.style);
                    z && g3.appendChild(z);
                    f2(l.children || [], g3);
                    b = g3;
                  } else
                    D(33, false, void 0, { "Invalid tagName in config": g3 });
                b && h2.appendChild(b);
                e = b;
              });
              return e;
            }
            return f2(this.nodes, g);
          }
          parseMarkup(g) {
            const h2 = [];
            g = g.trim().replace(/ style=(["'])/g, " data-style=$1");
            if (f)
              g = new DOMParser().parseFromString(n ? n.createHTML(g) : g, "text/html");
            else {
              const c2 = A("div");
              c2.innerHTML = g;
              g = { body: c2 };
            }
            const k2 = (g2, e) => {
              var l = g2.nodeName.toLowerCase();
              const f2 = { tagName: l };
              "#text" === l && (f2.textContent = g2.textContent || "");
              if (l = g2.attributes) {
                const e2 = {};
                [].forEach.call(l, (l2) => {
                  "data-style" === l2.name ? f2.style = c.parseStyle(l2.value) : e2[l2.name] = l2.value;
                });
                f2.attributes = e2;
              }
              if (g2.childNodes.length) {
                const e2 = [];
                [].forEach.call(g2.childNodes, (c2) => {
                  k2(
                    c2,
                    e2
                  );
                });
                e2.length && (f2.children = e2);
              }
              e.push(f2);
            };
            [].forEach.call(g.body.childNodes, (c2) => k2(c2, h2));
            return h2;
          }
        }
        c.allowedAttributes = "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
        c.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
        c.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");
        c.emptyHTML = x;
        c.bypassHTMLFiltering = false;
        "";
        return c;
      });
      K(a, "Core/Templating.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, x) {
        function r(f = "", c, g) {
          const k2 = /\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g, a3 = /\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g, n2 = [], e = /f$/, l = /\.([0-9])/, v = y.lang, z = g && g.time || A, u = g && g.numberFormatter || I, b = (b2 = "") => {
            let d2;
            return "true" === b2 ? true : "false" === b2 ? false : (d2 = Number(b2)).toString() === b2 ? d2 : D(b2, c);
          };
          let d, m, w = 0, q2;
          for (; null !== (d = k2.exec(f)); ) {
            const b2 = a3.exec(d[1]);
            b2 && (d = b2, q2 = true);
            m && m.isBlock || (m = {
              ctx: c,
              expression: d[1],
              find: d[0],
              isBlock: "#" === d[1].charAt(0),
              start: d.index,
              startInner: d.index + d[0].length,
              length: d[0].length
            });
            var H = d[1].split(" ")[0].replace("#", "");
            h[H] && (m.isBlock && H === m.fn && w++, m.fn || (m.fn = H));
            H = "else" === d[1];
            if (m.isBlock && m.fn && (d[1] === `/${m.fn}` || H))
              if (w)
                H || w--;
              else {
                var N = m.startInner;
                N = f.substr(N, d.index - N);
                void 0 === m.body ? (m.body = N, m.startInner = d.index + d[0].length) : m.elseBody = N;
                m.find += N + d[0];
                H || (n2.push(m), m = void 0);
              }
            else
              m.isBlock || n2.push(m);
            if (b2 && (null === m || void 0 === m || !m.isBlock))
              break;
          }
          n2.forEach((d2) => {
            const { body: m2, elseBody: g2, expression: w2, fn: N2 } = d2;
            var J;
            if (N2) {
              var k3 = [d2], a4 = w2.split(" ");
              for (J = h[N2].length; J--; )
                k3.unshift(b(a4[J + 1]));
              J = h[N2].apply(c, k3);
              d2.isBlock && "boolean" === typeof J && (J = r(J ? m2 : g2, c));
            } else
              k3 = w2.split(":"), J = b(k3.shift() || ""), k3.length && "number" === typeof J && (k3 = k3.join(":"), e.test(k3) ? (a4 = parseInt((k3.match(l) || ["", "-1"])[1], 10), null !== J && (J = u(J, a4, v.decimalPoint, -1 < k3.indexOf(",") ? v.thousandsSep : ""))) : J = z.dateFormat(k3, J));
            f = f.replace(d2.find, p(J, ""));
          });
          return q2 ? r(f, c, g) : f;
        }
        function I(f, c, g, h2) {
          f = +f || 0;
          c = +c;
          const k2 = y.lang;
          var a3 = (f.toString().split(".")[1] || "").split("e")[0].length;
          const e = f.toString().split("e"), l = c;
          if (-1 === c)
            c = Math.min(a3, 20);
          else if (!q(c))
            c = 2;
          else if (c && e[1] && 0 > e[1]) {
            var v = c + +e[1];
            0 <= v ? (e[0] = (+e[0]).toExponential(v).split("e")[0], c = v) : (e[0] = e[0].split(".")[0] || 0, f = 20 > c ? (e[0] * Math.pow(10, e[1])).toFixed(c) : 0, e[1] = 0);
          }
          v = (Math.abs(e[1] ? e[0] : f) + Math.pow(10, -Math.max(c, a3) - 1)).toFixed(c);
          a3 = String(n(v));
          const z = 3 < a3.length ? a3.length % 3 : 0;
          g = p(g, k2.decimalPoint);
          h2 = p(h2, k2.thousandsSep);
          f = (0 > f ? "-" : "") + (z ? a3.substr(0, z) + h2 : "");
          f = 0 > +e[1] && !l ? "0" : f + a3.substr(z).replace(/(\d{3})(?=\d)/g, "$1" + h2);
          c && (f += g + v.slice(-c));
          e[1] && 0 !== +f && (f += "e" + e[1]);
          return f;
        }
        const { defaultOptions: y, defaultTime: A } = a2, { extend: F, getNestedProperty: D, isArray: t, isNumber: q, isObject: k, pick: p, pInt: n } = x, h = { add: (f, c) => f + c, divide: (f, c) => 0 !== c ? f / c : "", eq: (f, c) => f == c, each: function(f) {
          const c = arguments[arguments.length - 1];
          return t(f) ? f.map((g, h2) => r(c.body, F(k(g) ? g : { "@this": g }, { "@index": h2, "@first": 0 === h2, "@last": h2 === f.length - 1 }))).join("") : false;
        }, ge: (f, c) => f >= c, gt: (f, c) => f > c, "if": (f) => !!f, le: (f, c) => f <= c, lt: (f, c) => f < c, multiply: (f, c) => f * c, ne: (f, c) => f != c, subtract: (f, c) => f - c, unless: (f) => !f };
        return { dateFormat: function(f, c, g) {
          return A.dateFormat(f, c, g);
        }, format: r, helpers: h, numberFormat: I };
      });
      K(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function(a2) {
        const { clamp: r, pick: G, stableSort: I } = a2;
        var y;
        (function(a3) {
          function y2(a4, t, q) {
            const k = a4;
            var p = k.reducedLen || t, n = (c2, g2) => (g2.rank || 0) - (c2.rank || 0);
            const h = (c2, g2) => c2.target - g2.target;
            let f, c = true, g = [], B = 0;
            for (f = a4.length; f--; )
              B += a4[f].size;
            if (B > p) {
              I(a4, n);
              for (B = f = 0; B <= p; )
                B += a4[f].size, f++;
              g = a4.splice(f - 1, a4.length);
            }
            I(a4, h);
            for (a4 = a4.map((c2) => ({ size: c2.size, targets: [c2.target], align: G(c2.align, 0.5) })); c; ) {
              for (f = a4.length; f--; )
                p = a4[f], n = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = r(n - p.size * p.align, 0, t - p.size);
              f = a4.length;
              for (c = false; f--; )
                0 < f && a4[f - 1].pos + a4[f - 1].size > a4[f].pos && (a4[f - 1].size += a4[f].size, a4[f - 1].targets = a4[f - 1].targets.concat(a4[f].targets), a4[f - 1].align = 0.5, a4[f - 1].pos + a4[f - 1].size > t && (a4[f - 1].pos = t - a4[f - 1].size), a4.splice(f, 1), c = true);
            }
            k.push.apply(k, g);
            f = 0;
            a4.some((c2) => {
              let g2 = 0;
              return (c2.targets || []).some(() => {
                k[f].pos = c2.pos + g2;
                if ("undefined" !== typeof q && Math.abs(k[f].pos - k[f].target) > q)
                  return k.slice(0, f + 1).forEach((e) => delete e.pos), k.reducedLen = (k.reducedLen || t) - 0.1 * t, k.reducedLen > 0.1 * t && y2(k, t, q), true;
                g2 += k[f].size;
                f++;
                return false;
              });
            });
            I(k, h);
            return k;
          }
          a3.distribute = y2;
        })(y || (y = {}));
        return y;
      });
      K(a, "Core/Renderer/SVG/SVGElement.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I) {
        const { animate: r, animObject: A, stop: F } = a2, { deg2rad: D, doc: t, svg: q, SVG_NS: k, win: p } = G, { addEvent: n, attr: h, createElement: f, css: c, defined: g, erase: B, extend: C, fireEvent: E, isArray: e, isFunction: l, isObject: v, isString: z, merge: u, objectEach: b, pick: d, pInt: m, syncTimeout: w, uniqueKey: M } = I;
        class H {
          constructor() {
            this.element = void 0;
            this.onEvents = {};
            this.opacity = 1;
            this.renderer = void 0;
            this.SVG_NS = k;
          }
          _defaultGetter(b2) {
            b2 = d(this[b2 + "Value"], this[b2], this.element ? this.element.getAttribute(b2) : null, 0);
            /^[\-0-9\.]+$/.test(b2) && (b2 = parseFloat(b2));
            return b2;
          }
          _defaultSetter(b2, d2, e2) {
            e2.setAttribute(d2, b2);
          }
          add(b2) {
            const d2 = this.renderer, e2 = this.element;
            let c2;
            b2 && (this.parentGroup = b2);
            "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d2.buildText(this);
            this.added = true;
            if (!b2 || b2.handleZ || this.zIndex)
              c2 = this.zIndexSetter();
            c2 || (b2 ? b2.element : d2.box).appendChild(e2);
            if (this.onAdd)
              this.onAdd();
            return this;
          }
          addClass(b2, d2) {
            const e2 = d2 ? "" : this.attr("class") || "";
            b2 = (b2 || "").split(/ /g).reduce(function(b3, d3) {
              -1 === e2.indexOf(d3) && b3.push(d3);
              return b3;
            }, e2 ? [e2] : []).join(" ");
            b2 !== e2 && this.attr("class", b2);
            return this;
          }
          afterSetters() {
            this.doTransform && (this.updateTransform(), this.doTransform = false);
          }
          align(b2, e2, c2) {
            const m2 = {};
            var l2 = this.renderer, g2 = l2.alignedObjects, J;
            let f2, w2;
            if (b2) {
              if (this.alignOptions = b2, this.alignByTranslate = e2, !c2 || z(c2))
                this.alignTo = J = c2 || "renderer", B(g2, this), g2.push(this), c2 = void 0;
            } else
              b2 = this.alignOptions, e2 = this.alignByTranslate, J = this.alignTo;
            c2 = d(c2, l2[J], "scrollablePlotBox" === J ? l2.plotBox : void 0, l2);
            J = b2.align;
            const h2 = b2.verticalAlign;
            l2 = (c2.x || 0) + (b2.x || 0);
            g2 = (c2.y || 0) + (b2.y || 0);
            "right" === J ? f2 = 1 : "center" === J && (f2 = 2);
            f2 && (l2 += (c2.width - (b2.width || 0)) / f2);
            m2[e2 ? "translateX" : "x"] = Math.round(l2);
            "bottom" === h2 ? w2 = 1 : "middle" === h2 && (w2 = 2);
            w2 && (g2 += (c2.height - (b2.height || 0)) / w2);
            m2[e2 ? "translateY" : "y"] = Math.round(g2);
            this[this.placed ? "animate" : "attr"](m2);
            this.placed = true;
            this.alignAttr = m2;
            return this;
          }
          alignSetter(b2) {
            const d2 = { left: "start", center: "middle", right: "end" };
            d2[b2] && (this.alignValue = b2, this.element.setAttribute("text-anchor", d2[b2]));
          }
          animate(e2, c2, m2) {
            const l2 = A(d(c2, this.renderer.globalAnimation, true));
            c2 = l2.defer;
            t.hidden && (l2.duration = 0);
            0 !== l2.duration ? (m2 && (l2.complete = m2), w(() => {
              this.element && r(this, e2, l2);
            }, c2)) : (this.attr(e2, void 0, m2 || l2.complete), b(e2, function(b2, d2) {
              l2.step && l2.step.call(this, b2, { prop: d2, pos: 1, elem: this });
            }, this));
            return this;
          }
          applyTextOutline(b2) {
            const d2 = this.element;
            -1 !== b2.indexOf("contrast") && (b2 = b2.replace(/contrast/g, this.renderer.getContrast(d2.style.fill)));
            var e2 = b2.split(" ");
            b2 = e2[e2.length - 1];
            if ((e2 = e2[0]) && "none" !== e2 && G.svg) {
              this.fakeTS = true;
              e2 = e2.replace(/(^[\d\.]+)(.*?)$/g, function(b3, d3, e3) {
                return 2 * Number(d3) + e3;
              });
              this.removeTextOutline();
              const c2 = t.createElementNS(k, "tspan");
              h(c2, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": e2, "stroke-linejoin": "round" });
              b2 = d2.querySelector("textPath") || d2;
              [].forEach.call(b2.childNodes, (b3) => {
                const d3 = b3.cloneNode(true);
                d3.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((b4) => d3.removeAttribute(b4));
                c2.appendChild(d3);
              });
              let m2 = 0;
              [].forEach.call(b2.querySelectorAll("text tspan"), (b3) => {
                m2 += Number(b3.getAttribute("dy"));
              });
              e2 = t.createElementNS(k, "tspan");
              e2.textContent = "​";
              h(e2, { x: Number(d2.getAttribute("x")), dy: -m2 });
              c2.appendChild(e2);
              b2.insertBefore(c2, b2.firstChild);
            }
          }
          attr(d2, e2, c2, m2) {
            const l2 = this.element, g2 = H.symbolCustomAttribs;
            let J, f2, w2 = this, h2, u2;
            "string" === typeof d2 && "undefined" !== typeof e2 && (J = d2, d2 = {}, d2[J] = e2);
            "string" === typeof d2 ? w2 = (this[d2 + "Getter"] || this._defaultGetter).call(this, d2, l2) : (b(d2, function(b2, e3) {
              h2 = false;
              m2 || F(this, e3);
              this.symbolName && -1 !== g2.indexOf(e3) && (f2 || (this.symbolAttr(d2), f2 = true), h2 = true);
              !this.rotation || "x" !== e3 && "y" !== e3 || (this.doTransform = true);
              h2 || (u2 = this[e3 + "Setter"] || this._defaultSetter, u2.call(this, b2, e3, l2));
            }, this), this.afterSetters());
            c2 && c2.call(this);
            return w2;
          }
          clip(b2) {
            return this.attr("clip-path", b2 ? "url(" + this.renderer.url + "#" + b2.id + ")" : "none");
          }
          crisp(b2, d2) {
            d2 = d2 || b2.strokeWidth || 0;
            const e2 = Math.round(d2) % 2 / 2;
            b2.x = Math.floor(b2.x || this.x || 0) + e2;
            b2.y = Math.floor(b2.y || this.y || 0) + e2;
            b2.width = Math.floor((b2.width || this.width || 0) - 2 * e2);
            b2.height = Math.floor((b2.height || this.height || 0) - 2 * e2);
            g(b2.strokeWidth) && (b2.strokeWidth = d2);
            return b2;
          }
          complexColor(d2, c2, m2) {
            const l2 = this.renderer;
            let f2, w2, J, h2, z2, v2, k2, L, a3, n2, B2 = [], N;
            E(this.renderer, "complexColor", { args: arguments }, function() {
              d2.radialGradient ? w2 = "radialGradient" : d2.linearGradient && (w2 = "linearGradient");
              if (w2) {
                J = d2[w2];
                z2 = l2.gradients;
                v2 = d2.stops;
                a3 = m2.radialReference;
                e(J) && (d2[w2] = J = { x1: J[0], y1: J[1], x2: J[2], y2: J[3], gradientUnits: "userSpaceOnUse" });
                "radialGradient" === w2 && a3 && !g(J.gradientUnits) && (h2 = J, J = u(J, l2.getRadialAttr(a3, h2), { gradientUnits: "userSpaceOnUse" }));
                b(J, function(b2, d3) {
                  "id" !== d3 && B2.push(d3, b2);
                });
                b(v2, function(b2) {
                  B2.push(b2);
                });
                B2 = B2.join(",");
                if (z2[B2])
                  n2 = z2[B2].attr("id");
                else {
                  J.id = n2 = M();
                  const b2 = z2[B2] = l2.createElement(w2).attr(J).add(l2.defs);
                  b2.radAttr = h2;
                  b2.stops = [];
                  v2.forEach(function(d3) {
                    0 === d3[1].indexOf("rgba") ? (f2 = x.parse(d3[1]), k2 = f2.get("rgb"), L = f2.get("a")) : (k2 = d3[1], L = 1);
                    d3 = l2.createElement("stop").attr({ offset: d3[0], "stop-color": k2, "stop-opacity": L }).add(b2);
                    b2.stops.push(d3);
                  });
                }
                N = "url(" + l2.url + "#" + n2 + ")";
                m2.setAttribute(c2, N);
                m2.gradient = B2;
                d2.toString = function() {
                  return N;
                };
              }
            });
          }
          css(d2) {
            const e2 = this.styles, l2 = {}, g2 = this.element;
            let f2, w2 = !e2;
            e2 && b(d2, function(b2, d3) {
              e2 && e2[d3] !== b2 && (l2[d3] = b2, w2 = true);
            });
            if (w2) {
              e2 && (d2 = C(e2, l2));
              null === d2.width || "auto" === d2.width ? delete this.textWidth : "text" === g2.nodeName.toLowerCase() && d2.width && (f2 = this.textWidth = m(d2.width));
              this.styles = d2;
              f2 && !q && this.renderer.forExport && delete d2.width;
              const b2 = u(d2);
              g2.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach((d3) => b2 && delete b2[d3]), b2.color && (b2.fill = b2.color));
              c(g2, b2);
            }
            this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), d2.textOutline && this.applyTextOutline(d2.textOutline));
            return this;
          }
          dashstyleSetter(b2) {
            let e2 = this["stroke-width"];
            "inherit" === e2 && (e2 = 1);
            if (b2 = b2 && b2.toLowerCase()) {
              const c2 = b2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
              for (b2 = c2.length; b2--; )
                c2[b2] = "" + m(c2[b2]) * d(e2, NaN);
              b2 = c2.join(",").replace(/NaN/g, "none");
              this.element.setAttribute(
                "stroke-dasharray",
                b2
              );
            }
          }
          destroy() {
            const d2 = this;
            var e2 = d2.element || {};
            const c2 = d2.renderer;
            var m2 = e2.ownerSVGElement;
            let l2 = "SPAN" === e2.nodeName && d2.parentGroup || void 0;
            e2.onclick = e2.onmouseout = e2.onmouseover = e2.onmousemove = e2.point = null;
            F(d2);
            if (d2.clipPath && m2) {
              const b2 = d2.clipPath;
              [].forEach.call(m2.querySelectorAll("[clip-path],[CLIP-PATH]"), function(d3) {
                -1 < d3.getAttribute("clip-path").indexOf(b2.element.id) && d3.removeAttribute("clip-path");
              });
              d2.clipPath = b2.destroy();
            }
            if (d2.stops) {
              for (m2 = 0; m2 < d2.stops.length; m2++)
                d2.stops[m2].destroy();
              d2.stops.length = 0;
              d2.stops = void 0;
            }
            for (d2.safeRemoveChild(e2); l2 && l2.div && 0 === l2.div.childNodes.length; )
              e2 = l2.parentGroup, d2.safeRemoveChild(l2.div), delete l2.div, l2 = e2;
            d2.alignTo && B(c2.alignedObjects, d2);
            b(d2, function(b2, e3) {
              d2[e3] && d2[e3].parentGroup === d2 && d2[e3].destroy && d2[e3].destroy();
              delete d2[e3];
            });
          }
          dSetter(b2, d2, c2) {
            e(b2) && ("string" === typeof b2[0] && (b2 = this.renderer.pathToSegments(b2)), this.pathArray = b2, b2 = b2.reduce((b3, d3, e2) => d3 && d3.join ? (e2 ? b3 + " " : "") + d3.join(" ") : (d3 || "").toString(), ""));
            /(NaN| {2}|^$)/.test(b2) && (b2 = "M 0 0");
            this[d2] !== b2 && (c2.setAttribute(
              d2,
              b2
            ), this[d2] = b2);
          }
          fadeOut(b2) {
            const e2 = this;
            e2.animate({ opacity: 0 }, { duration: d(b2, 150), complete: function() {
              e2.hide();
            } });
          }
          fillSetter(b2, d2, e2) {
            "string" === typeof b2 ? e2.setAttribute(d2, b2) : b2 && this.complexColor(b2, d2, e2);
          }
          getBBox(b2, e2) {
            const { alignValue: m2, element: f2, renderer: w2, styles: h2, textStr: J } = this, { cache: z2, cacheKeys: u2 } = w2;
            var v2 = f2.namespaceURI === this.SVG_NS;
            e2 = d(e2, this.rotation, 0);
            var k2 = w2.styledMode ? f2 && H.prototype.getStyle.call(f2, "font-size") : h2 && h2.fontSize;
            let L;
            let a3;
            g(J) && (a3 = J.toString(), -1 === a3.indexOf("<") && (a3 = a3.replace(
              /[0-9]/g,
              "0"
            )), a3 += ["", w2.rootFontSize, k2, e2, this.textWidth, m2, h2 && h2.textOverflow, h2 && h2.fontWeight].join());
            a3 && !b2 && (L = z2[a3]);
            if (!L) {
              if (v2 || w2.forExport) {
                try {
                  var B2 = this.fakeTS && function(b3) {
                    const d2 = f2.querySelector(".highcharts-text-outline");
                    d2 && c(d2, { display: b3 });
                  };
                  l(B2) && B2("none");
                  L = f2.getBBox ? C({}, f2.getBBox()) : { width: f2.offsetWidth, height: f2.offsetHeight, x: 0, y: 0 };
                  l(B2) && B2("");
                } catch (aa) {
                  "";
                }
                if (!L || 0 > L.width)
                  L = { x: 0, y: 0, width: 0, height: 0 };
              } else
                L = this.htmlGetBBox();
              B2 = L.width;
              b2 = L.height;
              v2 && (L.height = b2 = { "11px,17": 14, "13px,20": 16 }[`${k2 || ""},${Math.round(b2)}`] || b2);
              if (e2) {
                v2 = Number(f2.getAttribute("y") || 0) - L.y;
                k2 = { right: 1, center: 0.5 }[m2 || 0] || 0;
                var n2 = e2 * D, q2 = (e2 - 90) * D, E2 = B2 * Math.cos(n2);
                e2 = B2 * Math.sin(n2);
                var M2 = Math.cos(q2);
                n2 = Math.sin(q2);
                B2 = L.x + k2 * (B2 - E2) + v2 * M2;
                q2 = B2 + E2;
                M2 = q2 - b2 * M2;
                E2 = M2 - E2;
                v2 = L.y + v2 - k2 * e2 + v2 * n2;
                k2 = v2 + e2;
                b2 = k2 - b2 * n2;
                e2 = b2 - e2;
                L.x = Math.min(B2, q2, M2, E2);
                L.y = Math.min(v2, k2, b2, e2);
                L.width = Math.max(B2, q2, M2, E2) - L.x;
                L.height = Math.max(v2, k2, b2, e2) - L.y;
              }
            }
            if (a3 && ("" === J || 0 < L.height)) {
              for (; 250 < u2.length; )
                delete z2[u2.shift()];
              z2[a3] || u2.push(a3);
              z2[a3] = L;
            }
            return L;
          }
          getStyle(b2) {
            return p.getComputedStyle(this.element || this, "").getPropertyValue(b2);
          }
          hasClass(b2) {
            return -1 !== ("" + this.attr("class")).split(" ").indexOf(b2);
          }
          hide() {
            return this.attr({ visibility: "hidden" });
          }
          htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
          }
          init(b2, d2) {
            this.element = "span" === d2 ? f(d2) : t.createElementNS(this.SVG_NS, d2);
            this.renderer = b2;
            E(this, "afterInit");
          }
          on(b2, d2) {
            const { onEvents: e2 } = this;
            if (e2[b2])
              e2[b2]();
            e2[b2] = n(this.element, b2, d2);
            return this;
          }
          opacitySetter(b2, d2, e2) {
            this.opacity = b2 = Number(Number(b2).toFixed(3));
            e2.setAttribute(d2, b2);
          }
          removeClass(b2) {
            return this.attr(
              "class",
              ("" + this.attr("class")).replace(z(b2) ? new RegExp(`(^| )${b2}( |$)`) : b2, " ").replace(/ +/g, " ").trim()
            );
          }
          removeTextOutline() {
            const b2 = this.element.querySelector("tspan.highcharts-text-outline");
            b2 && this.safeRemoveChild(b2);
          }
          safeRemoveChild(b2) {
            const d2 = b2.parentNode;
            d2 && d2.removeChild(b2);
          }
          setRadialReference(b2) {
            const d2 = this.element.gradient && this.renderer.gradients[this.element.gradient];
            this.element.radialReference = b2;
            d2 && d2.radAttr && d2.animate(this.renderer.getRadialAttr(b2, d2.radAttr));
            return this;
          }
          setTextPath(b2, d2) {
            d2 = u(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, d2);
            const e2 = this.renderer.url, c2 = this.text || this, m2 = c2.textPath, { attributes: l2, enabled: f2 } = d2;
            b2 = b2 || m2 && m2.path;
            m2 && m2.undo();
            b2 && f2 ? (d2 = n(c2, "afterModifyTree", (d3) => {
              if (b2 && f2) {
                let f3 = b2.attr("id");
                f3 || b2.attr("id", f3 = M());
                var m3 = { x: 0, y: 0 };
                g(l2.dx) && (m3.dx = l2.dx, delete l2.dx);
                g(l2.dy) && (m3.dy = l2.dy, delete l2.dy);
                c2.attr(m3);
                this.attr({ transform: "" });
                this.box && (this.box = this.box.destroy());
                m3 = d3.nodes.slice(0);
                d3.nodes.length = 0;
                d3.nodes[0] = { tagName: "textPath", attributes: C(
                  l2,
                  { "text-anchor": l2.textAnchor, href: `${e2}#${f3}` }
                ), children: m3 };
              }
            }), c2.textPath = { path: b2, undo: d2 }) : (c2.attr({ dx: 0, dy: 0 }), delete c2.textPath);
            this.added && (c2.textCache = "", this.renderer.buildText(c2));
            return this;
          }
          shadow(b2) {
            var d2;
            const { renderer: e2 } = this, c2 = u(90 === (null === (d2 = this.parentGroup) || void 0 === d2 ? void 0 : d2.rotation) ? { offsetX: -1, offsetY: -1 } : {}, v(b2) ? b2 : {});
            d2 = e2.shadowDefinition(c2);
            return this.attr({ filter: b2 ? `url(${e2.url}#${d2})` : "none" });
          }
          show(b2 = true) {
            return this.attr({ visibility: b2 ? "inherit" : "visible" });
          }
          ["stroke-widthSetter"](b2, d2, e2) {
            this[d2] = b2;
            e2.setAttribute(d2, b2);
          }
          strokeWidth() {
            if (!this.renderer.styledMode)
              return this["stroke-width"] || 0;
            const b2 = this.getStyle("stroke-width");
            let d2 = 0, e2;
            b2.indexOf("px") === b2.length - 2 ? d2 = m(b2) : "" !== b2 && (e2 = t.createElementNS(k, "rect"), h(e2, { width: b2, "stroke-width": 0 }), this.element.parentNode.appendChild(e2), d2 = e2.getBBox().width, e2.parentNode.removeChild(e2));
            return d2;
          }
          symbolAttr(b2) {
            const e2 = this;
            H.symbolCustomAttribs.forEach(function(c2) {
              e2[c2] = d(b2[c2], e2[c2]);
            });
            e2.attr({ d: e2.renderer.symbols[e2.symbolName](
              e2.x,
              e2.y,
              e2.width,
              e2.height,
              e2
            ) });
          }
          textSetter(b2) {
            b2 !== this.textStr && (delete this.textPxLength, this.textStr = b2, this.added && this.renderer.buildText(this));
          }
          titleSetter(b2) {
            const e2 = this.element, c2 = e2.getElementsByTagName("title")[0] || t.createElementNS(this.SVG_NS, "title");
            e2.insertBefore ? e2.insertBefore(c2, e2.firstChild) : e2.appendChild(c2);
            c2.textContent = String(d(b2, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
          }
          toFront() {
            const b2 = this.element;
            b2.parentNode.appendChild(b2);
            return this;
          }
          translate(b2, d2) {
            return this.attr({
              translateX: b2,
              translateY: d2
            });
          }
          updateTransform() {
            const { element: b2, matrix: e2, rotation: c2 = 0, scaleX: m2, scaleY: l2, translateX: f2 = 0, translateY: J = 0 } = this, w2 = ["translate(" + f2 + "," + J + ")"];
            g(e2) && w2.push("matrix(" + e2.join(",") + ")");
            c2 && w2.push("rotate(" + c2 + " " + d(this.rotationOriginX, b2.getAttribute("x"), 0) + " " + d(this.rotationOriginY, b2.getAttribute("y") || 0) + ")");
            (g(m2) || g(l2)) && w2.push("scale(" + d(m2, 1) + " " + d(l2, 1) + ")");
            w2.length && !(this.text || this).textPath && b2.setAttribute("transform", w2.join(" "));
          }
          visibilitySetter(b2, d2, e2) {
            "inherit" === b2 ? e2.removeAttribute(d2) : this[d2] !== b2 && e2.setAttribute(d2, b2);
            this[d2] = b2;
          }
          xGetter(b2) {
            "circle" === this.element.nodeName && ("x" === b2 ? b2 = "cx" : "y" === b2 && (b2 = "cy"));
            return this._defaultGetter(b2);
          }
          zIndexSetter(b2, d2) {
            var e2 = this.renderer, c2 = this.parentGroup;
            const l2 = (c2 || e2).element || e2.box, f2 = this.element;
            e2 = l2 === e2.box;
            let w2 = false, h2;
            var z2 = this.added;
            let u2;
            g(b2) ? (f2.setAttribute("data-z-index", b2), b2 = +b2, this[d2] === b2 && (z2 = false)) : g(this[d2]) && f2.removeAttribute("data-z-index");
            this[d2] = b2;
            if (z2) {
              (b2 = this.zIndex) && c2 && (c2.handleZ = true);
              d2 = l2.childNodes;
              for (u2 = d2.length - 1; 0 <= u2 && !w2; u2--)
                if (c2 = d2[u2], z2 = c2.getAttribute("data-z-index"), h2 = !g(z2), c2 !== f2) {
                  if (0 > b2 && h2 && !e2 && !u2)
                    l2.insertBefore(f2, d2[u2]), w2 = true;
                  else if (m(z2) <= b2 || h2 && (!g(b2) || 0 <= b2))
                    l2.insertBefore(f2, d2[u2 + 1]), w2 = true;
                }
              w2 || (l2.insertBefore(f2, d2[e2 ? 3 : 0]), w2 = true);
            }
            return w2;
          }
        }
        H.symbolCustomAttribs = "anchorX anchorY clockwise end height innerR r start width x y".split(" ");
        H.prototype.strokeSetter = H.prototype.fillSetter;
        H.prototype.yGetter = H.prototype.xGetter;
        H.prototype.matrixSetter = H.prototype.rotationOriginXSetter = H.prototype.rotationOriginYSetter = H.prototype.rotationSetter = H.prototype.scaleXSetter = H.prototype.scaleYSetter = H.prototype.translateXSetter = H.prototype.translateYSetter = H.prototype.verticalAlignSetter = function(b2, d2) {
          this[d2] = b2;
          this.doTransform = true;
        };
        "";
        return H;
      });
      K(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function(a2) {
        var r;
        (function(r2) {
          r2.rendererTypes = {};
          let x;
          r2.getRendererType = function(a3 = x) {
            return r2.rendererTypes[a3] || r2.rendererTypes[x];
          };
          r2.registerRendererType = function(y, A, F) {
            r2.rendererTypes[y] = A;
            if (!x || F)
              x = y, a2.Renderer = A;
          };
        })(r || (r = {}));
        return r;
      });
      K(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { defined: r, extend: I, isNumber: y, merge: A, pick: F, removeEvent: D } = x;
        class t extends a2 {
          constructor(a3, k, p, n, h, f, c, g, B, C) {
            super();
            this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;
            this.init(a3, "g");
            this.textStr = k;
            this.x = p;
            this.y = n;
            this.anchorX = f;
            this.anchorY = c;
            this.baseline = B;
            this.className = C;
            this.addClass("button" === C ? "highcharts-no-tooltip" : "highcharts-label");
            C && this.addClass("highcharts-" + C);
            this.text = a3.text(void 0, 0, 0, g).attr({ zIndex: 1 });
            let q;
            "string" === typeof h && ((q = /^url\((.*?)\)$/.test(h)) || this.renderer.symbols[h]) && (this.symbolKey = h);
            this.bBox = t.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = a3.styledMode || q;
            this.deferredAttr = {};
            this.alignFactor = 0;
          }
          alignSetter(a3) {
            a3 = { left: 0, center: 0.5, right: 1 }[a3];
            a3 !== this.alignFactor && (this.alignFactor = a3, this.bBox && y(this.xSetting) && this.attr({ x: this.xSetting }));
          }
          anchorXSetter(a3, k) {
            this.anchorX = a3;
            this.boxAttr(k, Math.round(a3) - this.getCrispAdjust() - this.xSetting);
          }
          anchorYSetter(a3, k) {
            this.anchorY = a3;
            this.boxAttr(k, a3 - this.ySetting);
          }
          boxAttr(a3, k) {
            this.box ? this.box.attr(a3, k) : this.deferredAttr[a3] = k;
          }
          css(q) {
            if (q) {
              const a3 = {};
              q = A(q);
              t.textProps.forEach((k) => {
                "undefined" !== typeof q[k] && (a3[k] = q[k], delete q[k]);
              });
              this.text.css(a3);
              "fontSize" in a3 || "fontWeight" in a3 ? this.updateTextPadding() : ("width" in a3 || "textOverflow" in a3) && this.updateBoxSize();
            }
            return a2.prototype.css.call(this, q);
          }
          destroy() {
            D(this.element, "mouseenter");
            D(this.element, "mouseleave");
            this.text && this.text.destroy();
            this.box && (this.box = this.box.destroy());
            a2.prototype.destroy.call(this);
          }
          fillSetter(a3, k) {
            a3 && (this.needsBox = true);
            this.fill = a3;
            this.boxAttr(k, a3);
          }
          getBBox() {
            this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
            const a3 = this.padding, k = F(this.paddingLeft, a3);
            return { width: this.width, height: this.height, x: this.bBox.x - k, y: this.bBox.y - a3 };
          }
          getCrispAdjust() {
            return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          }
          heightSetter(a3) {
            this.heightSetting = a3;
          }
          onAdd() {
            this.text.add(this);
            this.attr({ text: F(this.textStr, ""), x: this.x || 0, y: this.y || 0 });
            this.box && r(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
          }
          paddingSetter(a3, k) {
            y(a3) ? a3 !== this[k] && (this[k] = a3, this.updateTextPadding()) : this[k] = void 0;
          }
          rSetter(a3, k) {
            this.boxAttr(k, a3);
          }
          strokeSetter(a3, k) {
            this.stroke = a3;
            this.boxAttr(k, a3);
          }
          ["stroke-widthSetter"](a3, k) {
            a3 && (this.needsBox = true);
            this["stroke-width"] = a3;
            this.boxAttr(k, a3);
          }
          ["text-alignSetter"](a3) {
            this.textAlign = a3;
          }
          textSetter(a3) {
            "undefined" !== typeof a3 && this.text.attr({ text: a3 });
            this.updateTextPadding();
          }
          updateBoxSize() {
            var a3 = this.text;
            const k = {}, p = this.padding, n = this.bBox = y(this.widthSetting) && y(this.heightSetting) && !this.textAlign || !r(a3.textStr) ? t.emptyBBox : a3.getBBox();
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || n.height || 0) + 2 * p;
            const h = this.renderer.fontMetrics(a3);
            this.baselineOffset = p + Math.min((this.text.firstLineMetrics || h).b, n.height || Infinity);
            this.heightSetting && (this.baselineOffset += (this.heightSetting - h.h) / 2);
            this.needsBox && !a3.textPath && (this.box || (a3 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a3.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a3.add(this)), a3 = this.getCrispAdjust(), k.x = a3, k.y = (this.baseline ? -this.baselineOffset : 0) + a3, k.width = Math.round(this.width), k.height = Math.round(this.height), this.box.attr(I(k, this.deferredAttr)), this.deferredAttr = {});
          }
          updateTextPadding() {
            const a3 = this.text;
            if (!a3.textPath) {
              this.updateBoxSize();
              const k = this.baseline ? 0 : this.baselineOffset;
              let p = F(this.paddingLeft, this.padding);
              r(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (p += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (p !== a3.x || k !== a3.y)
                a3.attr("x", p), a3.hasBoxWidthChanged && (this.bBox = a3.getBBox(true)), "undefined" !== typeof k && a3.attr("y", k);
              a3.x = p;
              a3.y = k;
            }
          }
          widthSetter(a3) {
            this.widthSetting = y(a3) ? a3 : void 0;
          }
          getPaddedWidth() {
            var a3 = this.padding;
            const k = F(this.paddingLeft, a3);
            a3 = F(
              this.paddingRight,
              a3
            );
            return (this.widthSetting || this.bBox.width || 0) + k + a3;
          }
          xSetter(a3) {
            this.x = a3;
            this.alignFactor && (a3 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true);
            this.xSetting = Math.round(a3);
            this.attr("translateX", this.xSetting);
          }
          ySetter(a3) {
            this.ySetting = this.y = Math.round(a3);
            this.attr("translateY", this.ySetting);
          }
        }
        t.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        t.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(" ");
        return t;
      });
      K(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function(a2) {
        function r(a3, t, q, k, p) {
          const n = [];
          if (p) {
            const h = p.start || 0, f = F(p.r, q);
            q = F(p.r, k || q);
            k = (p.end || 0) - 1e-3;
            const c = p.innerR, g = F(p.open, 1e-3 > Math.abs((p.end || 0) - h - 2 * Math.PI)), B = Math.cos(h), C = Math.sin(h), E = Math.cos(k), e = Math.sin(k), l = F(p.longArc, 1e-3 > k - h - Math.PI ? 0 : 1);
            let v = ["A", f, q, 0, l, F(p.clockwise, 1), a3 + f * E, t + q * e];
            v.params = { start: h, end: k, cx: a3, cy: t };
            n.push(["M", a3 + f * B, t + q * C], v);
            y(c) && (v = ["A", c, c, 0, l, y(p.clockwise) ? 1 - p.clockwise : 0, a3 + c * B, t + c * C], v.params = { start: k, end: h, cx: a3, cy: t }, n.push(g ? ["M", a3 + c * E, t + c * e] : ["L", a3 + c * E, t + c * e], v));
            g || n.push(["Z"]);
          }
          return n;
        }
        function G(a3, t, q, k, p) {
          return p && p.r ? I(a3, t, q, k, p) : [["M", a3, t], ["L", a3 + q, t], ["L", a3 + q, t + k], ["L", a3, t + k], ["Z"]];
        }
        function I(a3, t, q, k, p) {
          p = (null === p || void 0 === p ? void 0 : p.r) || 0;
          return [["M", a3 + p, t], ["L", a3 + q - p, t], ["A", p, p, 0, 0, 1, a3 + q, t + p], ["L", a3 + q, t + k - p], ["A", p, p, 0, 0, 1, a3 + q - p, t + k], ["L", a3 + p, t + k], ["A", p, p, 0, 0, 1, a3, t + k - p], ["L", a3, t + p], ["A", p, p, 0, 0, 1, a3 + p, t], ["Z"]];
        }
        const { defined: y, isNumber: A, pick: F } = a2;
        return { arc: r, callout: function(a3, t, q, k, p) {
          const n = Math.min(p && p.r || 0, q, k), h = n + 6, f = p && p.anchorX;
          p = p && p.anchorY || 0;
          const c = I(a3, t, q, k, { r: n });
          if (!A(f))
            return c;
          a3 + f >= q ? p > t + h && p < t + k - h ? c.splice(3, 1, ["L", a3 + q, p - 6], ["L", a3 + q + 6, p], ["L", a3 + q, p + 6], ["L", a3 + q, t + k - n]) : c.splice(3, 1, ["L", a3 + q, k / 2], ["L", f, p], ["L", a3 + q, k / 2], ["L", a3 + q, t + k - n]) : 0 >= a3 + f ? p > t + h && p < t + k - h ? c.splice(7, 1, ["L", a3, p + 6], ["L", a3 - 6, p], ["L", a3, p - 6], ["L", a3, t + n]) : c.splice(7, 1, ["L", a3, k / 2], ["L", f, p], ["L", a3, k / 2], ["L", a3, t + n]) : p && p > k && f > a3 + h && f < a3 + q - h ? c.splice(5, 1, [
            "L",
            f + 6,
            t + k
          ], ["L", f, t + k + 6], ["L", f - 6, t + k], ["L", a3 + n, t + k]) : p && 0 > p && f > a3 + h && f < a3 + q - h && c.splice(1, 1, ["L", f - 6, t], ["L", f, t - 6], ["L", f + 6, t], ["L", q - n, t]);
          return c;
        }, circle: function(a3, t, q, k) {
          return r(a3 + q / 2, t + k / 2, q / 2, k / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
        }, diamond: function(a3, t, q, k) {
          return [["M", a3 + q / 2, t], ["L", a3 + q, t + k / 2], ["L", a3 + q / 2, t + k], ["L", a3, t + k / 2], ["Z"]];
        }, rect: G, roundedRect: I, square: G, triangle: function(a3, t, q, k) {
          return [["M", a3 + q / 2, t], ["L", a3 + q, t + k], ["L", a3, t + k], ["Z"]];
        }, "triangle-down": function(a3, t, q, k) {
          return [[
            "M",
            a3,
            t
          ], ["L", a3 + q, t], ["L", a3 + q / 2, t + k], ["Z"]];
        } };
      });
      K(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { doc: r, SVG_NS: y, win: A } = x, { attr: F, extend: D, fireEvent: t, isString: q, objectEach: k, pick: p } = G;
        class n {
          constructor(a3) {
            const f = a3.styles;
            this.renderer = a3.renderer;
            this.svgElement = a3;
            this.width = a3.textWidth;
            this.textLineHeight = f && f.lineHeight;
            this.textOutline = f && f.textOutline;
            this.ellipsis = !(!f || "ellipsis" !== f.textOverflow);
            this.noWrap = !(!f || "nowrap" !== f.whiteSpace);
          }
          buildSVG() {
            const h = this.svgElement, f = h.element;
            var c = h.renderer, g = p(h.textStr, "").toString();
            const k2 = -1 !== g.indexOf("<"), n2 = f.childNodes;
            c = !h.added && c.box;
            const E = /<br.*?>/g;
            var e = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, h.getStyle("font-size"), this.width].join();
            if (e !== h.textCache) {
              h.textCache = e;
              delete h.actualWidth;
              for (e = n2.length; e--; )
                f.removeChild(n2[e]);
              k2 || this.ellipsis || this.width || h.textPath || -1 !== g.indexOf(" ") && (!this.noWrap || E.test(g)) ? "" !== g && (c && c.appendChild(f), g = new a2(g), this.modifyTree(g.nodes), g.addToDOM(f), this.modifyDOM(), this.ellipsis && -1 !== (f.textContent || "").indexOf("…") && h.attr("title", this.unescapeEntities(h.textStr || "", ["&lt;", "&gt;"])), c && c.removeChild(f)) : f.appendChild(r.createTextNode(this.unescapeEntities(g)));
              q(this.textOutline) && h.applyTextOutline && h.applyTextOutline(this.textOutline);
            }
          }
          modifyDOM() {
            const a3 = this.svgElement, f = F(a3.element, "x");
            a3.firstLineMetrics = void 0;
            let c;
            for (; c = a3.element.firstChild; )
              if (/^[\s\u200B]*$/.test(c.textContent || " "))
                a3.element.removeChild(c);
              else
                break;
            [].forEach.call(a3.element.querySelectorAll("tspan.highcharts-br"), (c2, e) => {
              c2.nextSibling && c2.previousSibling && (0 === e && 1 === c2.previousSibling.nodeType && (a3.firstLineMetrics = a3.renderer.fontMetrics(c2.previousSibling)), F(c2, { dy: this.getLineHeight(c2.nextSibling), x: f }));
            });
            const g = this.width || 0;
            if (g) {
              var k2 = (c2, e) => {
                var l = c2.textContent || "";
                const h = l.replace(/([^\^])-/g, "$1- ").split(" ");
                var z = !this.noWrap && (1 < h.length || 1 < a3.element.childNodes.length);
                const u = this.getLineHeight(e);
                let b = 0, d = a3.actualWidth;
                if (this.ellipsis)
                  l && this.truncate(c2, l, void 0, 0, Math.max(0, g - 0.8 * u), (b2, d2) => b2.substring(0, d2) + "…");
                else if (z) {
                  l = [];
                  for (z = []; e.firstChild && e.firstChild !== c2; )
                    z.push(e.firstChild), e.removeChild(e.firstChild);
                  for (; h.length; )
                    h.length && !this.noWrap && 0 < b && (l.push(c2.textContent || ""), c2.textContent = h.join(" ").replace(/- /g, "-")), this.truncate(c2, void 0, h, 0 === b ? d || 0 : 0, g, (b2, d2) => h.slice(0, d2).join(" ").replace(/- /g, "-")), d = a3.actualWidth, b++;
                  z.forEach((b2) => {
                    e.insertBefore(b2, c2);
                  });
                  l.forEach((b2) => {
                    e.insertBefore(r.createTextNode(b2), c2);
                    b2 = r.createElementNS(y, "tspan");
                    b2.textContent = "​";
                    F(b2, { dy: u, x: f });
                    e.insertBefore(b2, c2);
                  });
                }
              }, n2 = (c2) => {
                [].slice.call(c2.childNodes).forEach((e) => {
                  e.nodeType === A.Node.TEXT_NODE ? k2(e, c2) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (a3.actualWidth = 0), n2(e));
                });
              };
              n2(a3.element);
            }
          }
          getLineHeight(a3) {
            a3 = a3.nodeType === A.Node.TEXT_NODE ? a3.parentElement : a3;
            return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a3 || this.svgElement.element).h;
          }
          modifyTree(a3) {
            const f = (c, g) => {
              const { attributes: h = {}, children: k2, style: n2 = {}, tagName: e } = c, l = this.renderer.styledMode;
              if ("b" === e || "strong" === e)
                l ? h["class"] = "highcharts-strong" : n2.fontWeight = "bold";
              else if ("i" === e || "em" === e)
                l ? h["class"] = "highcharts-emphasized" : n2.fontStyle = "italic";
              n2 && n2.color && (n2.fill = n2.color);
              "br" === e ? (h["class"] = "highcharts-br", c.textContent = "​", (g = a3[g + 1]) && g.textContent && (g.textContent = g.textContent.replace(/^ +/gm, ""))) : "a" === e && k2 && k2.some((e2) => "#text" === e2.tagName) && (c.children = [{ children: k2, tagName: "tspan" }]);
              "#text" !== e && "a" !== e && (c.tagName = "tspan");
              D(c, { attributes: h, style: n2 });
              k2 && k2.filter((e2) => "#text" !== e2.tagName).forEach(f);
            };
            a3.forEach(f);
            t(this.svgElement, "afterModifyTree", { nodes: a3 });
          }
          truncate(a3, f, c, g, k2, n2) {
            const h = this.svgElement, { rotation: e } = h, l = [];
            let v = c ? 1 : 0, z = (f || c || "").length, u = z, b, d;
            const m = function(b2, d2) {
              b2 = d2 || b2;
              if ((d2 = a3.parentNode) && "undefined" === typeof l[b2] && d2.getSubStringLength)
                try {
                  l[b2] = g + d2.getSubStringLength(0, c ? b2 + 1 : b2);
                } catch (H) {
                  "";
                }
              return l[b2];
            };
            h.rotation = 0;
            d = m(a3.textContent.length);
            if (g + d > k2) {
              for (; v <= z; )
                u = Math.ceil((v + z) / 2), c && (b = n2(c, u)), d = m(u, b && b.length - 1), v === z ? v = z + 1 : d > k2 ? z = u - 1 : v = u;
              0 === z ? a3.textContent = "" : f && z === f.length - 1 || (a3.textContent = b || n2(f || c, u));
            }
            c && c.splice(0, u);
            h.actualWidth = d;
            h.rotation = e;
          }
          unescapeEntities(a3, f) {
            k(this.renderer.escapes, function(c, g) {
              f && -1 !== f.indexOf(c) || (a3 = a3.toString().replace(new RegExp(c, "g"), g));
            });
            return a3;
          }
        }
        return n;
      });
      K(a, "Core/Renderer/SVG/SVGRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGLabel.js"],
        a["Core/Renderer/SVG/Symbols.js"],
        a["Core/Renderer/SVG/TextBuilder.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y, A, F, D, t) {
        const { charts: q, deg2rad: k, doc: p, isFirefox: n, isMS: h, isWebKit: f, noop: c, SVG_NS: g, symbolSizes: B, win: C } = G, { addEvent: E, attr: e, createElement: l, css: v, defined: z, destroyObjectProperties: u, extend: b, isArray: d, isNumber: m, isObject: w, isString: M, merge: H, pick: N, pInt: r, uniqueKey: P } = t;
        let Y;
        class R {
          constructor(b2, d2, e2, c2, m2, l2, a3) {
            this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
            this.init(b2, d2, e2, c2, m2, l2, a3);
          }
          init(b2, d2, c2, m2, l2, a3, g2) {
            const f2 = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }), w2 = f2.element;
            g2 || f2.css(this.getStyle(m2));
            b2.appendChild(w2);
            e(b2, "dir", "ltr");
            -1 === b2.innerHTML.indexOf("xmlns") && e(w2, "xmlns", this.SVG_NS);
            this.box = w2;
            this.boxWrapper = f2;
            this.alignedObjects = [];
            this.url = this.getReferenceURL();
            this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 11.1.0"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = a3;
            this.forExport = l2;
            this.styledMode = g2;
            this.gradients = {};
            this.cache = {};
            this.cacheKeys = [];
            this.imgCount = 0;
            this.rootFontSize = f2.getStyle("font-size");
            this.setSize(d2, c2, false);
            let J;
            n && b2.getBoundingClientRect && (d2 = function() {
              v(b2, { left: 0, top: 0 });
              J = b2.getBoundingClientRect();
              v(b2, { left: Math.ceil(J.left) - J.left + "px", top: Math.ceil(J.top) - J.top + "px" });
            }, d2(), this.unSubPixelFix = E(C, "resize", d2));
          }
          definition(b2) {
            return new a2([b2]).addToDOM(this.defs.element);
          }
          getReferenceURL() {
            if ((n || f) && p.getElementsByTagName("base").length) {
              if (!z(Y)) {
                var b2 = P();
                b2 = new a2([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: b2 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${b2})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(p.body);
                v(b2, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                const d2 = p.elementFromPoint(6, 6);
                Y = "hitme" === (d2 && d2.id);
                p.body.removeChild(b2);
              }
              if (Y)
                return C.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
            }
            return "";
          }
          getStyle(d2) {
            return this.style = b({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, d2);
          }
          setStyle(b2) {
            this.boxWrapper.css(this.getStyle(b2));
          }
          isHidden() {
            return !this.boxWrapper.getBBox().width;
          }
          destroy() {
            const b2 = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            u(this.gradients || {});
            this.gradients = null;
            this.defs = b2.destroy();
            this.unSubPixelFix && this.unSubPixelFix();
            return this.alignedObjects = null;
          }
          createElement(b2) {
            const d2 = new this.Element();
            d2.init(this, b2);
            return d2;
          }
          getRadialAttr(b2, d2) {
            return { cx: b2[0] - b2[2] / 2 + (d2.cx || 0) * b2[2], cy: b2[1] - b2[2] / 2 + (d2.cy || 0) * b2[2], r: (d2.r || 0) * b2[2] };
          }
          shadowDefinition(b2) {
            const d2 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b2).map((d3) => b2[d3])].join("-").replace(/[^a-z0-9\-]/g, ""), e2 = H({
              color: "#000000",
              offsetX: 1,
              offsetY: 1,
              opacity: 0.15,
              width: 5
            }, b2);
            this.defs.element.querySelector(`#${d2}`) || this.definition({ tagName: "filter", attributes: { id: d2 }, children: [{ tagName: "feDropShadow", attributes: { dx: e2.offsetX, dy: e2.offsetY, "flood-color": e2.color, "flood-opacity": Math.min(5 * e2.opacity, 1), stdDeviation: e2.width / 2 } }] });
            return d2;
          }
          buildText(b2) {
            new D(b2).buildSVG();
          }
          getContrast(b2) {
            b2 = x.parse(b2).rgba.map((b3) => {
              b3 /= 255;
              return 0.03928 >= b3 ? b3 / 12.92 : Math.pow((b3 + 0.055) / 1.055, 2.4);
            });
            b2 = 0.2126 * b2[0] + 0.7152 * b2[1] + 0.0722 * b2[2];
            return 1.05 / (b2 + 0.05) > (b2 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
          }
          button(d2, e2, c2, m2, l2 = {}, g2, f2, z2, u2, v2) {
            const J = this.label(d2, e2, c2, u2, void 0, void 0, v2, void 0, "button"), k2 = this.styledMode;
            d2 = l2.states || {};
            let L = 0;
            l2 = H(l2);
            delete l2.states;
            const n2 = H({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, l2.style);
            delete l2.style;
            let B2 = a2.filterUserAttributes(l2);
            J.attr(H({ padding: 8, r: 2 }, B2));
            let C2, M2, p2;
            k2 || (B2 = H({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, B2), g2 = H(B2, { fill: "#e6e6e6" }, a2.filterUserAttributes(g2 || d2.hover || {})), C2 = g2.style, delete g2.style, f2 = H(B2, { fill: "#e6e9ff", style: {
              color: "#000000",
              fontWeight: "bold"
            } }, a2.filterUserAttributes(f2 || d2.select || {})), M2 = f2.style, delete f2.style, z2 = H(B2, { style: { color: "#cccccc" } }, a2.filterUserAttributes(z2 || d2.disabled || {})), p2 = z2.style, delete z2.style);
            E(J.element, h ? "mouseover" : "mouseenter", function() {
              3 !== L && J.setState(1);
            });
            E(J.element, h ? "mouseout" : "mouseleave", function() {
              3 !== L && J.setState(L);
            });
            J.setState = function(b2) {
              1 !== b2 && (J.state = L = b2);
              J.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [
                "normal",
                "hover",
                "pressed",
                "disabled"
              ][b2 || 0]);
              k2 || (J.attr([B2, g2, f2, z2][b2 || 0]), b2 = [n2, C2, M2, p2][b2 || 0], w(b2) && J.css(b2));
            };
            k2 || (J.attr(B2).css(b({ cursor: "default" }, n2)), v2 && J.text.css({ pointerEvents: "none" }));
            return J.on("touchstart", (b2) => b2.stopPropagation()).on("click", function(b2) {
              3 !== L && m2.call(J, b2);
            });
          }
          crispLine(b2, d2, e2 = "round") {
            const c2 = b2[0], m2 = b2[1];
            z(c2[1]) && c2[1] === m2[1] && (c2[1] = m2[1] = Math[e2](c2[1]) - d2 % 2 / 2);
            z(c2[2]) && c2[2] === m2[2] && (c2[2] = m2[2] = Math[e2](c2[2]) + d2 % 2 / 2);
            return b2;
          }
          path(e2) {
            const c2 = this.styledMode ? {} : { fill: "none" };
            d(e2) ? c2.d = e2 : w(e2) && b(c2, e2);
            return this.createElement("path").attr(c2);
          }
          circle(b2, d2, e2) {
            b2 = w(b2) ? b2 : "undefined" === typeof b2 ? {} : { x: b2, y: d2, r: e2 };
            d2 = this.createElement("circle");
            d2.xSetter = d2.ySetter = function(b3, d3, e3) {
              e3.setAttribute("c" + d3, b3);
            };
            return d2.attr(b2);
          }
          arc(b2, d2, e2, c2, m2, l2) {
            w(b2) ? (c2 = b2, d2 = c2.y, e2 = c2.r, b2 = c2.x) : c2 = { innerR: c2, start: m2, end: l2 };
            b2 = this.symbol("arc", b2, d2, e2, e2, c2);
            b2.r = e2;
            return b2;
          }
          rect(d2, c2, m2, l2, a3, g2) {
            d2 = w(d2) ? d2 : "undefined" === typeof d2 ? {} : { x: d2, y: c2, r: a3, width: Math.max(m2 || 0, 0), height: Math.max(l2 || 0, 0) };
            const f2 = this.createElement("rect");
            this.styledMode || ("undefined" !== typeof g2 && (d2["stroke-width"] = g2, b(d2, f2.crisp(d2))), d2.fill = "none");
            f2.rSetter = function(b2, d3, c3) {
              f2.r = b2;
              e(c3, { rx: b2, ry: b2 });
            };
            f2.rGetter = function() {
              return f2.r || 0;
            };
            return f2.attr(d2);
          }
          roundedRect(b2) {
            return this.symbol("roundedRect").attr(b2);
          }
          setSize(b2, d2, e2) {
            this.width = b2;
            this.height = d2;
            this.boxWrapper.animate({ width: b2, height: d2 }, { step: function() {
              this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
            }, duration: N(e2, true) ? void 0 : 0 });
            this.alignElements();
          }
          g(b2) {
            const d2 = this.createElement("g");
            return b2 ? d2.attr({ "class": "highcharts-" + b2 }) : d2;
          }
          image(b2, d2, e2, c2, l2, a3) {
            const g2 = { preserveAspectRatio: "none" };
            m(d2) && (g2.x = d2);
            m(e2) && (g2.y = e2);
            m(c2) && (g2.width = c2);
            m(l2) && (g2.height = l2);
            const f2 = this.createElement("image").attr(g2);
            d2 = function(d3) {
              f2.attr({ href: b2 });
              a3.call(f2, d3);
            };
            a3 ? (f2.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" }), e2 = new C.Image(), E(e2, "load", d2), e2.src = b2, e2.complete && d2({})) : f2.attr({ href: b2 });
            return f2;
          }
          symbol(d2, c2, m2, a3, g2, f2) {
            const w2 = this, u2 = /^url\((.*?)\)$/, h2 = u2.test(d2), J = !h2 && (this.symbols[d2] ? d2 : "circle"), k2 = J && this.symbols[J];
            let n2, H2, C2, M2;
            if (k2)
              "number" === typeof c2 && (H2 = k2.call(this.symbols, Math.round(c2 || 0), Math.round(m2 || 0), a3 || 0, g2 || 0, f2)), n2 = this.path(H2), w2.styledMode || n2.attr("fill", "none"), b(n2, { symbolName: J || void 0, x: c2, y: m2, width: a3, height: g2 }), f2 && b(n2, f2);
            else if (h2) {
              C2 = d2.match(u2)[1];
              const b2 = n2 = this.image(C2);
              b2.imgwidth = N(f2 && f2.width, B[C2] && B[C2].width);
              b2.imgheight = N(f2 && f2.height, B[C2] && B[C2].height);
              M2 = (b3) => b3.attr({ width: b3.width, height: b3.height });
              ["width", "height"].forEach(function(d3) {
                b2[d3 + "Setter"] = function(b3, d4) {
                  this[d4] = b3;
                  const {
                    alignByTranslate: c3,
                    element: m3,
                    width: l2,
                    height: a4,
                    imgwidth: g3,
                    imgheight: w3
                  } = this;
                  b3 = this["img" + d4];
                  if (z(b3)) {
                    let z2 = 1;
                    f2 && "within" === f2.backgroundSize && l2 && a4 ? (z2 = Math.min(l2 / g3, a4 / w3), e(m3, { width: Math.round(g3 * z2), height: Math.round(w3 * z2) })) : m3 && m3.setAttribute(d4, b3);
                    c3 || this.translate(((l2 || 0) - g3 * z2) / 2, ((a4 || 0) - w3 * z2) / 2);
                  }
                };
              });
              z(c2) && b2.attr({ x: c2, y: m2 });
              b2.isImg = true;
              z(b2.imgwidth) && z(b2.imgheight) ? M2(b2) : (b2.attr({ width: 0, height: 0 }), l("img", { onload: function() {
                const d3 = q[w2.chartIndex];
                0 === this.width && (v(this, { position: "absolute", top: "-999em" }), p.body.appendChild(this));
                B[C2] = {
                  width: this.width,
                  height: this.height
                };
                b2.imgwidth = this.width;
                b2.imgheight = this.height;
                b2.element && M2(b2);
                this.parentNode && this.parentNode.removeChild(this);
                w2.imgCount--;
                if (!w2.imgCount && d3 && !d3.hasLoaded)
                  d3.onload();
              }, src: C2 }), this.imgCount++);
            }
            return n2;
          }
          clipRect(b2, d2, e2, c2) {
            const m2 = P() + "-", l2 = this.createElement("clipPath").attr({ id: m2 }).add(this.defs);
            b2 = this.rect(b2, d2, e2, c2, 0).add(l2);
            b2.id = m2;
            b2.clipPath = l2;
            b2.count = 0;
            return b2;
          }
          text(b2, d2, e2, c2) {
            const m2 = {};
            if (c2 && (this.allowHTML || !this.forExport))
              return this.html(b2, d2, e2);
            m2.x = Math.round(d2 || 0);
            e2 && (m2.y = Math.round(e2));
            z(b2) && (m2.text = b2);
            b2 = this.createElement("text").attr(m2);
            if (!c2 || this.forExport && !this.allowHTML)
              b2.xSetter = function(b3, d3, e3) {
                const c3 = e3.getElementsByTagName("tspan"), m3 = e3.getAttribute(d3);
                for (let e4 = 0, l2; e4 < c3.length; e4++)
                  l2 = c3[e4], l2.getAttribute(d3) === m3 && l2.setAttribute(d3, b3);
                e3.setAttribute(d3, b3);
              };
            return b2;
          }
          fontMetrics(b2) {
            b2 = r(y.prototype.getStyle.call(b2, "font-size") || 0);
            const d2 = 24 > b2 ? b2 + 3 : Math.round(1.2 * b2);
            return { h: d2, b: Math.round(0.8 * d2), f: b2 };
          }
          rotCorr(b2, d2, e2) {
            let c2 = b2;
            d2 && e2 && (c2 = Math.max(c2 * Math.cos(d2 * k), 4));
            return { x: -b2 / 3 * Math.sin(d2 * k), y: c2 };
          }
          pathToSegments(b2) {
            const d2 = [], e2 = [], c2 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
            for (let l2 = 0; l2 < b2.length; l2++)
              M(e2[0]) && m(b2[l2]) && e2.length === c2[e2[0].toUpperCase()] && b2.splice(l2, 0, e2[0].replace("M", "L").replace("m", "l")), "string" === typeof b2[l2] && (e2.length && d2.push(e2.slice(0)), e2.length = 0), e2.push(b2[l2]);
            d2.push(e2.slice(0));
            return d2;
          }
          label(b2, d2, e2, c2, m2, l2, a3, g2, f2) {
            return new A(this, b2, d2, e2, c2, m2, l2, a3, g2, f2);
          }
          alignElements() {
            this.alignedObjects.forEach((b2) => b2.align());
          }
        }
        b(R.prototype, {
          Element: y,
          SVG_NS: g,
          escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" },
          symbols: F,
          draw: c
        });
        I.registerRendererType("svg", R, true);
        "";
        return R;
      });
      K(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { isFirefox: r, isMS: y, isWebKit: A, win: F } = a2, { css: D, defined: t, extend: q, pick: k, pInt: p } = G, n = [];
        class h extends x {
          static compose(a3) {
            if (G.pushUnique(n, a3)) {
              const c = h.prototype, g = a3.prototype;
              g.getSpanCorrection = c.getSpanCorrection;
              g.htmlCss = c.htmlCss;
              g.htmlGetBBox = c.htmlGetBBox;
              g.htmlUpdateTransform = c.htmlUpdateTransform;
              g.setSpanRotation = c.setSpanRotation;
            }
            return a3;
          }
          getSpanCorrection(a3, c, g) {
            this.xCorr = -a3 * g;
            this.yCorr = -c;
          }
          htmlCss(a3) {
            const c = "SPAN" === this.element.tagName && a3 && "width" in a3, g = k(c && a3.width, void 0);
            let f;
            c && (delete a3.width, this.textWidth = g, f = true);
            a3 && "ellipsis" === a3.textOverflow && (a3.whiteSpace = "nowrap", a3.overflow = "hidden");
            this.styles = q(this.styles, a3);
            D(this.element, a3);
            f && this.htmlUpdateTransform();
            return this;
          }
          htmlGetBBox() {
            const a3 = this.element;
            return { x: a3.offsetLeft, y: a3.offsetTop, width: a3.offsetWidth, height: a3.offsetHeight };
          }
          htmlUpdateTransform() {
            if (this.added) {
              var a3 = this.renderer, c = this.element, g = this.x || 0, h2 = this.y || 0, k2 = this.textAlign || "left", n2 = { left: 0, center: 0.5, right: 1 }[k2], e = this.styles, l = e && e.whiteSpace;
              D(c, { marginLeft: this.translateX || 0, marginTop: this.translateY || 0 });
              if ("SPAN" === c.tagName) {
                e = this.rotation;
                const f = this.textWidth && p(this.textWidth), u = [e, k2, c.innerHTML, this.textWidth, this.textAlign].join();
                let b = false;
                if (f !== this.oldTextWidth) {
                  if (this.textPxLength)
                    var v = this.textPxLength;
                  else
                    D(c, { width: "", whiteSpace: l || "nowrap" }), v = c.offsetWidth;
                  (f > this.oldTextWidth || v > f) && (/[ \-]/.test(c.textContent || c.innerText) || "ellipsis" === c.style.textOverflow) && (D(c, { width: v > f || e ? f + "px" : "auto", display: "block", whiteSpace: l || "normal" }), this.oldTextWidth = f, b = true);
                }
                this.hasBoxWidthChanged = b;
                u !== this.cTT && (a3 = a3.fontMetrics(c).b, !t(e) || e === (this.oldRotation || 0) && k2 === this.oldAlign || this.setSpanRotation(e, n2, a3), this.getSpanCorrection(!t(e) && this.textPxLength || c.offsetWidth, a3, n2, e, k2));
                D(c, { left: g + (this.xCorr || 0) + "px", top: h2 + (this.yCorr || 0) + "px" });
                this.cTT = u;
                this.oldRotation = e;
                this.oldAlign = k2;
              }
            } else
              this.alignOnAdd = true;
          }
          setSpanRotation(a3, c, g) {
            const f = {}, h2 = y && !/Edge/.test(F.navigator.userAgent) ? "-ms-transform" : A ? "-webkit-transform" : r ? "MozTransform" : F.opera ? "-o-transform" : void 0;
            h2 && (f[h2] = f.transform = "rotate(" + a3 + "deg)", f[h2 + (r ? "Origin" : "-origin")] = f.transformOrigin = 100 * c + "% " + g + "px", D(this.element, f));
          }
        }
        return h;
      });
      K(a, "Core/Renderer/HTML/HTMLRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I) {
        const { attr: r, createElement: A, extend: F, pick: D } = I, t = [];
        class q extends G {
          static compose(a3) {
            I.pushUnique(t, a3) && (a3.prototype.html = q.prototype.html);
            return a3;
          }
          html(k, p, n) {
            const h = this.createElement("span"), f = h.element, c = h.renderer, g = function(c2, a3) {
              ["opacity", "visibility"].forEach(function(g2) {
                c2[g2 + "Setter"] = function(e, l, f2) {
                  const z = c2.div ? c2.div.style : a3;
                  x.prototype[g2 + "Setter"].call(this, e, l, f2);
                  z && (z[l] = e);
                };
              });
              c2.addedSetters = true;
            };
            h.textSetter = function(c2) {
              c2 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a2.setElementHTML(this.element, D(c2, "")), this.textStr = c2, h.doTransform = true);
            };
            g(h, h.element.style);
            h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function(c2, a3) {
              "align" === a3 ? h.alignValue = h.textAlign = c2 : h[a3] = c2;
              h.doTransform = true;
            };
            h.afterSetters = function() {
              this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
            };
            h.attr({ text: k, x: Math.round(p), y: Math.round(n) }).css({ position: "absolute" });
            c.styledMode || h.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });
            f.style.whiteSpace = "nowrap";
            h.css = h.htmlCss;
            h.add = function(a3) {
              const k2 = c.box.parentNode, n2 = [];
              let e;
              if (this.parentGroup = a3) {
                if (e = a3.div, !e) {
                  for (; a3; )
                    n2.push(a3), a3 = a3.parentGroup;
                  n2.reverse().forEach(function(c2) {
                    function a4(d, e2) {
                      c2[e2] = d;
                      "translateX" === e2 ? b.left = d + "px" : b.top = d + "px";
                      c2.doTransform = true;
                    }
                    const l = r(c2.element, "class"), f2 = c2.styles || {};
                    e = c2.div = c2.div || A("div", l ? { className: l } : void 0, { position: "absolute", left: (c2.translateX || 0) + "px", top: (c2.translateY || 0) + "px", display: c2.display, opacity: c2.opacity, visibility: c2.visibility }, e || k2);
                    const b = e.style;
                    F(c2, { classSetter: function(b2) {
                      return function(d) {
                        this.element.setAttribute("class", d);
                        b2.className = d;
                      };
                    }(e), css: function(d) {
                      h.css.call(c2, d);
                      ["cursor", "pointerEvents"].forEach((e2) => {
                        d[e2] && (b[e2] = d[e2]);
                      });
                      return c2;
                    }, on: function() {
                      n2[0].div && h.on.apply({ element: n2[0].div, onEvents: c2.onEvents }, arguments);
                      return c2;
                    }, translateXSetter: a4, translateYSetter: a4 });
                    c2.addedSetters || g(c2);
                    c2.css(f2);
                  });
                }
              } else
                e = k2;
              e.appendChild(f);
              h.added = true;
              h.alignOnAdd && h.htmlUpdateTransform();
              return h;
            };
            return h;
          }
        }
        return q;
      });
      K(a, "Core/Axis/AxisDefaults.js", [], function() {
        var a2;
        (function(a3) {
          a3.defaultXAxisOptions = {
            alignTicks: true,
            allowDecimals: void 0,
            panningEnabled: true,
            zIndex: 2,
            zoomEnabled: true,
            dateTimeLabelFormats: { millisecond: { main: "%H:%M:%S.%L", range: false }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } },
            endOnTick: false,
            gridLineDashStyle: "Solid",
            gridZIndex: 1,
            labels: { autoRotation: void 0, autoRotationLimit: 80, distance: 15, enabled: true, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } },
            maxPadding: 0.01,
            minorGridLineDashStyle: "Solid",
            minorTickLength: 2,
            minorTickPosition: "outside",
            minorTicksPerMajor: 5,
            minPadding: 0.01,
            offset: void 0,
            opposite: false,
            reversed: void 0,
            reversedStacks: false,
            showEmpty: true,
            showFirstLabel: true,
            showLastLabel: true,
            startOfWeek: 1,
            startOnTick: false,
            tickLength: 10,
            tickPixelInterval: 100,
            tickmarkPlacement: "between",
            tickPosition: "outside",
            title: { align: "middle", rotation: 0, useHTML: false, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } },
            type: "linear",
            uniqueNames: true,
            visible: true,
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#333333",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            gridLineWidth: void 0,
            tickColor: "#333333"
          };
          a3.defaultYAxisOptions = {
            reversedStacks: true,
            endOnTick: true,
            maxPadding: 0.05,
            minPadding: 0.05,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: { x: void 0 },
            startOnTick: true,
            title: { rotation: 270, text: "Values" },
            stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
              const { numberFormatter: a4 } = this.axis.chart;
              return a4(this.total || 0, -1);
            }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } },
            gridLineWidth: 1,
            lineWidth: 0
          };
          a3.defaultLeftAxisOptions = { title: { rotation: 270 } };
          a3.defaultRightAxisOptions = { title: { rotation: 90 } };
          a3.defaultBottomAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
          a3.defaultTopAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
        })(a2 || (a2 = {}));
        return a2;
      });
      K(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: r, isFunction: G, objectEach: I, removeEvent: y } = a2;
        var A;
        (function(a3) {
          a3.registerEventOptions = function(a4, t) {
            a4.eventOptions = a4.eventOptions || {};
            I(t.events, function(q, k) {
              a4.eventOptions[k] !== q && (a4.eventOptions[k] && (y(a4, k, a4.eventOptions[k]), delete a4.eventOptions[k]), G(q) && (a4.eventOptions[k] = q, r(a4, k, q, { order: 0 })));
            });
          };
        })(A || (A = {}));
        return A;
      });
      K(a, "Core/Axis/Tick.js", [a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { deg2rad: r } = x, { clamp: y, correctFloat: A, defined: F, destroyObjectProperties: D, extend: t, fireEvent: q, isNumber: k, merge: p, objectEach: n, pick: h } = G;
        class f {
          constructor(c, a3, f2, h2, k2) {
            this.isNewLabel = this.isNew = true;
            this.axis = c;
            this.pos = a3;
            this.type = f2 || "";
            this.parameters = k2 || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            q(this, "init");
            f2 || h2 || this.addLabel();
          }
          addLabel() {
            const c = this, g = c.axis;
            var f2 = g.options;
            const n2 = g.chart;
            var p2 = g.categories;
            const e = g.logarithmic, l = g.names, v = c.pos, z = h(c.options && c.options.labels, f2.labels);
            var u = g.tickPositions;
            const b = v === u[0], d = v === u[u.length - 1], m = (!z.step || 1 === z.step) && 1 === g.tickInterval;
            u = u.info;
            let w = c.label, M, H, N;
            p2 = this.parameters.category || (p2 ? h(p2[v], l[v], v) : v);
            e && k(p2) && (p2 = A(e.lin2log(p2)));
            g.dateTime && (u ? (H = n2.time.resolveDTLFormat(f2.dateTimeLabelFormats[!f2.grid && u.higherRanks[v] || u.unitName]), M = H.main) : k(p2) && (M = g.dateTime.getXDateFormat(p2, f2.dateTimeLabelFormats || {})));
            c.isFirst = b;
            c.isLast = d;
            const r2 = { axis: g, chart: n2, dateTimeLabelFormat: M, isFirst: b, isLast: d, pos: v, tick: c, tickPositionInfo: u, value: p2 };
            q(this, "labelFormat", r2);
            const D2 = (b2) => z.formatter ? z.formatter.call(b2, b2) : z.format ? (b2.text = g.defaultLabelFormatter.call(b2, b2), a2.format(z.format, b2, n2)) : g.defaultLabelFormatter.call(b2, b2);
            f2 = D2.call(r2, r2);
            const y2 = H && H.list;
            c.shortenLabel = y2 ? function() {
              for (N = 0; N < y2.length; N++)
                if (t(
                  r2,
                  { dateTimeLabelFormat: y2[N] }
                ), w.attr({ text: D2.call(r2, r2) }), w.getBBox().width < g.getSlotWidth(c) - 2 * z.padding)
                  return;
              w.attr({ text: "" });
            } : void 0;
            m && g._addedPlotLB && c.moveLabel(f2, z);
            F(w) || c.movedLabel ? w && w.textStr !== f2 && !m && (!w.textWidth || z.style.width || w.styles.width || w.css({ width: null }), w.attr({ text: f2 }), w.textPxLength = w.getBBox().width) : (c.label = w = c.createLabel({ x: 0, y: 0 }, f2, z), c.rotation = 0);
          }
          createLabel(c, a3, f2) {
            const g = this.axis, h2 = g.chart;
            if (c = F(a3) && f2.enabled ? h2.renderer.text(a3, c.x, c.y, f2.useHTML).add(g.labelGroup) : null)
              h2.styledMode || c.css(p(f2.style)), c.textPxLength = c.getBBox().width;
            return c;
          }
          destroy() {
            D(this, this.axis);
          }
          getPosition(c, a3, f2, h2) {
            const g = this.axis, e = g.chart, l = h2 && e.oldChartHeight || e.chartHeight;
            c = { x: c ? A(g.translate(a3 + f2, void 0, void 0, h2) + g.transB) : g.left + g.offset + (g.opposite ? (h2 && e.oldChartWidth || e.chartWidth) - g.right - g.left : 0), y: c ? l - g.bottom + g.offset - (g.opposite ? g.height : 0) : A(l - g.translate(a3 + f2, void 0, void 0, h2) - g.transB) };
            c.y = y(c.y, -1e5, 1e5);
            q(this, "afterGetPosition", { pos: c });
            return c;
          }
          getLabelPosition(c, a3, f2, k2, n2, e, l, v) {
            const g = this.axis, u = g.transA, b = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed, d = g.staggerLines, m = g.tickRotCorr || { x: 0, y: 0 }, w = k2 || g.reserveSpaceDefault ? 0 : -g.labelOffset * ("center" === g.labelAlign ? 0.5 : 1), B = n2.distance, H = {};
            f2 = 0 === g.side ? f2.rotation ? -B : -f2.getBBox().height : 2 === g.side ? m.y + B : Math.cos(f2.rotation * r) * (m.y - f2.getBBox(false, 0).height / 2);
            F(n2.y) && (f2 = 0 === g.side && g.horiz ? n2.y + f2 : n2.y);
            c = c + h(n2.x, [0, 1, 0, -1][g.side] * B) + w + m.x - (e && k2 ? e * u * (b ? -1 : 1) : 0);
            a3 = a3 + f2 - (e && !k2 ? e * u * (b ? 1 : -1) : 0);
            d && (k2 = l / (v || 1) % d, g.opposite && (k2 = d - k2 - 1), a3 += g.labelOffset / d * k2);
            H.x = c;
            H.y = Math.round(a3);
            q(this, "afterGetLabelPosition", { pos: H, tickmarkOffset: e, index: l });
            return H;
          }
          getLabelSize() {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
          }
          getMarkPath(c, a3, f2, h2, k2, e) {
            return e.crispLine([["M", c, a3], ["L", c + (k2 ? 0 : -f2), a3 + (k2 ? f2 : 0)]], h2);
          }
          handleOverflow(c) {
            const a3 = this.axis, f2 = a3.options.labels, k2 = c.x;
            var n2 = a3.chart.chartWidth, e = a3.chart.spacing;
            const l = h(a3.labelLeft, Math.min(a3.pos, e[3]));
            e = h(a3.labelRight, Math.max(a3.isRadial ? 0 : a3.pos + a3.len, n2 - e[1]));
            const v = this.label, z = this.rotation, u = { left: 0, center: 0.5, right: 1 }[a3.labelAlign || v.attr("align")], b = v.getBBox().width, d = a3.getSlotWidth(this), m = {};
            let w = d, p2 = 1, H;
            if (z || "justify" !== f2.overflow)
              0 > z && k2 - u * b < l ? H = Math.round(k2 / Math.cos(z * r) - l) : 0 < z && k2 + u * b > e && (H = Math.round((n2 - k2) / Math.cos(z * r)));
            else if (n2 = k2 + (1 - u) * b, k2 - u * b < l ? w = c.x + w * (1 - u) - l : n2 > e && (w = e - c.x + w * u, p2 = -1), w = Math.min(d, w), w < d && "center" === a3.labelAlign && (c.x += p2 * (d - w - u * (d - Math.min(b, w)))), b > w || a3.autoRotation && (v.styles || {}).width)
              H = w;
            H && (this.shortenLabel ? this.shortenLabel() : (m.width = Math.floor(H) + "px", (f2.style || {}).textOverflow || (m.textOverflow = "ellipsis"), v.css(m)));
          }
          moveLabel(c, a3) {
            const f2 = this;
            var g = f2.label;
            const h2 = f2.axis;
            let e = false;
            g && g.textStr === c ? (f2.movedLabel = g, e = true, delete f2.label) : n(h2.ticks, function(a4) {
              e || a4.isNew || a4 === f2 || !a4.label || a4.label.textStr !== c || (f2.movedLabel = a4.label, e = true, a4.labelPos = f2.movedLabel.xy, delete a4.label);
            });
            e || !f2.labelPos && !g || (g = f2.labelPos || g.xy, f2.movedLabel = f2.createLabel(g, c, a3), f2.movedLabel && f2.movedLabel.attr({ opacity: 0 }));
          }
          render(c, a3, f2) {
            var g = this.axis, k2 = g.horiz, e = this.pos, l = h(this.tickmarkOffset, g.tickmarkOffset);
            e = this.getPosition(k2, e, l, a3);
            l = e.x;
            const v = e.y;
            g = k2 && l === g.pos + g.len || !k2 && v === g.pos ? -1 : 1;
            k2 = h(f2, this.label && this.label.newOpacity, 1);
            f2 = h(f2, 1);
            this.isActive = true;
            this.renderGridLine(a3, f2, g);
            this.renderMark(e, f2, g);
            this.renderLabel(e, a3, k2, c);
            this.isNew = false;
            q(this, "afterRender");
          }
          renderGridLine(c, a3, f2) {
            const g = this.axis, k2 = g.options, e = {}, l = this.pos, v = this.type, z = h(this.tickmarkOffset, g.tickmarkOffset), u = g.chart.renderer;
            let b = this.gridLine, d = k2.gridLineWidth, m = k2.gridLineColor, w = k2.gridLineDashStyle;
            "minor" === this.type && (d = k2.minorGridLineWidth, m = k2.minorGridLineColor, w = k2.minorGridLineDashStyle);
            b || (g.chart.styledMode || (e.stroke = m, e["stroke-width"] = d || 0, e.dashstyle = w), v || (e.zIndex = 1), c && (a3 = 0), this.gridLine = b = u.path().attr(e).addClass("highcharts-" + (v ? v + "-" : "") + "grid-line").add(g.gridGroup));
            if (b && (f2 = g.getPlotLinePath({ value: l + z, lineWidth: b.strokeWidth() * f2, force: "pass", old: c, acrossPanes: false })))
              b[c || this.isNew ? "attr" : "animate"]({ d: f2, opacity: a3 });
          }
          renderMark(c, a3, f2) {
            const g = this.axis;
            var k2 = g.options;
            const e = g.chart.renderer, l = this.type, v = g.tickSize(l ? l + "Tick" : "tick"), z = c.x;
            c = c.y;
            const u = h(k2["minor" !== l ? "tickWidth" : "minorTickWidth"], !l && g.isXAxis ? 1 : 0);
            k2 = k2["minor" !== l ? "tickColor" : "minorTickColor"];
            let b = this.mark;
            const d = !b;
            v && (g.opposite && (v[0] = -v[0]), b || (this.mark = b = e.path().addClass("highcharts-" + (l ? l + "-" : "") + "tick").add(g.axisGroup), g.chart.styledMode || b.attr({ stroke: k2, "stroke-width": u })), b[d ? "attr" : "animate"]({ d: this.getMarkPath(z, c, v[0], b.strokeWidth() * f2, g.horiz, e), opacity: a3 }));
          }
          renderLabel(c, a3, f2, n2) {
            var g = this.axis;
            const e = g.horiz, l = g.options, v = this.label, z = l.labels, u = z.step;
            g = h(this.tickmarkOffset, g.tickmarkOffset);
            const b = c.x;
            c = c.y;
            let d = true;
            v && k(b) && (v.xy = c = this.getLabelPosition(b, c, v, e, z, g, n2, u), this.isFirst && !this.isLast && !l.showFirstLabel || this.isLast && !this.isFirst && !l.showLastLabel ? d = false : !e || z.step || z.rotation || a3 || 0 === f2 || this.handleOverflow(c), u && n2 % u && (d = false), d && k(c.y) ? (c.opacity = f2, v[this.isNewLabel ? "attr" : "animate"](c).show(true), this.isNewLabel = false) : (v.hide(), this.isNewLabel = true));
          }
          replaceMovedLabel() {
            const c = this.label, a3 = this.axis;
            c && !this.isNew && (c.animate({ opacity: 0 }, void 0, c.destroy), delete this.label);
            a3.isDirty = true;
            this.label = this.movedLabel;
            delete this.movedLabel;
          }
        }
        "";
        return f;
      });
      K(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Defaults.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A, F, D) {
        const { animObject: t } = a2, { defaultOptions: q } = I, { registerEventOptions: k } = y, { deg2rad: p } = A, { arrayMax: n, arrayMin: h, clamp: f, correctFloat: c, defined: g, destroyObjectProperties: B, erase: C, error: E, extend: e, fireEvent: l, getClosestDistance: v, insertItem: z, isArray: u, isNumber: b, isString: d, merge: m, normalizeTickInterval: w, objectEach: M, pick: H, relativeLength: N, removeEvent: r, splat: P, syncTimeout: Y } = D, R = (b2, d2) => w(d2, void 0, void 0, H(b2.options.allowDecimals, 0.5 > d2 || void 0 !== b2.tickAmount), !!b2.tickAmount);
        class W {
          constructor(b2, d2, e2) {
            this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.index = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
            this.init(b2, d2, e2);
          }
          init(d2, e2, c2 = this.coll) {
            const a3 = "xAxis" === c2;
            this.chart = d2;
            this.horiz = this.isZAxis || (d2.inverted ? !a3 : a3);
            this.isXAxis = a3;
            this.coll = c2;
            l(this, "init", { userOptions: e2 });
            this.opposite = H(e2.opposite, this.opposite);
            this.side = H(e2.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
            this.setOptions(e2);
            c2 = this.options;
            const m2 = c2.labels, f2 = c2.type;
            this.userOptions = e2;
            this.minPixelPadding = 0;
            this.reversed = H(c2.reversed, this.reversed);
            this.visible = c2.visible;
            this.zoomEnabled = c2.zoomEnabled;
            this.hasNames = "category" === f2 || true === c2.categories;
            this.categories = c2.categories || (this.hasNames ? [] : void 0);
            this.names || (this.names = [], this.names.keys = {});
            this.plotLinesAndBandsGroups = {};
            this.positiveValuesOnly = !!this.logarithmic;
            this.isLinked = g(c2.linkedTo);
            this.ticks = {};
            this.labelEdge = [];
            this.minorTicks = {};
            this.plotLinesAndBands = [];
            this.alternateBands = {};
            this.len = 0;
            this.minRange = this.userMinRange = c2.minRange || c2.maxZoom;
            this.range = c2.range;
            this.offset = c2.offset || 0;
            this.min = this.max = null;
            e2 = H(c2.crosshair, P(d2.options.tooltip.crosshairs)[a3 ? 0 : 1]);
            this.crosshair = true === e2 ? {} : e2;
            -1 === d2.axes.indexOf(this) && (a3 ? d2.axes.splice(d2.xAxis.length, 0, this) : d2.axes.push(this), z(this, d2[this.coll]));
            d2.orderItems(this.coll);
            this.series = this.series || [];
            d2.inverted && !this.isZAxis && a3 && "undefined" === typeof this.reversed && (this.reversed = true);
            this.labelRotation = b(m2.rotation) ? m2.rotation : void 0;
            k(this, c2);
            l(this, "afterInit");
          }
          setOptions(b2) {
            this.options = m(x.defaultXAxisOptions, "yAxis" === this.coll && x.defaultYAxisOptions, [x.defaultTopAxisOptions, x.defaultRightAxisOptions, x.defaultBottomAxisOptions, x.defaultLeftAxisOptions][this.side], m(q[this.coll], b2));
            l(this, "afterSetOptions", { userOptions: b2 });
          }
          defaultLabelFormatter(d2) {
            var e2 = this.axis;
            ({ numberFormatter: d2 } = this.chart);
            const c2 = b(this.value) ? this.value : NaN, a3 = e2.chart.time, m2 = this.dateTimeLabelFormat;
            var l2 = q.lang;
            const f2 = l2.numericSymbols;
            l2 = l2.numericSymbolMagnitude || 1e3;
            const g2 = e2.logarithmic ? Math.abs(c2) : e2.tickInterval;
            let w2 = f2 && f2.length, h2;
            if (e2.categories)
              h2 = `${this.value}`;
            else if (m2)
              h2 = a3.dateFormat(m2, c2);
            else if (w2 && 1e3 <= g2)
              for (; w2-- && "undefined" === typeof h2; )
                e2 = Math.pow(l2, w2 + 1), g2 >= e2 && 0 === 10 * c2 % e2 && null !== f2[w2] && 0 !== c2 && (h2 = d2(c2 / e2, -1) + f2[w2]);
            "undefined" === typeof h2 && (h2 = 1e4 <= Math.abs(c2) ? d2(c2, -1) : d2(c2, -1, void 0, ""));
            return h2;
          }
          getSeriesExtremes() {
            const d2 = this, e2 = d2.chart;
            let c2;
            l(this, "getSeriesExtremes", null, function() {
              d2.hasVisibleSeries = false;
              d2.dataMin = d2.dataMax = d2.threshold = null;
              d2.softThreshold = !d2.isXAxis;
              d2.series.forEach(function(a3) {
                if (a3.visible || !e2.options.chart.ignoreHiddenSeries) {
                  var m2 = a3.options;
                  let e3 = m2.threshold, l2, f2;
                  d2.hasVisibleSeries = true;
                  d2.positiveValuesOnly && 0 >= e3 && (e3 = null);
                  if (d2.isXAxis)
                    (m2 = a3.xData) && m2.length && (m2 = d2.logarithmic ? m2.filter((b2) => 0 < b2) : m2, c2 = a3.getXExtremes(m2), l2 = c2.min, f2 = c2.max, b(l2) || l2 instanceof Date || (m2 = m2.filter(b), c2 = a3.getXExtremes(m2), l2 = c2.min, f2 = c2.max), m2.length && (d2.dataMin = Math.min(H(d2.dataMin, l2), l2), d2.dataMax = Math.max(H(
                      d2.dataMax,
                      f2
                    ), f2)));
                  else if (a3 = a3.applyExtremes(), b(a3.dataMin) && (l2 = a3.dataMin, d2.dataMin = Math.min(H(d2.dataMin, l2), l2)), b(a3.dataMax) && (f2 = a3.dataMax, d2.dataMax = Math.max(H(d2.dataMax, f2), f2)), g(e3) && (d2.threshold = e3), !m2.softThreshold || d2.positiveValuesOnly)
                    d2.softThreshold = false;
                }
              });
            });
            l(this, "afterGetSeriesExtremes");
          }
          translate(d2, e2, a3, m2, l2, f2) {
            const g2 = this.linkedParent || this, w2 = m2 && g2.old ? g2.old.min : g2.min;
            if (!b(w2))
              return NaN;
            const h2 = g2.minPixelPadding;
            l2 = (g2.isOrdinal || g2.brokenAxis && g2.brokenAxis.hasBreaks || g2.logarithmic && l2) && g2.lin2val;
            let k2 = 1, u2 = 0;
            m2 = m2 && g2.old ? g2.old.transA : g2.transA;
            m2 || (m2 = g2.transA);
            a3 && (k2 *= -1, u2 = g2.len);
            g2.reversed && (k2 *= -1, u2 -= k2 * (g2.sector || g2.len));
            e2 ? (f2 = (d2 * k2 + u2 - h2) / m2 + w2, l2 && (f2 = g2.lin2val(f2))) : (l2 && (d2 = g2.val2lin(d2)), d2 = k2 * (d2 - w2) * m2, f2 = (g2.isRadial ? d2 : c(d2)) + u2 + k2 * h2 + (b(f2) ? m2 * f2 : 0));
            return f2;
          }
          toPixels(b2, d2) {
            return this.translate(b2, false, !this.horiz, void 0, true) + (d2 ? 0 : this.pos);
          }
          toValue(b2, d2) {
            return this.translate(b2 - (d2 ? 0 : this.pos), true, !this.horiz, void 0, true);
          }
          getPlotLinePath(d2) {
            function e2(b2, d3, e3) {
              "pass" !== J && (b2 < d3 || b2 > e3) && (J ? b2 = f(b2, d3, e3) : q2 = true);
              return b2;
            }
            const c2 = this, a3 = c2.chart, m2 = c2.left, g2 = c2.top, w2 = d2.old, h2 = d2.value, k2 = d2.lineWidth, u2 = w2 && a3.oldChartHeight || a3.chartHeight, z2 = w2 && a3.oldChartWidth || a3.chartWidth, v2 = c2.transB;
            let n2 = d2.translatedValue, J = d2.force, p2, M2, B2, C2, q2;
            d2 = { value: h2, lineWidth: k2, old: w2, force: J, acrossPanes: d2.acrossPanes, translatedValue: n2 };
            l(this, "getPlotLinePath", d2, function(d3) {
              n2 = H(n2, c2.translate(h2, void 0, void 0, w2));
              n2 = f(n2, -1e5, 1e5);
              p2 = B2 = Math.round(n2 + v2);
              M2 = C2 = Math.round(u2 - n2 - v2);
              b(n2) ? c2.horiz ? (M2 = g2, C2 = u2 - c2.bottom, p2 = B2 = e2(p2, m2, m2 + c2.width)) : (p2 = m2, B2 = z2 - c2.right, M2 = C2 = e2(M2, g2, g2 + c2.height)) : (q2 = true, J = false);
              d3.path = q2 && !J ? null : a3.renderer.crispLine([["M", p2, M2], ["L", B2, C2]], k2 || 1);
            });
            return d2.path;
          }
          getLinearTickPositions(b2, d2, e2) {
            const a3 = c(Math.floor(d2 / b2) * b2);
            e2 = c(Math.ceil(e2 / b2) * b2);
            const m2 = [];
            let l2, g2;
            c(a3 + b2) === a3 && (g2 = 20);
            if (this.single)
              return [d2];
            for (d2 = a3; d2 <= e2; ) {
              m2.push(d2);
              d2 = c(d2 + b2, g2);
              if (d2 === l2)
                break;
              l2 = d2;
            }
            return m2;
          }
          getMinorTickInterval() {
            const b2 = this.options;
            return true === b2.minorTicks ? H(b2.minorTickInterval, "auto") : false === b2.minorTicks ? null : b2.minorTickInterval;
          }
          getMinorTickPositions() {
            var b2 = this.options;
            const d2 = this.tickPositions, e2 = this.minorTickInterval;
            var c2 = this.pointRangePadding || 0;
            const a3 = this.min - c2;
            c2 = this.max + c2;
            const m2 = c2 - a3;
            let l2 = [];
            if (m2 && m2 / e2 < this.len / 3) {
              const m3 = this.logarithmic;
              if (m3)
                this.paddedTicks.forEach(function(b3, d3, c3) {
                  d3 && l2.push.apply(l2, m3.getLogTickPositions(e2, c3[d3 - 1], c3[d3], true));
                });
              else if (this.dateTime && "auto" === this.getMinorTickInterval())
                l2 = l2.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e2), a3, c2, b2.startOfWeek));
              else
                for (b2 = a3 + (d2[0] - a3) % e2; b2 <= c2 && b2 !== l2[0]; b2 += e2)
                  l2.push(b2);
            }
            0 !== l2.length && this.trimTicks(l2);
            return l2;
          }
          adjustForMinRange() {
            const b2 = this.options, d2 = this.logarithmic;
            let e2 = this.min;
            var c2 = this.max;
            let a3, m2;
            if (this.isXAxis && "undefined" === typeof this.minRange && !d2)
              if (g(b2.min) || g(b2.max) || g(b2.floor) || g(b2.ceiling))
                this.minRange = null;
              else {
                var l2 = v(this.series.map((b3) => {
                  var d3;
                  return (b3.xIncrement ? null === (d3 = b3.xData) || void 0 === d3 ? void 0 : d3.slice(0, 2) : b3.xData) || [];
                })) || 0;
                this.minRange = Math.min(5 * l2, this.dataMax - this.dataMin);
              }
            c2 - e2 < this.minRange && (l2 = this.dataMax - this.dataMin >= this.minRange, m2 = this.minRange, c2 = (m2 - c2 + e2) / 2, a3 = [e2 - c2, H(b2.min, e2 - c2)], l2 && (a3[2] = d2 ? d2.log2lin(this.dataMin) : this.dataMin), e2 = n(a3), c2 = [e2 + m2, H(b2.max, e2 + m2)], l2 && (c2[2] = d2 ? d2.log2lin(this.dataMax) : this.dataMax), c2 = h(c2), c2 - e2 < m2 && (a3[0] = c2 - m2, a3[1] = H(b2.min, c2 - m2), e2 = n(a3)));
            this.min = e2;
            this.max = c2;
          }
          getClosest() {
            let b2, d2;
            if (this.categories)
              d2 = 1;
            else {
              const e2 = [];
              this.series.forEach(function(b3) {
                var c2;
                const a3 = b3.closestPointRange, m2 = b3.visible || !b3.chart.options.chart.ignoreHiddenSeries;
                1 === (null === (c2 = b3.xData) || void 0 === c2 ? void 0 : c2.length) ? e2.push(b3.xData[0]) : !b3.noSharedTooltip && g(a3) && m2 && (d2 = g(d2) ? Math.min(d2, a3) : a3);
              });
              e2.length && (e2.sort((b3, d3) => b3 - d3), b2 = v([e2]));
            }
            return b2 && d2 ? Math.min(b2, d2) : b2 || d2;
          }
          nameToX(b2) {
            const d2 = u(this.options.categories), e2 = d2 ? this.categories : this.names;
            let c2 = b2.options.x, a3;
            b2.series.requireSorting = false;
            g(c2) || (c2 = this.options.uniqueNames && e2 ? d2 ? e2.indexOf(b2.name) : H(e2.keys[b2.name], -1) : b2.series.autoIncrement());
            -1 === c2 ? !d2 && e2 && (a3 = e2.length) : a3 = c2;
            "undefined" !== typeof a3 ? (this.names[a3] = b2.name, this.names.keys[b2.name] = a3) : b2.x && (a3 = b2.x);
            return a3;
          }
          updateNames() {
            const b2 = this, d2 = this.names;
            0 < d2.length && (Object.keys(d2.keys).forEach(function(b3) {
              delete d2.keys[b3];
            }), d2.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(d3) {
              d3.xIncrement = null;
              if (!d3.points || d3.isDirtyData)
                b2.max = Math.max(b2.max, d3.xData.length - 1), d3.processData(), d3.generatePoints();
              d3.data.forEach(function(e2, c2) {
                let a3;
                e2 && e2.options && "undefined" !== typeof e2.name && (a3 = b2.nameToX(e2), "undefined" !== typeof a3 && a3 !== e2.x && (e2.x = a3, d3.xData[c2] = a3));
              });
            }));
          }
          setAxisTranslation() {
            const b2 = this, e2 = b2.max - b2.min;
            var c2 = b2.linkedParent;
            const a3 = !!b2.categories, m2 = b2.isXAxis;
            let g2 = b2.axisPointRange || 0, f2, w2 = 0, h2 = 0, k2 = b2.transA;
            if (m2 || a3 || g2)
              f2 = b2.getClosest(), c2 ? (w2 = c2.minPointOffset, h2 = c2.pointRangePadding) : b2.series.forEach(function(e3) {
                const c3 = a3 ? 1 : m2 ? H(e3.options.pointRange, f2, 0) : b2.axisPointRange || 0, l2 = e3.options.pointPlacement;
                g2 = Math.max(g2, c3);
                if (!b2.single || a3)
                  e3 = e3.is("xrange") ? !m2 : m2, w2 = Math.max(w2, e3 && d(l2) ? 0 : c3 / 2), h2 = Math.max(h2, e3 && "on" === l2 ? 0 : c3);
              }), c2 = b2.ordinal && b2.ordinal.slope && f2 ? b2.ordinal.slope / f2 : 1, b2.minPointOffset = w2 *= c2, b2.pointRangePadding = h2 *= c2, b2.pointRange = Math.min(g2, b2.single && a3 ? 1 : e2), m2 && f2 && (b2.closestPointRange = f2);
            b2.translationSlope = b2.transA = k2 = b2.staticScale || b2.len / (e2 + h2 || 1);
            b2.transB = b2.horiz ? b2.left : b2.bottom;
            b2.minPixelPadding = k2 * w2;
            l(this, "afterSetAxisTranslation");
          }
          minFromRange() {
            return this.max - this.range;
          }
          setTickInterval(d2) {
            var e2 = this.chart;
            const a3 = this.logarithmic, m2 = this.options, f2 = this.isXAxis, w2 = this.isLinked, h2 = m2.tickPixelInterval, k2 = this.categories, u2 = this.softThreshold;
            let z2 = m2.maxPadding, v2 = m2.minPadding;
            let n2 = b(m2.tickInterval) && 0 <= m2.tickInterval ? m2.tickInterval : void 0, J = b(this.threshold) ? this.threshold : null, p2, M2, B2;
            this.dateTime || k2 || w2 || this.getTickAmount();
            M2 = H(this.userMin, m2.min);
            B2 = H(this.userMax, m2.max);
            if (w2) {
              this.linkedParent = e2[this.coll][m2.linkedTo];
              var C2 = this.linkedParent.getExtremes();
              this.min = H(C2.min, C2.dataMin);
              this.max = H(C2.max, C2.dataMax);
              m2.type !== this.linkedParent.options.type && E(11, 1, e2);
            } else
              u2 && g(J) && (this.dataMin >= J ? (C2 = J, v2 = 0) : this.dataMax <= J && (p2 = J, z2 = 0)), this.min = H(M2, C2, this.dataMin), this.max = H(B2, p2, this.dataMax);
            a3 && (this.positiveValuesOnly && !d2 && 0 >= Math.min(this.min, H(
              this.dataMin,
              this.min
            )) && E(10, 1, e2), this.min = c(a3.log2lin(this.min), 16), this.max = c(a3.log2lin(this.max), 16));
            this.range && g(this.max) && (this.userMin = this.min = M2 = Math.max(this.dataMin, this.minFromRange()), this.userMax = B2 = this.max, this.range = null);
            l(this, "foundExtremes");
            this.beforePadding && this.beforePadding();
            this.adjustForMinRange();
            !b(this.userMin) && b(m2.softMin) && m2.softMin < this.min && (this.min = M2 = m2.softMin);
            !b(this.userMax) && b(m2.softMax) && m2.softMax > this.max && (this.max = B2 = m2.softMax);
            !(k2 || this.axisPointRange || this.stacking && this.stacking.usePercentage || w2) && g(this.min) && g(this.max) && (e2 = this.max - this.min) && (!g(M2) && v2 && (this.min -= e2 * v2), !g(B2) && z2 && (this.max += e2 * z2));
            !b(this.userMin) && b(m2.floor) && (this.min = Math.max(this.min, m2.floor));
            !b(this.userMax) && b(m2.ceiling) && (this.max = Math.min(this.max, m2.ceiling));
            u2 && g(this.dataMin) && (J = J || 0, !g(M2) && this.min < J && this.dataMin >= J ? this.min = this.options.minRange ? Math.min(J, this.max - this.minRange) : J : !g(B2) && this.max > J && this.dataMax <= J && (this.max = this.options.minRange ? Math.max(J, this.min + this.minRange) : J));
            b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (g(this.options.min) ? this.max = this.min : g(this.options.max) && (this.min = this.max));
            this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : w2 && this.linkedParent && !n2 && h2 === this.linkedParent.options.tickPixelInterval ? n2 = this.linkedParent.tickInterval : H(n2, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, k2 ? 1 : (this.max - this.min) * h2 / Math.max(this.len, h2));
            if (f2 && !d2) {
              const b2 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
              this.series.forEach(function(d3) {
                d3.forceCrop = d3.forceCropping && d3.forceCropping();
                d3.processData(b2);
              });
              l(this, "postProcessData", { hasExtremesChanged: b2 });
            }
            this.setAxisTranslation();
            l(this, "initialAxisTranslation");
            this.pointRange && !n2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
            d2 = H(m2.minTickInterval, this.dateTime && !this.series.some((b2) => b2.noSharedTooltip) ? this.closestPointRange : 0);
            !n2 && this.tickInterval < d2 && (this.tickInterval = d2);
            this.dateTime || this.logarithmic || n2 || (this.tickInterval = R(this, this.tickInterval));
            this.tickAmount || (this.tickInterval = this.unsquish());
            this.setTickPositions();
          }
          setTickPositions() {
            var d2 = this.options;
            const e2 = d2.tickPositions, c2 = d2.tickPositioner;
            var a3 = this.getMinorTickInterval(), m2 = this.hasVerticalPanning(), f2 = "colorAxis" === this.coll;
            const w2 = (f2 || !m2) && d2.startOnTick;
            m2 = (f2 || !m2) && d2.endOnTick;
            f2 = [];
            let h2;
            this.tickmarkOffset = this.categories && "between" === d2.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0;
            this.minorTickInterval = "auto" === a3 && this.tickInterval ? this.tickInterval / d2.minorTicksPerMajor : a3;
            this.single = this.min === this.max && g(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || false !== d2.allowDecimals);
            if (e2)
              f2 = e2.slice();
            else if (b(this.min) && b(this.max)) {
              if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)))
                if (this.dateTime)
                  f2 = this.getTimeTicks(
                    this.dateTime.normalizeTimeTickInterval(this.tickInterval, d2.units),
                    this.min,
                    this.max,
                    d2.startOfWeek,
                    this.ordinal && this.ordinal.positions,
                    this.closestPointRange,
                    true
                  );
                else if (this.logarithmic)
                  f2 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                else
                  for (a3 = d2 = this.tickInterval; a3 <= 2 * d2; )
                    if (f2 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && f2.length > this.tickAmount)
                      this.tickInterval = R(this, a3 *= 1.1);
                    else
                      break;
              else
                f2 = [this.min, this.max], E(19, false, this.chart);
              f2.length > this.len && (f2 = [f2[0], f2[f2.length - 1]], f2[0] === f2[1] && (f2.length = 1));
              c2 && (this.tickPositions = f2, (h2 = c2.apply(this, [this.min, this.max])) && (f2 = h2));
            }
            this.tickPositions = f2;
            this.paddedTicks = f2.slice(0);
            this.trimTicks(f2, w2, m2);
            !this.isLinked && b(this.min) && b(this.max) && (this.single && 2 > f2.length && !this.categories && !this.series.some((b2) => b2.is("heatmap") && "between" === b2.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), e2 || h2 || this.adjustTickAmount());
            l(this, "afterSetTickPositions");
          }
          trimTicks(b2, d2, e2) {
            const c2 = b2[0], a3 = b2[b2.length - 1], m2 = !this.isOrdinal && this.minPointOffset || 0;
            l(this, "trimTicks");
            if (!this.isLinked) {
              if (d2 && -Infinity !== c2)
                this.min = c2;
              else
                for (; this.min - m2 > b2[0]; )
                  b2.shift();
              if (e2)
                this.max = a3;
              else
                for (; this.max + m2 < b2[b2.length - 1]; )
                  b2.pop();
              0 === b2.length && g(c2) && !this.options.tickPositions && b2.push((a3 + c2) / 2);
            }
          }
          alignToOthers() {
            const d2 = this, e2 = [this], c2 = d2.options, a3 = "yAxis" === this.coll && this.chart.options.chart.alignThresholds, m2 = [];
            let f2;
            d2.thresholdAlignment = void 0;
            if ((false !== this.chart.options.chart.alignTicks && c2.alignTicks || a3) && false !== c2.startOnTick && false !== c2.endOnTick && !d2.logarithmic) {
              const b2 = (b3) => {
                const { horiz: d3, options: e3 } = b3;
                return [d3 ? e3.left : e3.top, e3.width, e3.height, e3.pane].join();
              }, c3 = b2(this);
              this.chart[this.coll].forEach(function(a4) {
                const { series: m3 } = a4;
                m3.length && m3.some((b3) => b3.visible) && a4 !== d2 && b2(a4) === c3 && (f2 = true, e2.push(a4));
              });
            }
            if (f2 && a3) {
              e2.forEach((e3) => {
                e3 = e3.getThresholdAlignment(d2);
                b(e3) && m2.push(e3);
              });
              const c3 = 1 < m2.length ? m2.reduce((b2, d3) => b2 + d3, 0) / m2.length : void 0;
              e2.forEach((b2) => {
                b2.thresholdAlignment = c3;
              });
            }
            return f2;
          }
          getThresholdAlignment(d2) {
            (!b(this.dataMin) || this !== d2 && this.series.some((b2) => b2.isDirty || b2.isDirtyData)) && this.getSeriesExtremes();
            if (b(this.threshold))
              return d2 = f((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (d2 = 1 - d2), d2;
          }
          getTickAmount() {
            const b2 = this.options, d2 = b2.tickPixelInterval;
            let e2 = b2.tickAmount;
            !g(b2.tickInterval) && !e2 && this.len < d2 && !this.isRadial && !this.logarithmic && b2.startOnTick && b2.endOnTick && (e2 = 2);
            !e2 && this.alignToOthers() && (e2 = Math.ceil(this.len / d2) + 1);
            4 > e2 && (this.finalTickAmt = e2, e2 = 5);
            this.tickAmount = e2;
          }
          adjustTickAmount() {
            const d2 = this, { finalTickAmt: e2, max: a3, min: m2, options: f2, tickPositions: l2, tickAmount: w2, thresholdAlignment: h2 } = d2, k2 = l2 && l2.length;
            var u2 = H(d2.threshold, d2.softThreshold ? 0 : null);
            var z2 = d2.tickInterval;
            let v2;
            b(h2) && (v2 = 0.5 > h2 ? Math.ceil(h2 * (w2 - 1)) : Math.floor(h2 * (w2 - 1)), f2.reversed && (v2 = w2 - 1 - v2));
            if (d2.hasData() && b(m2) && b(a3)) {
              const h3 = () => {
                d2.transA *= (k2 - 1) / (w2 - 1);
                d2.min = f2.startOnTick ? l2[0] : Math.min(m2, l2[0]);
                d2.max = f2.endOnTick ? l2[l2.length - 1] : Math.max(a3, l2[l2.length - 1]);
              };
              if (b(v2) && b(d2.threshold)) {
                for (; l2[v2] !== u2 || l2.length !== w2 || l2[0] > m2 || l2[l2.length - 1] < a3; ) {
                  l2.length = 0;
                  for (l2.push(d2.threshold); l2.length < w2; )
                    void 0 === l2[v2] || l2[v2] > d2.threshold ? l2.unshift(c(l2[0] - z2)) : l2.push(c(l2[l2.length - 1] + z2));
                  if (z2 > 8 * d2.tickInterval)
                    break;
                  z2 *= 2;
                }
                h3();
              } else if (k2 < w2) {
                for (; l2.length < w2; )
                  l2.length % 2 || m2 === u2 ? l2.push(c(l2[l2.length - 1] + z2)) : l2.unshift(c(l2[0] - z2));
                h3();
              }
              if (g(e2)) {
                for (z2 = u2 = l2.length; z2--; )
                  (3 === e2 && 1 === z2 % 2 || 2 >= e2 && 0 < z2 && z2 < u2 - 1) && l2.splice(z2, 1);
                d2.finalTickAmt = void 0;
              }
            }
          }
          setScale() {
            let b2 = false, d2 = false;
            this.series.forEach(function(e3) {
              b2 = b2 || e3.isDirtyData || e3.isDirty;
              d2 = d2 || e3.xAxis && e3.xAxis.isDirty || false;
            });
            this.setAxisSize();
            const e2 = this.len !== (this.old && this.old.len);
            e2 || b2 || d2 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = e2 || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
            b2 && this.panningState && (this.panningState.isDirty = true);
            l(this, "afterSetScale");
          }
          setExtremes(b2, d2, c2, a3, m2) {
            const f2 = this, g2 = f2.chart;
            c2 = H(c2, true);
            f2.series.forEach(function(b3) {
              delete b3.kdTree;
            });
            m2 = e(m2, { min: b2, max: d2 });
            l(f2, "setExtremes", m2, function() {
              f2.userMin = b2;
              f2.userMax = d2;
              f2.eventArgs = m2;
              c2 && g2.redraw(a3);
            });
          }
          zoom(b2, d2) {
            const e2 = this, c2 = this.dataMin, a3 = this.dataMax, m2 = this.options, f2 = Math.min(c2, H(m2.min, c2)), w2 = Math.max(a3, H(m2.max, a3));
            b2 = { newMin: b2, newMax: d2 };
            l(this, "zoom", b2, function(b3) {
              let d3 = b3.newMin, m3 = b3.newMax;
              if (d3 !== e2.min || m3 !== e2.max)
                e2.allowZoomOutside || (g(c2) && (d3 < f2 && (d3 = f2), d3 > w2 && (d3 = w2)), g(a3) && (m3 < f2 && (m3 = f2), m3 > w2 && (m3 = w2))), e2.displayBtn = "undefined" !== typeof d3 || "undefined" !== typeof m3, e2.setExtremes(d3, m3, false, void 0, { trigger: "zoom" });
              b3.zoomed = true;
            });
            return b2.zoomed;
          }
          setAxisSize() {
            const b2 = this.chart;
            var d2 = this.options;
            const e2 = d2.offsets || [0, 0, 0, 0], c2 = this.horiz, a3 = this.width = Math.round(N(H(d2.width, b2.plotWidth - e2[3] + e2[1]), b2.plotWidth)), m2 = this.height = Math.round(N(H(d2.height, b2.plotHeight - e2[0] + e2[2]), b2.plotHeight)), l2 = this.top = Math.round(N(H(d2.top, b2.plotTop + e2[0]), b2.plotHeight, b2.plotTop));
            d2 = this.left = Math.round(N(
              H(d2.left, b2.plotLeft + e2[3]),
              b2.plotWidth,
              b2.plotLeft
            ));
            this.bottom = b2.chartHeight - m2 - l2;
            this.right = b2.chartWidth - a3 - d2;
            this.len = Math.max(c2 ? a3 : m2, 0);
            this.pos = c2 ? d2 : l2;
          }
          getExtremes() {
            const b2 = this.logarithmic;
            return { min: b2 ? c(b2.lin2log(this.min)) : this.min, max: b2 ? c(b2.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
          }
          getThreshold(b2) {
            var d2 = this.logarithmic;
            const e2 = d2 ? d2.lin2log(this.min) : this.min;
            d2 = d2 ? d2.lin2log(this.max) : this.max;
            null === b2 || -Infinity === b2 ? b2 = e2 : Infinity === b2 ? b2 = d2 : e2 > b2 ? b2 = e2 : d2 < b2 && (b2 = d2);
            return this.translate(
              b2,
              0,
              1,
              0,
              1
            );
          }
          autoLabelAlign(b2) {
            const d2 = (H(b2, 0) - 90 * this.side + 720) % 360;
            b2 = { align: "center" };
            l(this, "autoLabelAlign", b2, function(b3) {
              15 < d2 && 165 > d2 ? b3.align = "right" : 195 < d2 && 345 > d2 && (b3.align = "left");
            });
            return b2.align;
          }
          tickSize(b2) {
            const d2 = this.options, e2 = H(d2["tick" === b2 ? "tickWidth" : "minorTickWidth"], "tick" === b2 && this.isXAxis && !this.categories ? 1 : 0);
            let c2 = d2["tick" === b2 ? "tickLength" : "minorTickLength"], a3;
            e2 && c2 && ("inside" === d2[b2 + "Position"] && (c2 = -c2), a3 = [c2, e2]);
            b2 = { tickSize: a3 };
            l(this, "afterTickSize", b2);
            return b2.tickSize;
          }
          labelMetrics() {
            const b2 = this.chart.renderer;
            var d2 = this.ticks;
            d2 = d2[Object.keys(d2)[0]] || {};
            return this.chart.renderer.fontMetrics(d2.label || d2.movedLabel || b2.box);
          }
          unsquish() {
            const d2 = this.options.labels;
            var e2 = this.horiz;
            const a3 = this.tickInterval, m2 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a3), l2 = d2.rotation, f2 = 0.75 * this.labelMetrics().h, g2 = Math.max(this.max - this.min, 0), w2 = function(b2) {
              let d3 = b2 / (m2 || 1);
              d3 = 1 < d3 ? Math.ceil(d3) : 1;
              d3 * a3 > g2 && Infinity !== b2 && Infinity !== m2 && g2 && (d3 = Math.ceil(g2 / a3));
              return c(d3 * a3);
            };
            let h2 = a3, k2, u2 = Number.MAX_VALUE, z2;
            if (e2) {
              if (d2.staggerLines || (b(l2) ? z2 = [l2] : m2 < d2.autoRotationLimit && (z2 = d2.autoRotation)), z2) {
                let b2;
                for (const d3 of z2)
                  if (d3 === l2 || d3 && -90 <= d3 && 90 >= d3)
                    e2 = w2(Math.abs(f2 / Math.sin(p * d3))), b2 = e2 + Math.abs(d3 / 360), b2 < u2 && (u2 = b2, k2 = d3, h2 = e2);
              }
            } else
              h2 = w2(f2);
            this.autoRotation = z2;
            this.labelRotation = H(k2, b(l2) ? l2 : 0);
            return d2.step ? a3 : h2;
          }
          getSlotWidth(d2) {
            const e2 = this.chart, c2 = this.horiz, a3 = this.options.labels, m2 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), l2 = e2.margin[3];
            if (d2 && b(d2.slotWidth))
              return d2.slotWidth;
            if (c2 && 2 > a3.step)
              return a3.rotation ? 0 : (this.staggerLines || 1) * this.len / m2;
            if (!c2) {
              d2 = a3.style.width;
              if (void 0 !== d2)
                return parseInt(String(d2), 10);
              if (l2)
                return l2 - e2.spacing[3];
            }
            return 0.33 * e2.chartWidth;
          }
          renderUnsquish() {
            const b2 = this.chart, e2 = b2.renderer, c2 = this.tickPositions, a3 = this.ticks, m2 = this.options.labels, l2 = m2.style, f2 = this.horiz, g2 = this.getSlotWidth();
            var w2 = Math.max(1, Math.round(g2 - 2 * m2.padding));
            const h2 = {}, k2 = this.labelMetrics(), u2 = l2.textOverflow;
            let z2, v2, n2 = 0;
            d(m2.rotation) || (h2.rotation = m2.rotation || 0);
            c2.forEach(function(b3) {
              b3 = a3[b3];
              b3.movedLabel && b3.replaceMovedLabel();
              b3 && b3.label && b3.label.textPxLength > n2 && (n2 = b3.label.textPxLength);
            });
            this.maxLabelLength = n2;
            if (this.autoRotation)
              n2 > w2 && n2 > k2.h ? h2.rotation = this.labelRotation : this.labelRotation = 0;
            else if (g2 && (z2 = w2, !u2))
              for (v2 = "clip", w2 = c2.length; !f2 && w2--; ) {
                var H2 = c2[w2];
                if (H2 = a3[H2].label)
                  H2.styles && "ellipsis" === H2.styles.textOverflow ? H2.css({ textOverflow: "clip" }) : H2.textPxLength > g2 && H2.css({ width: g2 + "px" }), H2.getBBox().height > this.len / c2.length - (k2.h - k2.f) && (H2.specificTextOverflow = "ellipsis");
              }
            h2.rotation && (z2 = n2 > 0.5 * b2.chartHeight ? 0.33 * b2.chartHeight : n2, u2 || (v2 = "ellipsis"));
            if (this.labelAlign = m2.align || this.autoLabelAlign(this.labelRotation))
              h2.align = this.labelAlign;
            c2.forEach(function(b3) {
              const d2 = (b3 = a3[b3]) && b3.label, e3 = l2.width, c3 = {};
              d2 && (d2.attr(h2), b3.shortenLabel ? b3.shortenLabel() : z2 && !e3 && "nowrap" !== l2.whiteSpace && (z2 < d2.textPxLength || "SPAN" === d2.element.tagName) ? (c3.width = z2 + "px", u2 || (c3.textOverflow = d2.specificTextOverflow || v2), d2.css(c3)) : d2.styles && d2.styles.width && !c3.width && !e3 && d2.css({ width: null }), delete d2.specificTextOverflow, b3.rotation = h2.rotation);
            }, this);
            this.tickRotCorr = e2.rotCorr(
              k2.b,
              this.labelRotation || 0,
              0 !== this.side
            );
          }
          hasData() {
            return this.series.some(function(b2) {
              return b2.hasData();
            }) || this.options.showEmpty && g(this.min) && g(this.max);
          }
          addTitle(b2) {
            const d2 = this.chart.renderer, e2 = this.horiz, c2 = this.opposite, a3 = this.options.title, l2 = this.chart.styledMode;
            let f2;
            this.axisTitle || ((f2 = a3.textAlign) || (f2 = (e2 ? { low: "left", middle: "center", high: "right" } : { low: c2 ? "right" : "left", middle: "center", high: c2 ? "left" : "right" })[a3.align]), this.axisTitle = d2.text(a3.text || "", 0, 0, a3.useHTML).attr({
              zIndex: 7,
              rotation: a3.rotation,
              align: f2
            }).addClass("highcharts-axis-title"), l2 || this.axisTitle.css(m(a3.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true);
            l2 || a3.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" });
            this.axisTitle[b2 ? "show" : "hide"](b2);
          }
          generateTick(b2) {
            const d2 = this.ticks;
            d2[b2] ? d2[b2].addLabel() : d2[b2] = new F(this, b2);
          }
          getOffset() {
            const d2 = this, { chart: e2, horiz: c2, options: a3, side: m2, ticks: f2, tickPositions: w2, coll: h2, axisParent: k2 } = d2, u2 = e2.renderer, z2 = e2.inverted && !d2.isZAxis ? [1, 0, 3, 2][m2] : m2;
            var v2 = d2.hasData();
            const n2 = a3.title;
            var p2 = a3.labels;
            const B2 = b(a3.crossing);
            var C2 = e2.axisOffset;
            const q2 = e2.clipOffset, E2 = [-1, 1, 1, -1][m2], N2 = a3.className;
            let t2, r2 = 0, D2;
            var y2 = 0;
            let A2 = 0;
            d2.showAxis = t2 = v2 || a3.showEmpty;
            d2.staggerLines = d2.horiz && p2.staggerLines || void 0;
            if (!d2.axisGroup) {
              const b2 = (b3, d3, e3) => u2.g(b3).attr({ zIndex: e3 }).addClass(`highcharts-${h2.toLowerCase()}${d3} ` + (this.isRadial ? `highcharts-radial-axis${d3} ` : "") + (N2 || "")).add(k2);
              d2.gridGroup = b2("grid", "-grid", a3.gridZIndex);
              d2.axisGroup = b2("axis", "", a3.zIndex);
              d2.labelGroup = b2(
                "axis-labels",
                "-labels",
                p2.zIndex
              );
            }
            v2 || d2.isLinked ? (w2.forEach(function(b2) {
              d2.generateTick(b2);
            }), d2.renderUnsquish(), d2.reserveSpaceDefault = 0 === m2 || 2 === m2 || { 1: "left", 3: "right" }[m2] === d2.labelAlign, H(p2.reserveSpace, B2 ? false : null, "center" === d2.labelAlign ? true : null, d2.reserveSpaceDefault) && w2.forEach(function(b2) {
              A2 = Math.max(f2[b2].getLabelSize(), A2);
            }), d2.staggerLines && (A2 *= d2.staggerLines), d2.labelOffset = A2 * (d2.opposite ? -1 : 1)) : M(f2, function(b2, d3) {
              b2.destroy();
              delete f2[d3];
            });
            n2 && n2.text && false !== n2.enabled && (d2.addTitle(t2), t2 && !B2 && false !== n2.reserveSpace && (d2.titleOffset = r2 = d2.axisTitle.getBBox()[c2 ? "height" : "width"], D2 = n2.offset, y2 = g(D2) ? 0 : H(n2.margin, c2 ? 5 : 10)));
            d2.renderLine();
            d2.offset = E2 * H(a3.offset, C2[m2] ? C2[m2] + (a3.margin || 0) : 0);
            d2.tickRotCorr = d2.tickRotCorr || { x: 0, y: 0 };
            v2 = 0 === m2 ? -d2.labelMetrics().h : 2 === m2 ? d2.tickRotCorr.y : 0;
            y2 = Math.abs(A2) + y2;
            A2 && (y2 = y2 - v2 + E2 * (c2 ? H(p2.y, d2.tickRotCorr.y + E2 * p2.distance) : H(p2.x, E2 * p2.distance)));
            d2.axisTitleMargin = H(D2, y2);
            d2.getMaxLabelDimensions && (d2.maxLabelDimensions = d2.getMaxLabelDimensions(f2, w2));
            "colorAxis" !== h2 && (p2 = this.tickSize("tick"), C2[m2] = Math.max(C2[m2], (d2.axisTitleMargin || 0) + r2 + E2 * d2.offset, y2, w2 && w2.length && p2 ? p2[0] + E2 * d2.offset : 0), C2 = !d2.axisLine || a3.offset ? 0 : 2 * Math.floor(d2.axisLine.strokeWidth() / 2), q2[z2] = Math.max(q2[z2], C2));
            l(this, "afterGetOffset");
          }
          getLinePath(b2) {
            const d2 = this.chart, e2 = this.opposite;
            var c2 = this.offset;
            const a3 = this.horiz, m2 = this.left + (e2 ? this.width : 0) + c2;
            c2 = d2.chartHeight - this.bottom - (e2 ? this.height : 0) + c2;
            e2 && (b2 *= -1);
            return d2.renderer.crispLine([["M", a3 ? this.left : m2, a3 ? c2 : this.top], ["L", a3 ? d2.chartWidth - this.right : m2, a3 ? c2 : d2.chartHeight - this.bottom]], b2);
          }
          renderLine() {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
          }
          getTitlePosition(b2) {
            var d2 = this.horiz, e2 = this.left;
            const c2 = this.top;
            var a3 = this.len;
            const m2 = this.options.title, f2 = d2 ? e2 : c2, g2 = this.opposite, w2 = this.offset, h2 = m2.x, k2 = m2.y, u2 = this.chart.renderer.fontMetrics(b2);
            b2 = b2 ? Math.max(b2.getBBox(false, 0).height - u2.h - 1, 0) : 0;
            a3 = { low: f2 + (d2 ? 0 : a3), middle: f2 + a3 / 2, high: f2 + (d2 ? a3 : 0) }[m2.align];
            e2 = (d2 ? c2 + this.height : e2) + (d2 ? 1 : -1) * (g2 ? -1 : 1) * (this.axisTitleMargin || 0) + [-b2, b2, u2.f, -b2][this.side];
            d2 = { x: d2 ? a3 + h2 : e2 + (g2 ? this.width : 0) + w2 + h2, y: d2 ? e2 + k2 - (g2 ? this.height : 0) + w2 : a3 + k2 };
            l(this, "afterGetTitlePosition", { titlePosition: d2 });
            return d2;
          }
          renderMinorTick(b2, d2) {
            const e2 = this.minorTicks;
            e2[b2] || (e2[b2] = new F(this, b2, "minor"));
            d2 && e2[b2].isNew && e2[b2].render(null, true);
            e2[b2].render(null, false, 1);
          }
          renderTick(b2, d2, e2) {
            const c2 = this.ticks;
            if (!this.isLinked || b2 >= this.min && b2 <= this.max || this.grid && this.grid.isColumn)
              c2[b2] || (c2[b2] = new F(
                this,
                b2
              )), e2 && c2[b2].isNew && c2[b2].render(d2, true, -1), c2[b2].render(d2);
          }
          render() {
            const d2 = this, e2 = d2.chart, c2 = d2.logarithmic, a3 = d2.options, m2 = d2.isLinked, f2 = d2.tickPositions, g2 = d2.axisTitle, w2 = d2.ticks, h2 = d2.minorTicks, k2 = d2.alternateBands, u2 = a3.stackLabels, z2 = a3.alternateGridColor;
            var v2 = a3.crossing;
            const n2 = d2.tickmarkOffset, H2 = d2.axisLine, p2 = d2.showAxis, B2 = t(e2.renderer.globalAnimation);
            let C2, q2;
            d2.labelEdge.length = 0;
            d2.overlap = false;
            [w2, h2, k2].forEach(function(b2) {
              M(b2, function(b3) {
                b3.isActive = false;
              });
            });
            if (b(v2)) {
              const b2 = this.isXAxis ? e2.yAxis[0] : e2.xAxis[0], c3 = [1, -1, -1, 1][this.side];
              b2 && (v2 = b2.toPixels(v2, true), d2.horiz && (v2 = b2.len - v2), d2.offset = c3 * v2);
            }
            if (d2.hasData() || m2) {
              const m3 = d2.chart.hasRendered && d2.old && b(d2.old.min);
              d2.minorTickInterval && !d2.categories && d2.getMinorTickPositions().forEach(function(b2) {
                d2.renderMinorTick(b2, m3);
              });
              f2.length && (f2.forEach(function(b2, e3) {
                d2.renderTick(b2, e3, m3);
              }), n2 && (0 === d2.min || d2.single) && (w2[-1] || (w2[-1] = new F(d2, -1, null, true)), w2[-1].render(-1)));
              z2 && f2.forEach(function(b2, a4) {
                q2 = "undefined" !== typeof f2[a4 + 1] ? f2[a4 + 1] + n2 : d2.max - n2;
                0 === a4 % 2 && b2 < d2.max && q2 <= d2.max + (e2.polar ? -n2 : n2) && (k2[b2] || (k2[b2] = new A.PlotLineOrBand(d2)), C2 = b2 + n2, k2[b2].options = { from: c2 ? c2.lin2log(C2) : C2, to: c2 ? c2.lin2log(q2) : q2, color: z2, className: "highcharts-alternate-grid" }, k2[b2].render(), k2[b2].isActive = true);
              });
              d2._addedPlotLB || (d2._addedPlotLB = true, (a3.plotLines || []).concat(a3.plotBands || []).forEach(function(b2) {
                d2.addPlotBandOrLine(b2);
              }));
            }
            [w2, h2, k2].forEach(function(b2) {
              const d3 = [], c3 = B2.duration;
              M(b2, function(b3, e3) {
                b3.isActive || (b3.render(e3, false, 0), b3.isActive = false, d3.push(e3));
              });
              Y(function() {
                let e3 = d3.length;
                for (; e3--; )
                  b2[d3[e3]] && !b2[d3[e3]].isActive && (b2[d3[e3]].destroy(), delete b2[d3[e3]]);
              }, b2 !== k2 && e2.hasRendered && c3 ? c3 : 0);
            });
            H2 && (H2[H2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(H2.strokeWidth()) }), H2.isPlaced = true, H2[p2 ? "show" : "hide"](p2));
            g2 && p2 && (g2[g2.isNew ? "attr" : "animate"](d2.getTitlePosition(g2)), g2.isNew = false);
            u2 && u2.enabled && d2.stacking && d2.stacking.renderStackTotals();
            d2.old = { len: d2.len, max: d2.max, min: d2.min, transA: d2.transA, userMax: d2.userMax, userMin: d2.userMin };
            d2.isDirty = false;
            l(this, "afterRender");
          }
          redraw() {
            this.visible && (this.render(), this.plotLinesAndBands.forEach(function(b2) {
              b2.render();
            }));
            this.series.forEach(function(b2) {
              b2.isDirty = true;
            });
          }
          getKeepProps() {
            return this.keepProps || W.keepProps;
          }
          destroy(b2) {
            const d2 = this, e2 = d2.plotLinesAndBands, c2 = this.eventOptions;
            l(this, "destroy", { keepEvents: b2 });
            b2 || r(d2);
            [d2.ticks, d2.minorTicks, d2.alternateBands].forEach(function(b3) {
              B(b3);
            });
            if (e2)
              for (b2 = e2.length; b2--; )
                e2[b2].destroy();
            "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b3) {
              d2[b3] && (d2[b3] = d2[b3].destroy());
            });
            for (const b3 in d2.plotLinesAndBandsGroups)
              d2.plotLinesAndBandsGroups[b3] = d2.plotLinesAndBandsGroups[b3].destroy();
            M(d2, function(b3, e3) {
              -1 === d2.getKeepProps().indexOf(e3) && delete d2[e3];
            });
            this.eventOptions = c2;
          }
          drawCrosshair(b2, d2) {
            const c2 = this.crosshair;
            var a3 = H(c2 && c2.snap, true);
            const m2 = this.chart;
            let f2, w2 = this.cross;
            l(this, "drawCrosshair", { e: b2, point: d2 });
            b2 || (b2 = this.cross && this.cross.e);
            if (c2 && false !== (g(d2) || !a3)) {
              a3 ? g(d2) && (f2 = H("colorAxis" !== this.coll ? d2.crosshairPos : null, this.isXAxis ? d2.plotX : this.len - d2.plotY)) : f2 = b2 && (this.horiz ? b2.chartX - this.pos : this.len - b2.chartY + this.pos);
              if (g(f2)) {
                var h2 = { value: d2 && (this.isXAxis ? d2.x : H(d2.stackY, d2.y)), translatedValue: f2 };
                m2.polar && e(h2, { isCrosshair: true, chartX: b2 && b2.chartX, chartY: b2 && b2.chartY, point: d2 });
                h2 = this.getPlotLinePath(h2) || null;
              }
              if (!g(h2)) {
                this.hideCrosshair();
                return;
              }
              a3 = this.categories && !this.isRadial;
              w2 || (this.cross = w2 = m2.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a3 ? "category " : "thin ") + (c2.className || "")).attr({ zIndex: H(c2.zIndex, 2) }).add(), m2.styledMode || (w2.attr({ stroke: c2.color || (a3 ? G.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": H(
                c2.width,
                1
              ) }).css({ "pointer-events": "none" }), c2.dashStyle && w2.attr({ dashstyle: c2.dashStyle })));
              w2.show().attr({ d: h2 });
              a3 && !c2.width && w2.attr({ "stroke-width": this.transA });
              this.cross.e = b2;
            } else
              this.hideCrosshair();
            l(this, "afterDrawCrosshair", { e: b2, point: d2 });
          }
          hideCrosshair() {
            this.cross && this.cross.hide();
            l(this, "afterHideCrosshair");
          }
          hasVerticalPanning() {
            const b2 = this.chart.options.chart.panning;
            return !!(b2 && b2.enabled && /y/.test(b2.type));
          }
          update(b2, d2) {
            const e2 = this.chart;
            b2 = m(this.userOptions, b2);
            this.destroy(true);
            this.init(e2, b2);
            e2.isDirtyBox = true;
            H(d2, true) && e2.redraw();
          }
          remove(b2) {
            const d2 = this.chart, e2 = this.coll, c2 = this.series;
            let a3 = c2.length;
            for (; a3--; )
              c2[a3] && c2[a3].remove(false);
            C(d2.axes, this);
            C(d2[e2] || [], this);
            d2.orderItems(e2);
            this.destroy();
            d2.isDirtyBox = true;
            H(b2, true) && d2.redraw();
          }
          setTitle(b2, d2) {
            this.update({ title: b2 }, d2);
          }
          setCategories(b2, d2) {
            this.update({ categories: b2 }, d2);
          }
        }
        W.defaultOptions = x.defaultXAxisOptions;
        W.keepProps = "coll extKey hcEvents names series userMax userMin".split(" ");
        "";
        return W;
      });
      K(
        a,
        "Core/Axis/DateTimeAxis.js",
        [a["Core/Utilities.js"]],
        function(a2) {
          const { addEvent: r, getMagnitude: G, normalizeTickInterval: I, timeUnits: y } = a2;
          var A;
          (function(A2) {
            function D() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function t(a3) {
              "datetime" !== a3.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new k(this));
            }
            const q = [];
            A2.compose = function(k2) {
              a2.pushUnique(q, k2) && (k2.keepProps.push("dateTime"), k2.prototype.getTimeTicks = D, r(k2, "init", t));
              return k2;
            };
            class k {
              constructor(a3) {
                this.axis = a3;
              }
              normalizeTimeTickInterval(a3, k2) {
                const h = k2 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                k2 = h[h.length - 1];
                let f = y[k2[0]], c = k2[1], g;
                for (g = 0; g < h.length && !(k2 = h[g], f = y[k2[0]], c = k2[1], h[g + 1] && a3 <= (f * c[c.length - 1] + y[h[g + 1][0]]) / 2); g++)
                  ;
                f === y.year && a3 < 5 * f && (c = [1, 2, 5]);
                a3 = I(a3 / f, c, "year" === k2[0] ? Math.max(G(a3 / f), 1) : 1);
                return { unitRange: f, count: a3, unitName: k2[0] };
              }
              getXDateFormat(a3, k2) {
                const { axis: h } = this, f = h.chart.time;
                return h.closestPointRange ? f.getDateFormat(h.closestPointRange, a3, h.options.startOfWeek, k2) || f.resolveDTLFormat(k2.year).main : f.resolveDTLFormat(k2.day).main;
              }
            }
            A2.Additions = k;
          })(A || (A = {}));
          return A;
        }
      );
      K(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: r, normalizeTickInterval: G, pick: I } = a2;
        var y;
        (function(y2) {
          function A(a3) {
            let k = this.logarithmic;
            "logarithmic" !== a3.userOptions.type ? this.logarithmic = void 0 : k || (this.logarithmic = new q(this));
          }
          function D() {
            const a3 = this.logarithmic;
            a3 && (this.lin2val = function(k) {
              return a3.lin2log(k);
            }, this.val2lin = function(k) {
              return a3.log2lin(k);
            });
          }
          const t = [];
          y2.compose = function(k) {
            a2.pushUnique(t, k) && (k.keepProps.push("logarithmic"), r(k, "init", A), r(k, "afterInit", D));
            return k;
          };
          class q {
            constructor(a3) {
              this.axis = a3;
            }
            getLogTickPositions(a3, p, n, h) {
              const f = this.axis;
              var c = f.len, g = f.options;
              let k = [];
              h || (this.minorAutoInterval = void 0);
              if (0.5 <= a3)
                a3 = Math.round(a3), k = f.getLinearTickPositions(a3, p, n);
              else if (0.08 <= a3) {
                g = Math.floor(p);
                let f2, B, e, l, v;
                for (c = 0.3 < a3 ? [1, 2, 4] : 0.15 < a3 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; g < n + 1 && !v; g++)
                  for (B = c.length, f2 = 0; f2 < B && !v; f2++)
                    e = this.log2lin(this.lin2log(g) * c[f2]), e > p && (!h || l <= n) && "undefined" !== typeof l && k.push(l), l > n && (v = true), l = e;
              } else
                p = this.lin2log(p), n = this.lin2log(n), a3 = h ? f.getMinorTickInterval() : g.tickInterval, a3 = I("auto" === a3 ? null : a3, this.minorAutoInterval, g.tickPixelInterval / (h ? 5 : 1) * (n - p) / ((h ? c / f.tickPositions.length : c) || 1)), a3 = G(a3), k = f.getLinearTickPositions(a3, p, n).map(this.log2lin), h || (this.minorAutoInterval = a3 / 5);
              h || (f.tickInterval = a3);
              return k;
            }
            lin2log(a3) {
              return Math.pow(
                10,
                a3
              );
            }
            log2lin(a3) {
              return Math.log(a3) / Math.LN10;
            }
          }
          y2.Additions = q;
        })(y || (y = {}));
        return y;
      });
      K(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { erase: r, extend: G, isNumber: I } = a2;
        var y;
        (function(y2) {
          function A(c) {
            return this.addPlotBandOrLine(c, "plotBands");
          }
          function D(c, a3) {
            const g = this.userOptions;
            let h2 = new f(this, c);
            this.visible && (h2 = h2.render());
            if (h2) {
              this._addedPlotLB || (this._addedPlotLB = true, (g.plotLines || []).concat(g.plotBands || []).forEach((c2) => {
                this.addPlotBandOrLine(c2);
              }));
              if (a3) {
                const f2 = g[a3] || [];
                f2.push(c);
                g[a3] = f2;
              }
              this.plotLinesAndBands.push(h2);
            }
            return h2;
          }
          function t(c) {
            return this.addPlotBandOrLine(c, "plotLines");
          }
          function q(c, a3, f2 = this.options) {
            const g = this.getPlotLinePath({ value: a3, force: true, acrossPanes: f2.acrossPanes }), h2 = [], e = this.horiz;
            a3 = !I(this.min) || !I(this.max) || c < this.min && a3 < this.min || c > this.max && a3 > this.max;
            c = this.getPlotLinePath({ value: c, force: true, acrossPanes: f2.acrossPanes });
            f2 = 1;
            let l;
            if (c && g)
              for (a3 && (l = c.toString() === g.toString(), f2 = 0), a3 = 0; a3 < c.length; a3 += 2) {
                const k2 = c[a3], z = c[a3 + 1], u = g[a3], b = g[a3 + 1];
                "M" !== k2[0] && "L" !== k2[0] || "M" !== z[0] && "L" !== z[0] || "M" !== u[0] && "L" !== u[0] || "M" !== b[0] && "L" !== b[0] || (e && u[1] === k2[1] ? (u[1] += f2, b[1] += f2) : e || u[2] !== k2[2] || (u[2] += f2, b[2] += f2), h2.push(["M", k2[1], k2[2]], ["L", z[1], z[2]], ["L", b[1], b[2]], ["L", u[1], u[2]], ["Z"]));
                h2.isFlat = l;
              }
            return h2;
          }
          function k(c) {
            this.removePlotBandOrLine(c);
          }
          function p(c) {
            const a3 = this.plotLinesAndBands, f2 = this.options, h2 = this.userOptions;
            if (a3) {
              let g = a3.length;
              for (; g--; )
                a3[g].id === c && a3[g].destroy();
              [
                f2.plotLines || [],
                h2.plotLines || [],
                f2.plotBands || [],
                h2.plotBands || []
              ].forEach(function(e) {
                for (g = e.length; g--; )
                  (e[g] || {}).id === c && r(e, e[g]);
              });
            }
          }
          function n(c) {
            this.removePlotBandOrLine(c);
          }
          const h = [];
          let f;
          y2.compose = function(c, g) {
            f || (f = c);
            a2.pushUnique(h, g) && G(g.prototype, { addPlotBand: A, addPlotLine: t, addPlotBandOrLine: D, getPlotBandPath: q, removePlotBand: k, removePlotLine: n, removePlotBandOrLine: p });
            return g;
          };
        })(y || (y = {}));
        return y;
      });
      K(
        a,
        "Core/Axis/PlotLineOrBand/PlotLineOrBand.js",
        [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]],
        function(a2, x) {
          const { arrayMax: r, arrayMin: I, defined: y, destroyObjectProperties: A, erase: F, fireEvent: D, merge: t, objectEach: q, pick: k } = x;
          class p {
            static compose(k2) {
              return a2.compose(p, k2);
            }
            constructor(a3, h) {
              this.axis = a3;
              h && (this.options = h, this.id = h.id);
            }
            render() {
              D(this, "render");
              const a3 = this, h = a3.axis, f = h.horiz;
              var c = h.logarithmic;
              const g = a3.options, p2 = g.color, C = k(g.zIndex, 0), E = g.events, e = {}, l = h.chart.renderer;
              let v = g.label, z = a3.label, u = g.to, b = g.from, d = g.value, m = a3.svgElem;
              var w = [];
              const M = y(b) && y(u);
              w = y(d);
              const H = !m, N = { "class": "highcharts-plot-" + (M ? "band " : "line ") + (g.className || "") };
              let r2 = M ? "bands" : "lines";
              c && (b = c.log2lin(b), u = c.log2lin(u), d = c.log2lin(d));
              h.chart.styledMode || (w ? (N.stroke = p2 || "#999999", N["stroke-width"] = k(g.width, 1), g.dashStyle && (N.dashstyle = g.dashStyle)) : M && (N.fill = p2 || "#e6e9ff", g.borderWidth && (N.stroke = g.borderColor, N["stroke-width"] = g.borderWidth)));
              e.zIndex = C;
              r2 += "-" + C;
              (c = h.plotLinesAndBandsGroups[r2]) || (h.plotLinesAndBandsGroups[r2] = c = l.g("plot-" + r2).attr(e).add());
              H && (a3.svgElem = m = l.path().attr(N).add(c));
              if (w)
                w = h.getPlotLinePath({ value: d, lineWidth: m.strokeWidth(), acrossPanes: g.acrossPanes });
              else if (M)
                w = h.getPlotBandPath(b, u, g);
              else
                return;
              !a3.eventsAdded && E && (q(E, function(b2, d2) {
                m.on(d2, function(b3) {
                  E[d2].apply(a3, [b3]);
                });
              }), a3.eventsAdded = true);
              (H || !m.d) && w && w.length ? m.attr({ d: w }) : m && (w ? (m.show(), m.animate({ d: w })) : m.d && (m.hide(), z && (a3.label = z = z.destroy())));
              v && (y(v.text) || y(v.formatter)) && w && w.length && 0 < h.width && 0 < h.height && !w.isFlat ? (v = t({ align: f && M && "center", x: f ? !M && 4 : 10, verticalAlign: !f && M && "middle", y: f ? M ? 16 : 10 : M ? 6 : -4, rotation: f && !M && 90 }, v), this.renderLabel(v, w, M, C)) : z && z.hide();
              return a3;
            }
            renderLabel(a3, h, f, c) {
              const g = this.axis;
              var k2 = g.chart.renderer;
              let n = this.label;
              n || (this.label = n = k2.text(this.getLabelText(a3), 0, 0, a3.useHTML).attr({ align: a3.textAlign || a3.align, rotation: a3.rotation, "class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (a3.className || ""), zIndex: c }).add(), g.chart.styledMode || n.css(t({ fontSize: "0.8em", textOverflow: "ellipsis" }, a3.style)));
              c = h.xBounds || [h[0][1], h[1][1], f ? h[2][1] : h[0][1]];
              h = h.yBounds || [h[0][2], h[1][2], f ? h[2][2] : h[0][2]];
              f = I(c);
              k2 = I(h);
              n.align(a3, false, { x: f, y: k2, width: r(c) - f, height: r(h) - k2 });
              n.alignValue && "left" !== n.alignValue || (a3 = a3.clip ? g.width : g.chart.chartWidth, n.css({ width: (90 === n.rotation ? g.height - (n.alignAttr.y - g.top) : a3 - (n.alignAttr.x - g.left)) + "px" }));
              n.show(true);
            }
            getLabelText(a3) {
              return y(a3.formatter) ? a3.formatter.call(this) : a3.text;
            }
            destroy() {
              F(this.axis.plotLinesAndBands, this);
              delete this.axis;
              A(this);
            }
          }
          "";
          "";
          return p;
        }
      );
      K(a, "Core/Tooltip.js", [
        a["Core/Templating.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y) {
        const { format: r } = a2, { doc: F, isSafari: D } = x, { distribute: t } = G, { addEvent: q, clamp: k, css: p, discardElement: n, extend: h, fireEvent: f, isArray: c, isNumber: g, isString: B, merge: C, pick: E, splat: e, syncTimeout: l } = y;
        class v {
          constructor(e2, c2) {
            this.allowShared = true;
            this.container = void 0;
            this.crosshairs = [];
            this.distance = 0;
            this.isHidden = true;
            this.isSticky = false;
            this.now = {};
            this.options = {};
            this.outside = false;
            this.chart = e2;
            this.init(e2, c2);
          }
          bodyFormatter(e2) {
            return e2.map(function(e3) {
              const b = e3.series.tooltipOptions;
              return (b[(e3.point.formatPrefix || "point") + "Formatter"] || e3.point.tooltipFormatter).call(e3.point, b[(e3.point.formatPrefix || "point") + "Format"] || "");
            });
          }
          cleanSplit(e2) {
            this.chart.series.forEach(function(c2) {
              const b = c2 && c2.tt;
              b && (!b.isActive || e2 ? c2.tt = b.destroy() : b.isActive = false);
            });
          }
          defaultFormatter(c2) {
            const a3 = this.points || e(this);
            let b;
            b = [c2.tooltipFooterHeaderFormatter(a3[0])];
            b = b.concat(c2.bodyFormatter(a3));
            b.push(c2.tooltipFooterHeaderFormatter(
              a3[0],
              true
            ));
            return b;
          }
          destroy() {
            this.label && (this.label = this.label.destroy());
            this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy()));
            this.renderer && (this.renderer = this.renderer.destroy(), n(this.container));
            y.clearTimeout(this.hideTimer);
            y.clearTimeout(this.tooltipTimeout);
          }
          getAnchor(c2, a3) {
            var b = this.chart;
            const d = b.pointer, m = b.inverted, f2 = b.plotTop;
            b = b.plotLeft;
            c2 = e(c2);
            c2[0].series && c2[0].series.yAxis && !c2[0].series.yAxis.options.reversedStacks && (c2 = c2.slice().reverse());
            if (this.followPointer && a3)
              "undefined" === typeof a3.chartX && (a3 = d.normalize(a3)), c2 = [a3.chartX - b, a3.chartY - f2];
            else if (c2[0].tooltipPos)
              c2 = c2[0].tooltipPos;
            else {
              let d2 = 0, e2 = 0;
              c2.forEach(function(b2) {
                if (b2 = b2.pos(true))
                  d2 += b2[0], e2 += b2[1];
              });
              d2 /= c2.length;
              e2 /= c2.length;
              this.shared && 1 < c2.length && a3 && (m ? d2 = a3.chartX : e2 = a3.chartY);
              c2 = [d2 - b, e2 - f2];
            }
            return c2.map(Math.round);
          }
          getClassName(e2, c2, b) {
            const d = e2.series, a3 = d.options;
            return [this.options.className, "highcharts-label", b && "highcharts-tooltip-header", c2 ? "highcharts-tooltip-box" : "highcharts-tooltip", !b && "highcharts-color-" + E(
              e2.colorIndex,
              d.colorIndex
            ), a3 && a3.className].filter(B).join(" ");
          }
          getLabel() {
            const e2 = this, c2 = this.chart.styledMode, b = this.options, d = this.split && this.allowShared, a3 = b.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none");
            let f2, l2 = this.chart.renderer;
            if (this.label) {
              var g2 = !this.label.hasClass("highcharts-label");
              (!d && g2 || d && !g2) && this.destroy();
            }
            if (!this.label) {
              if (this.outside) {
                g2 = this.chart.options.chart.style;
                const b2 = I.getRendererType();
                this.container = f2 = x.doc.createElement("div");
                f2.className = "highcharts-tooltip-container";
                p(f2, { position: "absolute", top: "1px", pointerEvents: a3, zIndex: Math.max(this.options.style.zIndex || 0, (g2 && g2.zIndex || 0) + 3) });
                x.doc.body.appendChild(f2);
                this.renderer = l2 = new b2(f2, 0, 0, g2, void 0, void 0, l2.styledMode);
              }
              d ? this.label = l2.g("tooltip") : (this.label = l2.label("", 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, "tooltip").attr({ padding: b.padding, r: b.borderRadius }), c2 || this.label.attr({ fill: b.backgroundColor, "stroke-width": b.borderWidth || 0 }).css(b.style).css({ pointerEvents: a3 }));
              if (e2.outside) {
                const b2 = this.label, {
                  xSetter: d2,
                  ySetter: c3
                } = b2;
                b2.xSetter = function(c4) {
                  d2.call(b2, e2.distance);
                  f2.style.left = c4 + "px";
                };
                b2.ySetter = function(d3) {
                  c3.call(b2, e2.distance);
                  f2.style.top = d3 + "px";
                };
              }
              this.label.attr({ zIndex: 8 }).shadow(b.shadow).add();
            }
            return this.label;
          }
          getPlayingField() {
            const { body: e2, documentElement: c2 } = F, { chart: b, distance: d, outside: a3 } = this;
            return { width: a3 ? Math.max(e2.scrollWidth, c2.scrollWidth, e2.offsetWidth, c2.offsetWidth, c2.clientWidth) - 2 * d : b.chartWidth, height: a3 ? Math.max(e2.scrollHeight, c2.scrollHeight, e2.offsetHeight, c2.offsetHeight, c2.clientHeight) : b.chartHeight };
          }
          getPosition(e2, c2, b) {
            const d = this.chart, a3 = this.distance, f2 = {}, l2 = d.inverted && b.h || 0, g2 = this.outside;
            var h2 = this.getPlayingField();
            const k2 = h2.width, u = h2.height, v2 = d.pointer.getChartPosition();
            h2 = (m) => {
              const f3 = "x" === m;
              return [m, f3 ? k2 : u, f3 ? e2 : c2].concat(g2 ? [f3 ? e2 * v2.scaleX : c2 * v2.scaleY, f3 ? v2.left - a3 + (b.plotX + d.plotLeft) * v2.scaleX : v2.top - a3 + (b.plotY + d.plotTop) * v2.scaleY, 0, f3 ? k2 : u] : [f3 ? e2 : c2, f3 ? b.plotX + d.plotLeft : b.plotY + d.plotTop, f3 ? d.plotLeft : d.plotTop, f3 ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);
            };
            let z = h2("y"), n2 = h2("x"), p2;
            h2 = !!b.negative;
            !d.polar && d.hoverSeries && d.hoverSeries.yAxis && d.hoverSeries.yAxis.reversed && (h2 = !h2);
            const B2 = !this.followPointer && E(b.ttBelow, !d.inverted === h2), q2 = function(b2, d2, e3, c3, m, h3, w) {
              const k3 = g2 ? "y" === b2 ? a3 * v2.scaleY : a3 * v2.scaleX : a3, u2 = (e3 - c3) / 2, z2 = c3 < m - a3, n3 = m + a3 + c3 < d2, H = m - k3 - e3 + u2;
              m = m + k3 - u2;
              if (B2 && n3)
                f2[b2] = m;
              else if (!B2 && z2)
                f2[b2] = H;
              else if (z2)
                f2[b2] = Math.min(w - c3, 0 > H - l2 ? H : H - l2);
              else if (n3)
                f2[b2] = Math.max(h3, m + l2 + e3 > d2 ? m : m + l2);
              else
                return false;
            }, C2 = function(b2, d2, e3, c3, m) {
              let l3;
              m < a3 || m > d2 - a3 ? l3 = false : f2[b2] = m < e3 / 2 ? 1 : m > d2 - c3 / 2 ? d2 - c3 - 2 : m - e3 / 2;
              return l3;
            }, t2 = function(b2) {
              const d2 = z;
              z = n2;
              n2 = d2;
              p2 = b2;
            }, L = function() {
              false !== q2.apply(0, z) ? false !== C2.apply(0, n2) || p2 || (t2(true), L()) : p2 ? f2.x = f2.y = 0 : (t2(true), L());
            };
            (d.inverted || 1 < this.len) && t2();
            L();
            return f2;
          }
          hide(e2) {
            const c2 = this;
            y.clearTimeout(this.hideTimer);
            e2 = E(e2, this.options.hideDelay);
            this.isHidden || (this.hideTimer = l(function() {
              c2.getLabel().fadeOut(e2 ? void 0 : e2);
              c2.isHidden = true;
            }, e2));
          }
          init(e2, c2) {
            this.chart = e2;
            this.options = c2;
            this.crosshairs = [];
            this.now = { x: 0, y: 0 };
            this.isHidden = true;
            this.split = c2.split && !e2.inverted && !e2.polar;
            this.shared = c2.shared || this.split;
            this.outside = E(c2.outside, !(!e2.scrollablePixelsX && !e2.scrollablePixelsY));
          }
          shouldStickOnContact(e2) {
            return !(this.followPointer || !this.options.stickOnContact || e2 && !this.chart.pointer.inClass(e2.target, "highcharts-tooltip"));
          }
          move(e2, c2, b, d) {
            const a3 = this, f2 = a3.now, l2 = false !== a3.options.animation && !a3.isHidden && (1 < Math.abs(e2 - f2.x) || 1 < Math.abs(c2 - f2.y)), g2 = a3.followPointer || 1 < a3.len;
            h(f2, { x: l2 ? (2 * f2.x + e2) / 3 : e2, y: l2 ? (f2.y + c2) / 2 : c2, anchorX: g2 ? void 0 : l2 ? (2 * f2.anchorX + b) / 3 : b, anchorY: g2 ? void 0 : l2 ? (f2.anchorY + d) / 2 : d });
            a3.getLabel().attr(f2);
            a3.drawTracker();
            l2 && (y.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
              a3 && a3.move(e2, c2, b, d);
            }, 32));
          }
          refresh(a3, l2) {
            const b = this.chart, d = this.options, m = b.pointer, g2 = e(a3), h2 = g2[0], k2 = [];
            var v2 = d.format, u = d.formatter || this.defaultFormatter;
            const z = this.shared, n2 = b.styledMode;
            let p2 = {};
            if (d.enabled && h2.series) {
              y.clearTimeout(this.hideTimer);
              this.allowShared = !(!c(a3) && a3.series && a3.series.noSharedTooltip);
              this.followPointer = !this.split && h2.series.tooltipOptions.followPointer;
              a3 = this.getAnchor(a3, l2);
              var q2 = a3[0], C2 = a3[1];
              z && this.allowShared ? (m.applyInactiveState(g2), g2.forEach(function(b2) {
                b2.setState("hover");
                k2.push(b2.getLabelConfig());
              }), p2 = h2.getLabelConfig(), p2.points = k2) : p2 = h2.getLabelConfig();
              this.len = k2.length;
              v2 = B(v2) ? r(v2, p2, b) : u.call(p2, this);
              u = h2.series;
              this.distance = E(u.tooltipOptions.distance, 16);
              if (false === v2)
                this.hide();
              else {
                if (this.split && this.allowShared)
                  this.renderSplit(v2, g2);
                else {
                  let e2 = q2, c2 = C2;
                  l2 && m.isDirectTouch && (e2 = l2.chartX - b.plotLeft, c2 = l2.chartY - b.plotTop);
                  if (b.polar || false === u.options.clip || g2.some((b2) => m.isDirectTouch || b2.series.shouldShowTooltip(
                    e2,
                    c2
                  )))
                    l2 = this.getLabel(), d.style.width && !n2 || l2.css({ width: (this.outside ? this.getPlayingField() : b.spacingBox).width + "px" }), l2.attr({ text: v2 && v2.join ? v2.join("") : v2 }), l2.addClass(this.getClassName(h2), true), n2 || l2.attr({ stroke: d.borderColor || h2.color || u.color || "#666666" }), this.updatePosition({ plotX: q2, plotY: C2, negative: h2.negative, ttBelow: h2.ttBelow, h: a3[2] || 0 });
                  else {
                    this.hide();
                    return;
                  }
                }
                this.isHidden && this.label && this.label.attr({ opacity: 1 }).show();
                this.isHidden = false;
              }
              f(this, "refresh");
            }
          }
          renderSplit(e2, c2) {
            function b(b2, e3, c3, a4, m = true) {
              c3 ? (e3 = O ? 0 : ca, b2 = k(b2 - a4 / 2, L.left, L.right - a4 - (d.outside ? U : 0))) : (e3 -= I2, b2 = m ? b2 - a4 - y2 : b2 + y2, b2 = k(b2, m ? b2 : L.left, L.right));
              return { x: b2, y: e3 };
            }
            const d = this, { chart: a3, chart: { chartWidth: f2, chartHeight: l2, plotHeight: g2, plotLeft: v2, plotTop: u, pointer: z, scrollablePixelsY: n2 = 0, scrollablePixelsX: p2, scrollingContainer: { scrollLeft: q2, scrollTop: C2 } = { scrollLeft: 0, scrollTop: 0 }, styledMode: r2 }, distance: y2, options: A, options: { positioner: x2 } } = d, L = d.outside && "number" !== typeof p2 ? F.documentElement.getBoundingClientRect() : {
              left: q2,
              right: q2 + f2,
              top: C2,
              bottom: C2 + l2
            }, Q = d.getLabel(), S = this.renderer || a3.renderer, O = !(!a3.xAxis[0] || !a3.xAxis[0].opposite), { left: U, top: G2 } = z.getChartPosition();
            let I2 = u + C2, aa = 0, ca = g2 - n2;
            B(e2) && (e2 = [false, e2]);
            e2 = e2.slice(0, c2.length + 1).reduce(function(e3, a4, m) {
              if (false !== a4 && "" !== a4) {
                m = c2[m - 1] || { isHeader: true, plotX: c2[0].plotX, plotY: g2, series: {} };
                const n3 = m.isHeader;
                var f3 = n3 ? d : m.series, l3;
                {
                  var h2 = m;
                  a4 = a4.toString();
                  var w = f3.tt;
                  const { isHeader: b2, series: e4 } = h2;
                  w || (w = { padding: A.padding, r: A.borderRadius }, r2 || (w.fill = A.backgroundColor, w["stroke-width"] = null !== (l3 = A.borderWidth) && void 0 !== l3 ? l3 : 1), w = S.label("", 0, 0, A[b2 ? "headerShape" : "shape"], void 0, void 0, A.useHTML).addClass(d.getClassName(h2, true, b2)).attr(w).add(Q));
                  w.isActive = true;
                  w.attr({ text: a4 });
                  r2 || w.css(A.style).attr({ stroke: A.borderColor || h2.color || e4.color || "#333333" });
                  l3 = w;
                }
                l3 = f3.tt = l3;
                h2 = l3.getBBox();
                f3 = h2.width + l3.strokeWidth();
                n3 && (aa = h2.height, ca += aa, O && (I2 -= aa));
                {
                  const { isHeader: b2, plotX: d2 = 0, plotY: e4 = 0, series: c3 } = m;
                  if (b2) {
                    a4 = v2 + d2;
                    var z2 = u + g2 / 2;
                  } else {
                    const { xAxis: b3, yAxis: m2 } = c3;
                    a4 = b3.pos + k(d2, -y2, b3.len + y2);
                    c3.shouldShowTooltip(0, m2.pos - u + e4, { ignoreX: true }) && (z2 = m2.pos + e4);
                  }
                  a4 = k(a4, L.left - y2, L.right + y2);
                  z2 = { anchorX: a4, anchorY: z2 };
                }
                const { anchorX: H, anchorY: p3 } = z2;
                "number" === typeof p3 ? (z2 = h2.height + 1, h2 = x2 ? x2.call(d, f3, z2, m) : b(H, p3, n3, f3), e3.push({ align: x2 ? 0 : void 0, anchorX: H, anchorY: p3, boxWidth: f3, point: m, rank: E(h2.rank, n3 ? 1 : 0), size: z2, target: h2.y, tt: l3, x: h2.x })) : l3.isActive = false;
              }
              return e3;
            }, []);
            !x2 && e2.some((b2) => {
              var { outside: e3 } = d;
              e3 = (e3 ? U : 0) + b2.anchorX;
              return e3 < L.left && e3 + b2.boxWidth < L.right ? true : e3 < U - L.left + b2.boxWidth && L.right - e3 > e3;
            }) && (e2 = e2.map((d2) => {
              const { x: e3, y: c3 } = b(
                d2.anchorX,
                d2.anchorY,
                d2.point.isHeader,
                d2.boxWidth,
                false
              );
              return h(d2, { target: c3, x: e3 });
            }));
            d.cleanSplit();
            t(e2, ca);
            var ba = U, K2 = U;
            e2.forEach(function(b2) {
              const { x: e3, boxWidth: c3, isHeader: a4 } = b2;
              a4 || (d.outside && U + e3 < ba && (ba = U + e3), !a4 && d.outside && ba + c3 > K2 && (K2 = U + e3));
            });
            e2.forEach(function(b2) {
              const { x: e3, anchorX: c3, anchorY: a4, pos: m, point: { isHeader: f3 } } = b2, l3 = { visibility: "undefined" === typeof m ? "hidden" : "inherit", x: e3, y: (m || 0) + I2, anchorX: c3, anchorY: a4 };
              if (d.outside && e3 < c3) {
                const b3 = U - ba;
                0 < b3 && (f3 || (l3.x = e3 + b3, l3.anchorX = c3 + b3), f3 && (l3.x = (K2 - ba) / 2, l3.anchorX = c3 + b3));
              }
              b2.tt.attr(l3);
            });
            const {
              container: ha,
              outside: ka,
              renderer: ja
            } = d;
            if (ka && ha && ja) {
              const { width: b2, height: d2, x: e3, y: c3 } = Q.getBBox();
              ja.setSize(b2 + e3, d2 + c3, false);
              ha.style.left = ba + "px";
              ha.style.top = G2 + "px";
            }
            D && Q.attr({ opacity: 1 === Q.opacity ? 0.999 : 1 });
          }
          drawTracker() {
            if (this.shouldStickOnContact()) {
              var e2 = this.chart, c2 = this.label, b = this.shared ? e2.hoverPoints : e2.hoverPoint;
              if (c2 && b) {
                var d = { x: 0, y: 0, width: 0, height: 0 };
                b = this.getAnchor(b);
                var a3 = c2.getBBox();
                b[0] += e2.plotLeft - c2.translateX;
                b[1] += e2.plotTop - c2.translateY;
                d.x = Math.min(0, b[0]);
                d.y = Math.min(0, b[1]);
                d.width = 0 > b[0] ? Math.max(Math.abs(b[0]), a3.width - b[0]) : Math.max(Math.abs(b[0]), a3.width);
                d.height = 0 > b[1] ? Math.max(Math.abs(b[1]), a3.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), a3.height);
                this.tracker ? this.tracker.attr(d) : (this.tracker = c2.renderer.rect(d).addClass("highcharts-tracker").add(c2), e2.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
              }
            } else
              this.tracker && (this.tracker = this.tracker.destroy());
          }
          styledModeFormat(e2) {
            return e2.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(
              /style="color:{(point|series)\.color}"/g,
              'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"'
            );
          }
          tooltipFooterHeaderFormatter(e2, c2) {
            const b = e2.series, d = b.tooltipOptions;
            var a3 = b.xAxis;
            const l2 = a3 && a3.dateTime;
            a3 = { isFooter: c2, labelConfig: e2 };
            let h2 = d.xDateFormat, k2 = d[c2 ? "footerFormat" : "headerFormat"];
            f(this, "headerFormatter", a3, function(c3) {
              l2 && !h2 && g(e2.key) && (h2 = l2.getXDateFormat(e2.key, d.dateTimeLabelFormats));
              l2 && h2 && (e2.point && e2.point.tooltipDateKeys || ["key"]).forEach(function(b2) {
                k2 = k2.replace("{point." + b2 + "}", "{point." + b2 + ":" + h2 + "}");
              });
              b.chart.styledMode && (k2 = this.styledModeFormat(k2));
              c3.text = r(k2, { point: e2, series: b }, this.chart);
            });
            return a3.text;
          }
          update(e2) {
            this.destroy();
            this.init(this.chart, C(true, this.options, e2));
          }
          updatePosition(e2) {
            const { chart: c2, distance: b, options: d } = this;
            var a3 = c2.pointer;
            const f2 = this.getLabel(), { left: l2, top: g2, scaleX: h2, scaleY: k2 } = a3.getChartPosition();
            a3 = (d.positioner || this.getPosition).call(this, f2.width, f2.height, e2);
            let v2 = (e2.plotX || 0) + c2.plotLeft;
            e2 = (e2.plotY || 0) + c2.plotTop;
            let n2;
            if (this.outside) {
              d.positioner && (a3.x += l2 - b, a3.y += g2 - b);
              n2 = (d.borderWidth || 0) + 2 * b;
              this.renderer.setSize(f2.width + n2, f2.height + n2, false);
              if (1 !== h2 || 1 !== k2)
                p(this.container, { transform: `scale(${h2}, ${k2})` }), v2 *= h2, e2 *= k2;
              v2 += l2 - a3.x;
              e2 += g2 - a3.y;
            }
            this.move(Math.round(a3.x), Math.round(a3.y || 0), v2, e2);
          }
        }
        (function(e2) {
          const c2 = [];
          e2.compose = function(b) {
            y.pushUnique(c2, b) && q(b, "afterInit", function() {
              const b2 = this.chart;
              b2.options.tooltip && (b2.tooltip = new e2(b2, b2.options.tooltip));
            });
          };
        })(v || (v = {}));
        "";
        return v;
      });
      K(a, "Core/Series/Point.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y) {
        const { animObject: r } = x, { defaultOptions: F } = G, { format: D } = I, { addEvent: t, defined: q, erase: k, extend: p, fireEvent: n, getNestedProperty: h, isArray: f, isFunction: c, isNumber: g, isObject: B, merge: C, objectEach: E, pick: e, syncTimeout: l, removeEvent: v, uniqueKey: z } = y;
        class u {
          constructor() {
            this.category = void 0;
            this.destroyed = false;
            this.formatPrefix = "point";
            this.id = void 0;
            this.isNull = false;
            this.percentage = this.options = this.name = void 0;
            this.selected = false;
            this.total = this.shapeArgs = this.series = void 0;
            this.visible = true;
            this.x = void 0;
          }
          animateBeforeDestroy() {
            const b = this, d = { x: b.startXPos, opacity: 0 }, e2 = b.getGraphicalProps();
            e2.singular.forEach(function(e3) {
              b[e3] = b[e3].animate("dataLabel" === e3 ? { x: b[e3].startXPos, y: b[e3].startYPos, opacity: 0 } : d);
            });
            e2.plural.forEach(function(d2) {
              b[d2].forEach(function(d3) {
                d3.element && d3.animate(p({ x: b.startXPos }, d3.startYPos ? { x: d3.startXPos, y: d3.startYPos } : {}));
              });
            });
          }
          applyOptions(b, d) {
            const e2 = this.series, c2 = e2.options.pointValKey || e2.pointValKey;
            b = u.prototype.optionsToObject.call(this, b);
            p(this, b);
            this.options = this.options ? p(this.options, b) : b;
            b.group && delete this.group;
            b.dataLabels && delete this.dataLabels;
            c2 && (this.y = u.prototype.getNestedProperty.call(this, c2));
            this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? "null" : "point";
            this.selected && (this.state = "select");
            "name" in this && "undefined" === typeof d && e2.xAxis && e2.xAxis.hasNames && (this.x = e2.xAxis.nameToX(this));
            "undefined" === typeof this.x && e2 ? this.x = "undefined" === typeof d ? e2.autoIncrement() : d : g(b.x) && e2.options.relativeXValue && (this.x = e2.autoIncrement(b.x));
            return this;
          }
          destroy() {
            if (!this.destroyed) {
              const d = this;
              var b = d.series;
              const e2 = b.chart;
              b = b.options.dataSorting;
              const c2 = e2.hoverPoints, a3 = r(d.series.chart.renderer.globalAnimation), f2 = () => {
                if (d.graphic || d.graphics || d.dataLabel || d.dataLabels)
                  v(d), d.destroyElements();
                for (const b2 in d)
                  delete d[b2];
              };
              d.legendItem && e2.legend.destroyItem(d);
              c2 && (d.setState(), k(c2, d), c2.length || (e2.hoverPoints = null));
              if (d === e2.hoverPoint)
                d.onMouseOut();
              b && b.enabled ? (this.animateBeforeDestroy(), l(f2, a3.duration)) : f2();
              e2.pointCount--;
            }
            this.destroyed = true;
          }
          destroyElements(b) {
            const d = this;
            b = d.getGraphicalProps(b);
            b.singular.forEach(function(b2) {
              d[b2] = d[b2].destroy();
            });
            b.plural.forEach(function(b2) {
              d[b2].forEach(function(b3) {
                b3 && b3.element && b3.destroy();
              });
              delete d[b2];
            });
          }
          firePointEvent(b, d, e2) {
            const c2 = this, a3 = this.series.options;
            (a3.point.events[b] || c2.options && c2.options.events && c2.options.events[b]) && c2.importEvents();
            "click" === b && a3.allowPointSelect && (e2 = function(b2) {
              c2.select && c2.select(null, b2.ctrlKey || b2.metaKey || b2.shiftKey);
            });
            n(c2, b, d, e2);
          }
          getClassName() {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
          }
          getGraphicalProps(b) {
            const d = this, e2 = [], c2 = { singular: [], plural: [] };
            let a3, f2;
            b = b || { graphic: 1, dataLabel: 1 };
            b.graphic && e2.push("graphic");
            b.dataLabel && e2.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
            for (f2 = e2.length; f2--; )
              a3 = e2[f2], d[a3] && c2.singular.push(a3);
            ["graphic", "dataLabel", "connector"].forEach(function(e3) {
              const a4 = e3 + "s";
              b[e3] && d[a4] && c2.plural.push(a4);
            });
            return c2;
          }
          getLabelConfig() {
            return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
          }
          getNestedProperty(b) {
            if (b)
              return 0 === b.indexOf("custom.") ? h(b, this.options) : this[b];
          }
          getZone() {
            var b = this.series;
            const d = b.zones;
            b = b.zoneAxis || "y";
            let e2, c2 = 0;
            for (e2 = d[c2]; this[b] >= e2.value; )
              e2 = d[++c2];
            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = e2 && e2.color && !this.options.color ? e2.color : this.nonZonedColor;
            return e2;
          }
          hasNewShapeType() {
            return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
          }
          init(b, d, e2) {
            this.series = b;
            this.applyOptions(d, e2);
            this.id = q(this.id) ? this.id : z();
            this.resolveColor();
            b.chart.pointCount++;
            n(this, "afterInit");
            return this;
          }
          isValid() {
            return null !== this.x && g(this.y);
          }
          optionsToObject(b) {
            var d = this.series;
            const e2 = d.options.keys, c2 = e2 || d.pointArrayMap || ["y"], a3 = c2.length;
            let l2 = {}, h2 = 0, k2 = 0;
            if (g(b) || null === b)
              l2[c2[0]] = b;
            else if (f(b))
              for (!e2 && b.length > a3 && (d = typeof b[0], "string" === d ? l2.name = b[0] : "number" === d && (l2.x = b[0]), h2++); k2 < a3; )
                e2 && "undefined" === typeof b[h2] || (0 < c2[k2].indexOf(".") ? u.prototype.setNestedProperty(l2, b[h2], c2[k2]) : l2[c2[k2]] = b[h2]), h2++, k2++;
            else
              "object" === typeof b && (l2 = b, b.dataLabels && (d._hasPointLabels = true), b.marker && (d._hasPointMarkers = true));
            return l2;
          }
          pos(b, d = this.plotY) {
            if (!this.destroyed) {
              const { plotX: e2, series: c2 } = this, { chart: a3, xAxis: f2, yAxis: l2 } = c2;
              let h2 = 0, k2 = 0;
              if (g(e2) && g(d))
                return b && (h2 = f2 ? f2.pos : a3.plotLeft, k2 = l2 ? l2.pos : a3.plotTop), a3.inverted && f2 && l2 ? [l2.len - d + k2, f2.len - e2 + h2] : [e2 + h2, d + k2];
            }
          }
          resolveColor() {
            const b = this.series;
            var d = b.chart.styledMode;
            let c2;
            var a3 = b.chart.options.chart.colorCount;
            delete this.nonZonedColor;
            b.options.colorByPoint ? (d || (a3 = b.options.colors || b.chart.options.colors, c2 = a3[b.colorCounter], a3 = a3.length), d = b.colorCounter, b.colorCounter++, b.colorCounter === a3 && (b.colorCounter = 0)) : (d || (c2 = b.color), d = b.colorIndex);
            this.colorIndex = e(this.options.colorIndex, d);
            this.color = e(this.options.color, c2);
          }
          setNestedProperty(b, d, e2) {
            e2.split(".").reduce(function(b2, e3, c2, a3) {
              b2[e3] = a3.length - 1 === c2 ? d : B(b2[e3], true) ? b2[e3] : {};
              return b2[e3];
            }, b);
            return b;
          }
          shouldDraw() {
            return !this.isNull;
          }
          tooltipFormatter(b) {
            const d = this.series, c2 = d.tooltipOptions, a3 = e(c2.valueDecimals, ""), f2 = c2.valuePrefix || "", l2 = c2.valueSuffix || "";
            d.chart.styledMode && (b = d.chart.tooltip.styledModeFormat(b));
            (d.pointArrayMap || ["y"]).forEach(function(d2) {
              d2 = "{point." + d2;
              if (f2 || l2)
                b = b.replace(RegExp(d2 + "}", "g"), f2 + d2 + "}" + l2);
              b = b.replace(RegExp(d2 + "}", "g"), d2 + ":,." + a3 + "f}");
            });
            return D(b, { point: this, series: this.series }, d.chart);
          }
          update(b, d, c2, a3) {
            function f2() {
              m.applyOptions(b);
              var a4 = g2 && m.hasMockGraphic;
              a4 = null === m.y ? !a4 : a4;
              g2 && a4 && (m.graphic = g2.destroy(), delete m.hasMockGraphic);
              B(b, true) && (g2 && g2.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (m.graphic = g2.destroy()), b && b.dataLabels && m.dataLabel && (m.dataLabel = m.dataLabel.destroy()), m.connector && (m.connector = m.connector.destroy()));
              w = m.index;
              l2.updateParallelArrays(m, w);
              k2.data[w] = B(k2.data[w], true) || B(b, true) ? m.options : e(b, k2.data[w]);
              l2.isDirty = l2.isDirtyData = true;
              !l2.fixedBox && l2.hasCartesianSeries && (h2.isDirtyBox = true);
              "point" === k2.legendType && (h2.isDirtyLegend = true);
              d && h2.redraw(c2);
            }
            const m = this, l2 = m.series, g2 = m.graphic, h2 = l2.chart, k2 = l2.options;
            let w;
            d = e(d, true);
            false === a3 ? f2() : m.firePointEvent("update", { options: b }, f2);
          }
          remove(b, d) {
            this.series.removePoint(
              this.series.data.indexOf(this),
              b,
              d
            );
          }
          select(b, d) {
            const c2 = this, a3 = c2.series, f2 = a3.chart;
            this.selectedStaging = b = e(b, !c2.selected);
            c2.firePointEvent(b ? "select" : "unselect", { accumulate: d }, function() {
              c2.selected = c2.options.selected = b;
              a3.options.data[a3.data.indexOf(c2)] = c2.options;
              c2.setState(b && "select");
              d || f2.getSelectedPoints().forEach(function(b2) {
                const d2 = b2.series;
                b2.selected && b2 !== c2 && (b2.selected = b2.options.selected = false, d2.options.data[d2.data.indexOf(b2)] = b2.options, b2.setState(f2.hoverPoints && d2.options.inactiveOtherPoints ? "inactive" : ""), b2.firePointEvent("unselect"));
              });
            });
            delete this.selectedStaging;
          }
          onMouseOver(b) {
            const d = this.series.chart, e2 = d.pointer;
            b = b ? e2.normalize(b) : e2.getChartCoordinatesFromPoint(this, d.inverted);
            e2.runPointActions(b, this);
          }
          onMouseOut() {
            const b = this.series.chart;
            this.firePointEvent("mouseOut");
            this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function(b2) {
              b2.setState();
            });
            b.hoverPoints = b.hoverPoint = null;
          }
          importEvents() {
            if (!this.hasImportedEvents) {
              const b = this, d = C(b.series.options.point, b.options).events;
              b.events = d;
              E(d, function(d2, e2) {
                c(d2) && t(b, e2, d2);
              });
              this.hasImportedEvents = true;
            }
          }
          setState(b, d) {
            const c2 = this.series;
            var f2 = this.state, l2 = c2.options.states[b || "normal"] || {}, h2 = F.plotOptions[c2.type].marker && c2.options.marker;
            const k2 = h2 && false === h2.enabled, v2 = h2 && h2.states && h2.states[b || "normal"] || {}, u2 = false === v2.enabled, z2 = this.marker || {}, B2 = c2.chart, q2 = h2 && c2.markerAttribs;
            let C2 = c2.halo;
            var E2;
            let t2;
            var r2 = c2.stateMarkerGraphic;
            b = b || "";
            if (!(b === this.state && !d || this.selected && "select" !== b || false === l2.enabled || b && (u2 || k2 && false === v2.enabled) || b && z2.states && z2.states[b] && false === z2.states[b].enabled)) {
              this.state = b;
              q2 && (E2 = c2.markerAttribs(this, b));
              if (this.graphic && !this.hasMockGraphic) {
                f2 && this.graphic.removeClass("highcharts-point-" + f2);
                b && this.graphic.addClass("highcharts-point-" + b);
                if (!B2.styledMode) {
                  f2 = c2.pointAttribs(this, b);
                  t2 = e(B2.options.chart.animation, l2.animation);
                  const d2 = f2.opacity;
                  c2.options.inactiveOtherPoints && g(d2) && ((this.dataLabels || []).forEach(function(b2) {
                    b2 && !b2.hasClass("highcharts-data-label-hidden") && b2.animate({ opacity: d2 }, t2);
                  }), this.connector && this.connector.animate({ opacity: d2 }, t2));
                  this.graphic.animate(
                    f2,
                    t2
                  );
                }
                E2 && this.graphic.animate(E2, e(B2.options.chart.animation, v2.animation, h2.animation));
                r2 && r2.hide();
              } else {
                if (b && v2) {
                  h2 = z2.symbol || c2.symbol;
                  r2 && r2.currentSymbol !== h2 && (r2 = r2.destroy());
                  if (E2)
                    if (r2)
                      r2[d ? "animate" : "attr"]({ x: E2.x, y: E2.y });
                    else
                      h2 && (c2.stateMarkerGraphic = r2 = B2.renderer.symbol(h2, E2.x, E2.y, E2.width, E2.height).add(c2.markerGroup), r2.currentSymbol = h2);
                  !B2.styledMode && r2 && "inactive" !== this.state && r2.attr(c2.pointAttribs(this, b));
                }
                r2 && (r2[b && this.isInside ? "show" : "hide"](), r2.element.point = this, r2.addClass(this.getClassName(), true));
              }
              l2 = l2.halo;
              E2 = (r2 = this.graphic || r2) && r2.visibility || "inherit";
              l2 && l2.size && r2 && "hidden" !== E2 && !this.isCluster ? (C2 || (c2.halo = C2 = B2.renderer.path().add(r2.parentGroup)), C2.show()[d ? "animate" : "attr"]({ d: this.haloPath(l2.size) }), C2.attr({ "class": "highcharts-halo highcharts-color-" + e(this.colorIndex, c2.colorIndex) + (this.className ? " " + this.className : ""), visibility: E2, zIndex: -1 }), C2.point = this, B2.styledMode || C2.attr(p({ fill: this.color || c2.color, "fill-opacity": l2.opacity }, a2.filterUserAttributes(l2.attributes || {})))) : C2 && C2.point && C2.point.haloPath && C2.animate({ d: C2.point.haloPath(0) }, null, C2.hide);
              n(this, "afterSetState", { state: b });
            }
          }
          haloPath(b) {
            const d = this.pos();
            return d ? this.series.chart.renderer.symbols.circle(Math.floor(d[0]) - b, d[1] - b, 2 * b, 2 * b) : [];
          }
        }
        "";
        return u;
      });
      K(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { parse: r } = a2, { charts: y, noop: A } = x, { addEvent: F, attr: D, css: t, defined: q, extend: k, find: p, fireEvent: n, isNumber: h, isObject: f, objectEach: c, offset: g, pick: B, splat: C } = G;
        class E {
          constructor(e, c2) {
            this.lastValidTouch = {};
            this.pinchDown = [];
            this.runChartClick = false;
            this.eventsToUnbind = [];
            this.chart = e;
            this.hasDragged = false;
            this.options = c2;
            this.init(e, c2);
          }
          applyInactiveState(e) {
            let c2 = [], a3;
            (e || []).forEach(function(e2) {
              a3 = e2.series;
              c2.push(a3);
              a3.linkedParent && c2.push(a3.linkedParent);
              a3.linkedSeries && (c2 = c2.concat(a3.linkedSeries));
              a3.navigatorSeries && c2.push(a3.navigatorSeries);
            });
            this.chart.series.forEach(function(e2) {
              -1 === c2.indexOf(e2) ? e2.setState("inactive", true) : e2.options.inactiveOtherPoints && e2.setAllPointsToState("inactive");
            });
          }
          destroy() {
            const e = this;
            this.eventsToUnbind.forEach((e2) => e2());
            this.eventsToUnbind = [];
            x.chartCount || (E.unbindDocumentMouseUp && (E.unbindDocumentMouseUp = E.unbindDocumentMouseUp()), E.unbindDocumentTouchEnd && (E.unbindDocumentTouchEnd = E.unbindDocumentTouchEnd()));
            clearInterval(e.tooltipTimeout);
            c(e, function(c2, a3) {
              e[a3] = void 0;
            });
          }
          getSelectionMarkerAttrs(e, c2) {
            const a3 = { args: { chartX: e, chartY: c2 }, attrs: {}, shapeType: "rect" };
            n(this, "getSelectionMarkerAttrs", a3, (a4) => {
              const { chart: f2, mouseDownX: b = 0, mouseDownY: d = 0, zoomHor: l, zoomVert: g2 } = this;
              a4 = a4.attrs;
              let h2;
              a4.x = f2.plotLeft;
              a4.y = f2.plotTop;
              a4.width = l ? 1 : f2.plotWidth;
              a4.height = g2 ? 1 : f2.plotHeight;
              l && (h2 = e - b, a4.width = Math.abs(h2), a4.x = (0 < h2 ? 0 : h2) + b);
              g2 && (h2 = c2 - d, a4.height = Math.abs(h2), a4.y = (0 < h2 ? 0 : h2) + d);
            });
            return a3;
          }
          drag(e) {
            const c2 = this.chart, a3 = c2.options.chart;
            var g2 = c2.plotLeft;
            const h2 = c2.plotTop, b = c2.plotWidth, d = c2.plotHeight, m = this.mouseDownX || 0, k2 = this.mouseDownY || 0, n2 = f(a3.panning) ? a3.panning && a3.panning.enabled : a3.panning, p2 = a3.panKey && e[a3.panKey + "Key"];
            let B2 = e.chartX, q2 = e.chartY, C2 = this.selectionMarker;
            if (!C2 || !C2.touch) {
              if (B2 < g2 ? B2 = g2 : B2 > g2 + b && (B2 = g2 + b), q2 < h2 ? q2 = h2 : q2 > h2 + d && (q2 = h2 + d), this.hasDragged = Math.sqrt(Math.pow(m - B2, 2) + Math.pow(k2 - q2, 2)), 10 < this.hasDragged) {
                g2 = c2.isInsidePlot(m - g2, k2 - h2, { visiblePlotOnly: true });
                const { shapeType: b2, attrs: d2 } = this.getSelectionMarkerAttrs(B2, q2);
                !c2.hasCartesianSeries && !c2.mapView || !this.zoomX && !this.zoomY || !g2 || p2 || C2 || (this.selectionMarker = C2 = c2.renderer[b2](), C2.attr({ "class": "highcharts-selection-marker", zIndex: 7 }).add(), c2.styledMode || C2.attr({ fill: a3.selectionMarkerFill || r("#334eff").setOpacity(0.25).get() }));
                C2 && C2.attr(d2);
                g2 && !C2 && n2 && c2.pan(e, a3.panning);
              }
            }
          }
          dragStart(e) {
            const c2 = this.chart;
            c2.mouseIsDown = e.type;
            c2.cancelClick = false;
            c2.mouseDownX = this.mouseDownX = e.chartX;
            c2.mouseDownY = this.mouseDownY = e.chartY;
          }
          getSelectionBox(e) {
            const c2 = { args: { marker: e }, result: {} };
            n(this, "getSelectionBox", c2, (c3) => {
              c3.result = { x: e.attr ? +e.attr("x") : e.x, y: e.attr ? +e.attr("y") : e.y, width: e.attr ? e.attr("width") : e.width, height: e.attr ? e.attr("height") : e.height };
            });
            return c2.result;
          }
          drop(e) {
            const c2 = this, a3 = this.chart, f2 = this.hasPinched;
            if (this.selectionMarker) {
              const {
                x: l,
                y: b,
                width: d,
                height: m
              } = this.getSelectionBox(this.selectionMarker), g2 = { originalEvent: e, xAxis: [], yAxis: [], x: l, y: b, width: d, height: m };
              let v = !!a3.mapView;
              if (this.hasDragged || f2)
                a3.axes.forEach(function(a4) {
                  if (a4.zoomEnabled && q(a4.min) && (f2 || c2[{ xAxis: "zoomX", yAxis: "zoomY" }[a4.coll]]) && h(l) && h(b) && h(d) && h(m)) {
                    var k2 = a4.horiz;
                    const c3 = "touchend" === e.type ? a4.minPixelPadding : 0, f3 = a4.toValue((k2 ? l : b) + c3);
                    k2 = a4.toValue((k2 ? l + d : b + m) - c3);
                    g2[a4.coll].push({ axis: a4, min: Math.min(f3, k2), max: Math.max(f3, k2) });
                    v = true;
                  }
                }), v && n(a3, "selection", g2, function(b2) {
                  a3.zoom(k(
                    b2,
                    f2 ? { animation: false } : null
                  ));
                });
              h(a3.index) && (this.selectionMarker = this.selectionMarker.destroy());
              f2 && this.scaleGroups();
            }
            a3 && h(a3.index) && (t(a3.container, { cursor: a3._cursor }), a3.cancelClick = 10 < this.hasDragged, a3.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
          }
          findNearestKDPoint(e, c2, a3) {
            let l;
            e.forEach(function(e2) {
              var b = !(e2.noSharedTooltip && c2) && 0 > e2.options.findNearestPointBy.indexOf("y");
              e2 = e2.searchPoint(a3, b);
              if ((b = f(e2, true) && e2.series) && !(b = !f(l, true))) {
                {
                  b = l.distX - e2.distX;
                  const d = l.dist - e2.dist, a4 = (e2.series.group && e2.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
                  b = 0 !== b && c2 ? b : 0 !== d ? d : 0 !== a4 ? a4 : l.series.index > e2.series.index ? -1 : 1;
                }
                b = 0 < b;
              }
              b && (l = e2);
            });
            return l;
          }
          getChartCoordinatesFromPoint(e, c2) {
            var a3 = e.series;
            const f2 = a3.xAxis;
            a3 = a3.yAxis;
            const l = e.shapeArgs;
            if (f2 && a3) {
              let b = B(e.clientX, e.plotX), d = e.plotY || 0;
              e.isNode && l && h(l.x) && h(l.y) && (b = l.x, d = l.y);
              return c2 ? { chartX: a3.len + a3.pos - d, chartY: f2.len + f2.pos - b } : { chartX: b + f2.pos, chartY: d + a3.pos };
            }
            if (l && l.x && l.y)
              return { chartX: l.x, chartY: l.y };
          }
          getChartPosition() {
            if (this.chartPosition)
              return this.chartPosition;
            var { container: e } = this.chart;
            const c2 = g(e);
            this.chartPosition = { left: c2.left, top: c2.top, scaleX: 1, scaleY: 1 };
            const a3 = e.offsetWidth;
            e = e.offsetHeight;
            2 < a3 && 2 < e && (this.chartPosition.scaleX = c2.width / a3, this.chartPosition.scaleY = c2.height / e);
            return this.chartPosition;
          }
          getCoordinates(e) {
            const c2 = { xAxis: [], yAxis: [] };
            this.chart.axes.forEach(function(a3) {
              c2[a3.isXAxis ? "xAxis" : "yAxis"].push({ axis: a3, value: a3.toValue(e[a3.horiz ? "chartX" : "chartY"]) });
            });
            return c2;
          }
          getHoverData(e, c2, a3, g2, h2, b) {
            const d = [];
            g2 = !(!g2 || !e);
            const l = function(b2) {
              return b2.visible && !(!h2 && b2.directTouch) && B(b2.options.enableMouseTracking, true);
            };
            let k2, v = { chartX: b ? b.chartX : void 0, chartY: b ? b.chartY : void 0, shared: h2 };
            n(this, "beforeGetHoverData", v);
            k2 = c2 && !c2.stickyTracking ? [c2] : a3.filter((b2) => b2.stickyTracking && (v.filter || l)(b2));
            const u = g2 || !b ? e : this.findNearestKDPoint(k2, h2, b);
            c2 = u && u.series;
            u && (h2 && !c2.noSharedTooltip ? (k2 = a3.filter(function(b2) {
              return v.filter ? v.filter(b2) : l(b2) && !b2.noSharedTooltip;
            }), k2.forEach(function(b2) {
              let e2 = p(b2.points, function(b3) {
                return b3.x === u.x && !b3.isNull;
              });
              f(e2) && (b2.boosted && b2.boost && (e2 = b2.boost.getPoint(e2)), d.push(e2));
            })) : d.push(u));
            v = { hoverPoint: u };
            n(this, "afterGetHoverData", v);
            return { hoverPoint: v.hoverPoint, hoverSeries: c2, hoverPoints: d };
          }
          getPointFromEvent(e) {
            e = e.target;
            let c2;
            for (; e && !c2; )
              c2 = e.point, e = e.parentNode;
            return c2;
          }
          onTrackerMouseOut(e) {
            e = e.relatedTarget;
            const c2 = this.chart.hoverSeries;
            this.isDirectTouch = false;
            if (!(!c2 || !e || c2.stickyTracking || this.inClass(e, "highcharts-tooltip") || this.inClass(e, "highcharts-series-" + c2.index) && this.inClass(e, "highcharts-tracker")))
              c2.onMouseOut();
          }
          inClass(e, c2) {
            let a3;
            for (; e; ) {
              if (a3 = D(e, "class")) {
                if (-1 !== a3.indexOf(c2))
                  return true;
                if (-1 !== a3.indexOf("highcharts-container"))
                  return false;
              }
              e = e.parentElement;
            }
          }
          init(e, c2) {
            this.options = c2;
            this.chart = e;
            this.runChartClick = !(!c2.chart.events || !c2.chart.events.click);
            this.pinchDown = [];
            this.lastValidTouch = {};
            this.setDOMEvents();
            n(this, "afterInit");
          }
          normalize(e, c2) {
            var a3 = e.touches, f2 = a3 ? a3.length ? a3.item(0) : B(a3.changedTouches, e.changedTouches)[0] : e;
            c2 || (c2 = this.getChartPosition());
            a3 = f2.pageX - c2.left;
            f2 = f2.pageY - c2.top;
            a3 /= c2.scaleX;
            f2 /= c2.scaleY;
            return k(e, { chartX: Math.round(a3), chartY: Math.round(f2) });
          }
          onContainerClick(e) {
            const c2 = this.chart, a3 = c2.hoverPoint;
            e = this.normalize(e);
            const f2 = c2.plotLeft, g2 = c2.plotTop;
            c2.cancelClick || (a3 && this.inClass(e.target, "highcharts-tracker") ? (n(a3.series, "click", k(e, { point: a3 })), c2.hoverPoint && a3.firePointEvent("click", e)) : (k(e, this.getCoordinates(e)), c2.isInsidePlot(e.chartX - f2, e.chartY - g2, { visiblePlotOnly: true }) && n(c2, "click", e)));
          }
          onContainerMouseDown(e) {
            const c2 = 1 === ((e.buttons || e.button) & 1);
            e = this.normalize(e);
            if (x.isFirefox && 0 !== e.button)
              this.onContainerMouseMove(e);
            if ("undefined" === typeof e.button || c2)
              this.zoomOption(e), c2 && e.preventDefault && e.preventDefault(), this.dragStart(e);
          }
          onContainerMouseLeave(e) {
            const c2 = y[B(E.hoverChartIndex, -1)];
            e = this.normalize(e);
            c2 && e.relatedTarget && !this.inClass(e.relatedTarget, "highcharts-tooltip") && (c2.pointer.reset(), c2.pointer.chartPosition = void 0);
          }
          onContainerMouseEnter(e) {
            delete this.chartPosition;
          }
          onContainerMouseMove(e) {
            const c2 = this.chart, a3 = c2.tooltip;
            e = this.normalize(e);
            this.setHoverChartIndex();
            ("mousedown" === c2.mouseIsDown || this.touchSelect(e)) && this.drag(e);
            c2.openMenu || !this.inClass(e.target, "highcharts-tracker") && !c2.isInsidePlot(e.chartX - c2.plotLeft, e.chartY - c2.plotTop, { visiblePlotOnly: true }) || a3 && a3.shouldStickOnContact(e) || (this.inClass(e.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(e));
          }
          onDocumentTouchEnd(e) {
            const c2 = y[B(E.hoverChartIndex, -1)];
            c2 && c2.pointer.drop(e);
          }
          onContainerTouchMove(e) {
            if (this.touchSelect(e))
              this.onContainerMouseMove(e);
            else
              this.touch(e);
          }
          onContainerTouchStart(e) {
            if (this.touchSelect(e))
              this.onContainerMouseDown(e);
            else
              this.zoomOption(e), this.touch(e, true);
          }
          onDocumentMouseMove(e) {
            const c2 = this.chart, a3 = c2.tooltip, f2 = this.chartPosition;
            e = this.normalize(e, f2);
            !f2 || c2.isInsidePlot(e.chartX - c2.plotLeft, e.chartY - c2.plotTop, { visiblePlotOnly: true }) || a3 && a3.shouldStickOnContact(e) || this.inClass(e.target, "highcharts-tracker") || this.reset();
          }
          onDocumentMouseUp(e) {
            const c2 = y[B(E.hoverChartIndex, -1)];
            c2 && c2.pointer.drop(e);
          }
          pinch(e) {
            const c2 = this, a3 = c2.chart, f2 = c2.pinchDown, g2 = e.touches || [], b = g2.length, d = c2.lastValidTouch, m = c2.hasZoom, h2 = {}, p2 = 1 === b && (c2.inClass(e.target, "highcharts-tracker") && a3.runTrackerClick || c2.runChartClick), C2 = {};
            var q2 = c2.chart.tooltip;
            q2 = 1 === b && B(q2 && q2.options.followTouchMove, true);
            let E2 = c2.selectionMarker;
            1 < b ? c2.initiated = true : q2 && (c2.initiated = false);
            m && c2.initiated && !p2 && false !== e.cancelable && e.preventDefault();
            [].map.call(g2, function(b2) {
              return c2.normalize(b2);
            });
            "touchstart" === e.type ? ([].forEach.call(g2, function(b2, d2) {
              f2[d2] = { chartX: b2.chartX, chartY: b2.chartY };
            }), d.x = [f2[0].chartX, f2[1] && f2[1].chartX], d.y = [f2[0].chartY, f2[1] && f2[1].chartY], a3.axes.forEach(function(b2) {
              if (b2.zoomEnabled) {
                const d2 = a3.bounds[b2.horiz ? "h" : "v"], e2 = b2.minPixelPadding, c3 = b2.toPixels(Math.min(B(b2.options.min, b2.dataMin), b2.dataMin)), f3 = b2.toPixels(Math.max(B(b2.options.max, b2.dataMax), b2.dataMax)), m2 = Math.max(c3, f3);
                d2.min = Math.min(b2.pos, Math.min(c3, f3) - e2);
                d2.max = Math.max(b2.pos + b2.len, m2 + e2);
              }
            }), c2.res = true) : q2 ? this.runPointActions(c2.normalize(e)) : f2.length && (n(a3, "touchpan", { originalEvent: e }, () => {
              E2 || (c2.selectionMarker = E2 = k({ destroy: A, touch: true }, a3.plotBox));
              c2.pinchTranslate(f2, g2, h2, E2, C2, d);
              c2.hasPinched = m;
              c2.scaleGroups(h2, C2);
            }), c2.res && (c2.res = false, this.reset(
              false,
              0
            )));
          }
          pinchTranslate(e, c2, a3, f2, g2, b) {
            this.zoomHor && this.pinchTranslateDirection(true, e, c2, a3, f2, g2, b);
            this.zoomVert && this.pinchTranslateDirection(false, e, c2, a3, f2, g2, b);
          }
          pinchTranslateDirection(e, c2, a3, f2, g2, b, d, m) {
            const l = this.chart, h2 = e ? "x" : "y", k2 = e ? "X" : "Y", n2 = "chart" + k2, v = e ? "width" : "height", u = l["plot" + (e ? "Left" : "Top")], z = l.inverted, p2 = l.bounds[e ? "h" : "v"], B2 = 1 === c2.length, q2 = c2[0][n2], C2 = !B2 && c2[1][n2];
            c2 = function() {
              "number" === typeof y2 && 20 < Math.abs(q2 - C2) && (t2 = m || Math.abs(L - y2) / Math.abs(q2 - C2));
              r2 = (u - L) / t2 + q2;
              E2 = l["plot" + (e ? "Width" : "Height")] / t2;
            };
            let E2, r2, t2 = m || 1, L = a3[0][n2], y2 = !B2 && a3[1][n2], S;
            c2();
            a3 = r2;
            a3 < p2.min ? (a3 = p2.min, S = true) : a3 + E2 > p2.max && (a3 = p2.max - E2, S = true);
            S ? (L -= 0.8 * (L - d[h2][0]), "number" === typeof y2 && (y2 -= 0.8 * (y2 - d[h2][1])), c2()) : d[h2] = [L, y2];
            z || (b[h2] = r2 - u, b[v] = E2);
            b = z ? 1 / t2 : t2;
            g2[v] = E2;
            g2[h2] = a3;
            f2[z ? e ? "scaleY" : "scaleX" : "scale" + k2] = t2;
            f2["translate" + k2] = b * u + (L - b * q2);
          }
          reset(e, c2) {
            const a3 = this.chart, f2 = a3.hoverSeries, g2 = a3.hoverPoint, b = a3.hoverPoints, d = a3.tooltip, m = d && d.shared ? b : g2;
            e && m && C(m).forEach(function(b2) {
              b2.series.isCartesian && "undefined" === typeof b2.plotX && (e = false);
            });
            if (e)
              d && m && C(m).length && (d.refresh(m), d.shared && b ? b.forEach(function(b2) {
                b2.setState(b2.state, true);
                b2.series.isCartesian && (b2.series.xAxis.crosshair && b2.series.xAxis.drawCrosshair(null, b2), b2.series.yAxis.crosshair && b2.series.yAxis.drawCrosshair(null, b2));
              }) : g2 && (g2.setState(g2.state, true), a3.axes.forEach(function(b2) {
                b2.crosshair && g2.series[b2.coll] === b2 && b2.drawCrosshair(null, g2);
              })));
            else {
              if (g2)
                g2.onMouseOut();
              b && b.forEach(function(b2) {
                b2.setState();
              });
              if (f2)
                f2.onMouseOut();
              d && d.hide(c2);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              a3.axes.forEach(function(b2) {
                b2.hideCrosshair();
              });
              this.hoverX = a3.hoverPoints = a3.hoverPoint = null;
            }
          }
          runPointActions(e, c2, a3) {
            const f2 = this.chart, g2 = f2.tooltip && f2.tooltip.options.enabled ? f2.tooltip : void 0, b = g2 ? g2.shared : false;
            let d = c2 || f2.hoverPoint, m = d && d.series || f2.hoverSeries;
            c2 = this.getHoverData(d, m, f2.series, (!e || "touchmove" !== e.type) && (!!c2 || m && m.directTouch && this.isDirectTouch), b, e);
            d = c2.hoverPoint;
            m = c2.hoverSeries;
            const l = c2.hoverPoints;
            c2 = m && m.tooltipOptions.followPointer && !m.tooltipOptions.split;
            const h2 = b && m && !m.noSharedTooltip;
            if (d && (a3 || d !== f2.hoverPoint || g2 && g2.isHidden)) {
              (f2.hoverPoints || []).forEach(function(b2) {
                -1 === l.indexOf(b2) && b2.setState();
              });
              if (f2.hoverSeries !== m)
                m.onMouseOver();
              this.applyInactiveState(l);
              (l || []).forEach(function(b2) {
                b2.setState("hover");
              });
              f2.hoverPoint && f2.hoverPoint.firePointEvent("mouseOut");
              if (!d.series)
                return;
              f2.hoverPoints = l;
              f2.hoverPoint = d;
              d.firePointEvent("mouseOver", void 0, () => {
                g2 && d && g2.refresh(h2 ? l : d, e);
              });
            } else
              c2 && g2 && !g2.isHidden && (a3 = g2.getAnchor([{}], e), f2.isInsidePlot(a3[0], a3[1], { visiblePlotOnly: true }) && g2.updatePosition({
                plotX: a3[0],
                plotY: a3[1]
              }));
            this.unDocMouseMove || (this.unDocMouseMove = F(f2.container.ownerDocument, "mousemove", function(b2) {
              const d2 = y[E.hoverChartIndex];
              if (d2)
                d2.pointer.onDocumentMouseMove(b2);
            }), this.eventsToUnbind.push(this.unDocMouseMove));
            f2.axes.forEach(function(b2) {
              const d2 = B((b2.crosshair || {}).snap, true);
              let c3;
              d2 && ((c3 = f2.hoverPoint) && c3.series[b2.coll] === b2 || (c3 = p(l, (d3) => d3.series && d3.series[b2.coll] === b2)));
              c3 || !d2 ? b2.drawCrosshair(e, c3) : b2.hideCrosshair();
            });
          }
          scaleGroups(c2, a3) {
            const e = this.chart;
            e.series.forEach(function(f2) {
              const g2 = c2 || f2.getPlotBox();
              f2.group && (f2.xAxis && f2.xAxis.zoomEnabled || e.mapView) && (f2.group.attr(g2), f2.markerGroup && (f2.markerGroup.attr(g2), f2.markerGroup.clip(a3 ? e.clipRect : null)), f2.dataLabelsGroup && f2.dataLabelsGroup.attr(g2));
            });
            e.clipRect.attr(a3 || e.clipBox);
          }
          setDOMEvents() {
            const c2 = this.chart.container, a3 = c2.ownerDocument;
            c2.onmousedown = this.onContainerMouseDown.bind(this);
            c2.onmousemove = this.onContainerMouseMove.bind(this);
            c2.onclick = this.onContainerClick.bind(this);
            this.eventsToUnbind.push(F(c2, "mouseenter", this.onContainerMouseEnter.bind(this)));
            this.eventsToUnbind.push(F(c2, "mouseleave", this.onContainerMouseLeave.bind(this)));
            E.unbindDocumentMouseUp || (E.unbindDocumentMouseUp = F(a3, "mouseup", this.onDocumentMouseUp.bind(this)));
            let f2 = this.chart.renderTo.parentElement;
            for (; f2 && "BODY" !== f2.tagName; )
              this.eventsToUnbind.push(F(f2, "scroll", () => {
                delete this.chartPosition;
              })), f2 = f2.parentElement;
            x.hasTouch && (this.eventsToUnbind.push(F(c2, "touchstart", this.onContainerTouchStart.bind(this), { passive: false })), this.eventsToUnbind.push(F(
              c2,
              "touchmove",
              this.onContainerTouchMove.bind(this),
              { passive: false }
            )), E.unbindDocumentTouchEnd || (E.unbindDocumentTouchEnd = F(a3, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })));
          }
          setHoverChartIndex() {
            const c2 = this.chart, a3 = x.charts[B(E.hoverChartIndex, -1)];
            if (a3 && a3 !== c2)
              a3.pointer.onContainerMouseLeave({ relatedTarget: c2.container });
            a3 && a3.mouseIsDown || (E.hoverChartIndex = c2.index);
          }
          touch(c2, a3) {
            const e = this.chart;
            let f2, g2;
            this.setHoverChartIndex();
            1 === c2.touches.length ? (c2 = this.normalize(c2), (g2 = e.isInsidePlot(c2.chartX - e.plotLeft, c2.chartY - e.plotTop, { visiblePlotOnly: true })) && !e.openMenu ? (a3 && this.runPointActions(c2), "touchmove" === c2.type && (a3 = this.pinchDown, f2 = a3[0] ? 4 <= Math.sqrt(Math.pow(a3[0].chartX - c2.chartX, 2) + Math.pow(a3[0].chartY - c2.chartY, 2)) : false), B(f2, true) && this.pinch(c2)) : a3 && this.reset()) : 2 === c2.touches.length && this.pinch(c2);
          }
          touchSelect(c2) {
            return !(!this.chart.zooming.singleTouch || !c2.touches || 1 !== c2.touches.length);
          }
          zoomOption(c2) {
            const e = this.chart, a3 = e.inverted;
            var f2 = e.zooming.type || "";
            /touch/.test(c2.type) && (f2 = B(e.zooming.pinchType, f2));
            this.zoomX = c2 = /x/.test(f2);
            this.zoomY = f2 = /y/.test(f2);
            this.zoomHor = c2 && !a3 || f2 && a3;
            this.zoomVert = f2 && !a3 || c2 && a3;
            this.hasZoom = c2 || f2;
          }
        }
        (function(c2) {
          const e = [], a3 = [];
          c2.compose = function(e2) {
            G.pushUnique(a3, e2) && F(e2, "beforeRender", function() {
              this.pointer = new c2(this, this.options);
            });
          };
          c2.dissolve = function() {
            for (let c3 = 0, a4 = e.length; c3 < a4; ++c3)
              e[c3]();
            e.length = 0;
          };
        })(E || (E = {}));
        "";
        return E;
      });
      K(
        a,
        "Core/Legend/Legend.js",
        [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]],
        function(a2, x, G, I, y, A) {
          const { animObject: r, setAnimation: D } = a2, { format: t } = x, { marginNames: q } = G, { distribute: k } = y, { addEvent: p, createElement: n, css: h, defined: f, discardElement: c, find: g, fireEvent: B, isNumber: C, merge: E, pick: e, relativeLength: l, stableSort: v, syncTimeout: z } = A;
          class u {
            constructor(b, d) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = false;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = void 0;
              this.padding = 0;
              this.pages = [];
              this.proximate = false;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = b;
              this.init(b, d);
            }
            init(b, d) {
              this.chart = b;
              this.setOptions(d);
              d.enabled && (this.render(), p(this.chart, "endResize", function() {
                this.legend.positionCheckboxes();
              }), p(this.chart, "render", () => {
                this.proximate && (this.proximatePositions(), this.positionItems());
              }));
            }
            setOptions(b) {
              const d = e(b.padding, 8);
              this.options = b;
              this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = E(this.itemStyle, b.itemHiddenStyle));
              this.itemMarginTop = b.itemMarginTop;
              this.itemMarginBottom = b.itemMarginBottom;
              this.padding = d;
              this.initialItemY = d - 5;
              this.symbolWidth = e(b.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === b.layout && !this.chart.inverted;
              this.baseline = void 0;
            }
            update(b, d) {
              const c2 = this.chart;
              this.setOptions(E(true, this.options, b));
              this.destroy();
              c2.isDirtyLegend = c2.isDirtyBox = true;
              e(d, true) && c2.redraw();
              B(this, "afterUpdate");
            }
            colorizeItem(b, d) {
              const { group: c2, label: e2, line: a3, symbol: f2 } = b.legendItem || {};
              if (c2)
                c2[d ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
              if (!this.chart.styledMode) {
                const { itemHiddenStyle: c3 } = this, m = c3.color, g2 = d ? b.color || m : m, l2 = b.options && b.options.marker;
                let h2 = { fill: g2 };
                null === e2 || void 0 === e2 ? void 0 : e2.css(E(d ? this.itemStyle : c3));
                null === a3 || void 0 === a3 ? void 0 : a3.attr({ stroke: g2 });
                f2 && (l2 && f2.isMarker && (h2 = b.pointAttribs(), d || (h2.stroke = h2.fill = m)), f2.attr(h2));
              }
              B(this, "afterColorizeItem", { item: b, visible: d });
            }
            positionItems() {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(b) {
              const { group: d, x: c2 = 0, y: e2 = 0 } = b.legendItem || {};
              var a3 = this.options, g2 = a3.symbolPadding;
              const l2 = !a3.rtl;
              a3 = b.checkbox;
              d && d.element && (g2 = { translateX: l2 ? c2 : this.legendWidth - c2 - 2 * g2 - 4, translateY: e2 }, d[f(d.translateY) ? "animate" : "attr"](g2, void 0, () => {
                B(this, "afterPositionItem", { item: b });
              }));
              a3 && (a3.x = c2, a3.y = e2);
            }
            destroyItem(b) {
              const d = b.checkbox, e2 = b.legendItem || {};
              for (const b2 of ["group", "label", "line", "symbol"])
                e2[b2] && (e2[b2] = e2[b2].destroy());
              d && c(d);
              b.legendItem = void 0;
            }
            destroy() {
              for (const b of this.getAllItems())
                this.destroyItem(b);
              for (const b of "clipRect up down pager nav box title group".split(" "))
                this[b] && (this[b] = this[b].destroy());
              this.display = null;
            }
            positionCheckboxes() {
              const b = this.group && this.group.alignAttr, d = this.clipHeight || this.legendHeight, c2 = this.titleHeight;
              let e2;
              b && (e2 = b.translateY, this.allItems.forEach(function(a3) {
                const f2 = a3.checkbox;
                let g2;
                f2 && (g2 = e2 + c2 + f2.y + (this.scrollOffset || 0) + 3, h(f2, { left: b.translateX + a3.checkboxOffset + f2.x - 20 + "px", top: g2 + "px", display: this.proximate || g2 > e2 - 6 && g2 < e2 + d - 6 ? "" : "none" }));
              }, this));
            }
            renderTitle() {
              var b = this.options;
              const d = this.padding, c2 = b.title;
              let e2 = 0;
              c2.text && (this.title || (this.title = this.chart.renderer.label(c2.text, d - 3, d - 4, void 0, void 0, void 0, b.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(c2.style), this.title.add(this.group)), c2.width || this.title.css({ width: this.maxLegendWidth + "px" }), b = this.title.getBBox(), e2 = b.height, this.offsetWidth = b.width, this.contentGroup.attr({ translateY: e2 }));
              this.titleHeight = e2;
            }
            setText(b) {
              const d = this.options;
              b.legendItem.label.attr({ text: d.labelFormat ? t(d.labelFormat, b, this.chart) : d.labelFormatter.call(b) });
            }
            renderItem(b) {
              const d = b.legendItem = b.legendItem || {};
              var c2 = this.chart, a3 = c2.renderer;
              const f2 = this.options, g2 = this.symbolWidth, l2 = f2.symbolPadding || 0, h2 = this.itemStyle, k2 = this.itemHiddenStyle, n2 = "horizontal" === f2.layout ? e(f2.itemDistance, 20) : 0, v2 = !f2.rtl, u2 = !b.series, p2 = !u2 && b.series.drawLegendSymbol ? b.series : b;
              var z2 = p2.options;
              const B2 = this.createCheckboxForItem && z2 && z2.showCheckbox, q2 = f2.useHTML, C2 = b.options.className;
              let L = d.label;
              z2 = g2 + l2 + n2 + (B2 ? 20 : 0);
              L || (d.group = a3.g("legend-item").addClass("highcharts-" + p2.type + "-series highcharts-color-" + b.colorIndex + (C2 ? " " + C2 : "") + (u2 ? " highcharts-series-" + b.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), d.label = L = a3.text("", v2 ? g2 + l2 : -l2, this.baseline || 0, q2), c2.styledMode || L.css(E(b.visible ? h2 : k2)), L.attr({ align: v2 ? "left" : "right", zIndex: 2 }).add(d.group), this.baseline || (this.fontMetrics = a3.fontMetrics(L), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, L.attr("y", this.baseline), this.symbolHeight = e(f2.symbolHeight, this.fontMetrics.f), f2.squareSymbol && (this.symbolWidth = e(f2.symbolWidth, Math.max(this.symbolHeight, 16)), z2 = this.symbolWidth + l2 + n2 + (B2 ? 20 : 0), v2 && L.attr("x", this.symbolWidth + l2))), p2.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, L, q2));
              B2 && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
              this.colorizeItem(
                b,
                b.visible
              );
              !c2.styledMode && h2.width || L.css({ width: (f2.itemWidth || this.widthOption || c2.spacingBox.width) - z2 + "px" });
              this.setText(b);
              c2 = L.getBBox();
              a3 = this.fontMetrics && this.fontMetrics.h || 0;
              b.itemWidth = b.checkboxOffset = f2.itemWidth || d.labelWidth || c2.width + z2;
              this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
              this.totalItemWidth += b.itemWidth;
              this.itemHeight = b.itemHeight = Math.round(d.labelHeight || (c2.height > 1.5 * a3 ? c2.height : a3));
            }
            layoutItem(b) {
              var d = this.options;
              const c2 = this.padding, a3 = "horizontal" === d.layout, f2 = b.itemHeight, g2 = this.itemMarginBottom, l2 = this.itemMarginTop, h2 = a3 ? e(d.itemDistance, 20) : 0, k2 = this.maxLegendWidth;
              d = d.alignColumns && this.totalItemWidth > k2 ? this.maxItemWidth : b.itemWidth;
              const n2 = b.legendItem || {};
              a3 && this.itemX - c2 + d > k2 && (this.itemX = c2, this.lastLineHeight && (this.itemY += l2 + this.lastLineHeight + g2), this.lastLineHeight = 0);
              this.lastItemY = l2 + this.itemY + g2;
              this.lastLineHeight = Math.max(f2, this.lastLineHeight);
              n2.x = this.itemX;
              n2.y = this.itemY;
              a3 ? this.itemX += d : (this.itemY += l2 + f2 + g2, this.lastLineHeight = f2);
              this.offsetWidth = this.widthOption || Math.max((a3 ? this.itemX - c2 - (b.checkbox ? 0 : h2) : d) + c2, this.offsetWidth);
            }
            getAllItems() {
              let b = [];
              this.chart.series.forEach(function(d) {
                const c2 = d && d.options;
                d && e(c2.showInLegend, f(c2.linkedTo) ? false : void 0, true) && (b = b.concat((d.legendItem || {}).labels || ("point" === c2.legendType ? d.data : d)));
              });
              B(this, "afterGetAllItems", { allItems: b });
              return b;
            }
            getAlignment() {
              const b = this.options;
              return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
            }
            adjustMargins(b, d) {
              const c2 = this.chart, a3 = this.options, g2 = this.getAlignment();
              g2 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(m, l2) {
                m.test(g2) && !f(b[l2]) && (c2[q[l2]] = Math.max(c2[q[l2]], c2.legend[(l2 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l2] * a3[l2 % 2 ? "x" : "y"] + e(a3.margin, 12) + d[l2] + (c2.titleOffset[l2] || 0)));
              });
            }
            proximatePositions() {
              const b = this.chart, d = [], c2 = "left" === this.options.align;
              this.allItems.forEach(function(e3) {
                var a3;
                var f2 = c2;
                let m;
                e3.yAxis && (e3.xAxis.options.reversed && (f2 = !f2), e3.points && (a3 = g(f2 ? e3.points : e3.points.slice(0).reverse(), function(b2) {
                  return C(b2.plotY);
                })), f2 = this.itemMarginTop + e3.legendItem.label.getBBox().height + this.itemMarginBottom, m = e3.yAxis.top - b.plotTop, e3.visible ? (a3 = a3 ? a3.plotY : e3.yAxis.height, a3 += m - 0.3 * f2) : a3 = m + e3.yAxis.height, d.push({ target: a3, size: f2, item: e3 }));
              }, this);
              let e2;
              for (const c3 of k(d, b.plotHeight))
                e2 = c3.item.legendItem || {}, C(c3.pos) && (e2.y = b.plotTop - b.spacing[0] + c3.pos);
            }
            render() {
              const b = this.chart, d = b.renderer, c2 = this.options, e2 = this.padding;
              var a3 = this.getAllItems();
              let f2, g2 = this.group, h2 = this.box;
              this.itemX = e2;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = l(c2.width, b.spacingBox.width - e2);
              var k2 = b.spacingBox.width - 2 * e2 - c2.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (k2 /= 2);
              this.maxLegendWidth = this.widthOption || k2;
              g2 || (this.group = g2 = d.g("legend").addClass(c2.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = d.g().attr({ zIndex: 1 }).add(g2), this.scrollGroup = d.g().add(this.contentGroup));
              this.renderTitle();
              v(a3, (b2, d2) => (b2.options && b2.options.legendIndex || 0) - (d2.options && d2.options.legendIndex || 0));
              c2.reversed && a3.reverse();
              this.allItems = a3;
              this.display = k2 = !!a3.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              a3.forEach(this.renderItem, this);
              a3.forEach(this.layoutItem, this);
              a3 = (this.widthOption || this.offsetWidth) + e2;
              f2 = this.lastItemY + this.lastLineHeight + this.titleHeight;
              f2 = this.handleOverflow(f2);
              f2 += e2;
              h2 || (this.box = h2 = d.rect().addClass("highcharts-legend-box").attr({ r: c2.borderRadius }).add(g2));
              b.styledMode || h2.attr({
                stroke: c2.borderColor,
                "stroke-width": c2.borderWidth || 0,
                fill: c2.backgroundColor || "none"
              }).shadow(c2.shadow);
              if (0 < a3 && 0 < f2)
                h2[h2.placed ? "animate" : "attr"](h2.crisp.call({}, { x: 0, y: 0, width: a3, height: f2 }, h2.strokeWidth()));
              g2[k2 ? "show" : "hide"]();
              b.styledMode && "none" === g2.getStyle("display") && (a3 = f2 = 0);
              this.legendWidth = a3;
              this.legendHeight = f2;
              k2 && this.align();
              this.proximate || this.positionItems();
              B(this, "afterRender");
            }
            align(b = this.chart.spacingBox) {
              const d = this.chart, c2 = this.options;
              let e2 = b.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < d.titleOffset[0] ? e2 += d.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < d.titleOffset[2] && (e2 -= d.titleOffset[2]);
              e2 !== b.y && (b = E(b, { y: e2 }));
              d.hasRendered || (this.group.placed = false);
              this.group.align(E(c2, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : c2.verticalAlign }), true, b);
            }
            handleOverflow(b) {
              const d = this, c2 = this.chart, a3 = c2.renderer, f2 = this.options;
              var g2 = f2.y;
              const l2 = "top" === f2.verticalAlign, h2 = this.padding, k2 = f2.maxHeight, n2 = f2.navigation, v2 = e(n2.animation, true), u2 = n2.arrowSize || 12, p2 = this.pages, z2 = this.allItems, B2 = function(b2) {
                "number" === typeof b2 ? t2.attr({ height: b2 }) : t2 && (d.clipRect = t2.destroy(), d.contentGroup.clip());
                d.contentGroup.div && (d.contentGroup.div.style.clip = b2 ? "rect(" + h2 + "px,9999px," + (h2 + b2) + "px,0)" : "auto");
              }, q2 = function(b2) {
                d[b2] = a3.circle(0, 0, 1.3 * u2).translate(u2 / 2, u2 / 2).add(r2);
                c2.styledMode || d[b2].attr("fill", "rgba(0,0,0,0.0001)");
                return d[b2];
              };
              let C2, L, E2;
              g2 = c2.spacingBox.height + (l2 ? -g2 : g2) - h2;
              let r2 = this.nav, t2 = this.clipRect;
              "horizontal" !== f2.layout || "middle" === f2.verticalAlign || f2.floating || (g2 /= 2);
              k2 && (g2 = Math.min(g2, k2));
              p2.length = 0;
              b && 0 < g2 && b > g2 && false !== n2.enabled ? (this.clipHeight = C2 = Math.max(g2 - 20 - this.titleHeight - h2, 0), this.currentPage = e(this.currentPage, 1), this.fullHeight = b, z2.forEach((b2, d2) => {
                E2 = b2.legendItem || {};
                b2 = E2.y || 0;
                const c3 = Math.round(E2.label.getBBox().height);
                let e2 = p2.length;
                if (!e2 || b2 - p2[e2 - 1] > C2 && (L || b2) !== p2[e2 - 1])
                  p2.push(L || b2), e2++;
                E2.pageIx = e2 - 1;
                L && ((z2[d2 - 1].legendItem || {}).pageIx = e2 - 1);
                d2 === z2.length - 1 && b2 + c3 - p2[e2 - 1] > C2 && b2 > p2[e2 - 1] && (p2.push(b2), E2.pageIx = e2);
                b2 !== L && (L = b2);
              }), t2 || (t2 = d.clipRect = a3.clipRect(0, h2 - 2, 9999, 0), d.contentGroup.clip(t2)), B2(C2), r2 || (this.nav = r2 = a3.g().attr({ zIndex: 1 }).add(this.group), this.up = a3.symbol("triangle", 0, 0, u2, u2).add(r2), q2("upTracker").on("click", function() {
                d.scroll(-1, v2);
              }), this.pager = a3.text("", 15, 10).addClass("highcharts-legend-navigation"), !c2.styledMode && n2.style && this.pager.css(n2.style), this.pager.add(r2), this.down = a3.symbol("triangle-down", 0, 0, u2, u2).add(r2), q2("downTracker").on("click", function() {
                d.scroll(1, v2);
              })), d.scroll(0), b = g2) : r2 && (B2(), this.nav = r2.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
              return b;
            }
            scroll(b, d) {
              const c2 = this.chart, a3 = this.pages, f2 = a3.length, g2 = this.clipHeight, l2 = this.options.navigation, h2 = this.pager, k2 = this.padding;
              let n2 = this.currentPage + b;
              n2 > f2 && (n2 = f2);
              0 < n2 && ("undefined" !== typeof d && D(d, c2), this.nav.attr({ translateX: k2, translateY: g2 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(b2) {
                b2.attr({ "class": 1 === n2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
              }), h2.attr({ text: n2 + "/" + f2 }), [this.down, this.downTracker].forEach(function(b2) {
                b2.attr({ x: 18 + this.pager.getBBox().width, "class": n2 === f2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
              }, this), c2.styledMode || (this.up.attr({ fill: 1 === n2 ? l2.inactiveColor : l2.activeColor }), this.upTracker.css({ cursor: 1 === n2 ? "default" : "pointer" }), this.down.attr({ fill: n2 === f2 ? l2.inactiveColor : l2.activeColor }), this.downTracker.css({ cursor: n2 === f2 ? "default" : "pointer" })), this.scrollOffset = -a3[n2 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = n2, this.positionCheckboxes(), b = r(e(d, c2.renderer.globalAnimation, true)), z(() => {
                B(this, "afterScroll", { currentPage: n2 });
              }, b.duration));
            }
            setItemEvents(b, d, c2) {
              const e2 = this, a3 = b.legendItem || {}, f2 = e2.chart.renderer.boxWrapper, g2 = b instanceof I, m = "highcharts-legend-" + (g2 ? "point" : "series") + "-active", l2 = e2.chart.styledMode;
              c2 = c2 ? [d, a3.symbol] : [a3.group];
              const h2 = (d2) => {
                e2.allItems.forEach((c3) => {
                  b !== c3 && [c3].concat(c3.linkedSeries || []).forEach((b2) => {
                    b2.setState(d2, !g2);
                  });
                });
              };
              for (const a4 of c2)
                if (a4)
                  a4.on("mouseover", function() {
                    b.visible && h2("inactive");
                    b.setState("hover");
                    b.visible && f2.addClass(m);
                    l2 || d.css(e2.options.itemHoverStyle);
                  }).on("mouseout", function() {
                    e2.chart.styledMode || d.css(E(b.visible ? e2.itemStyle : e2.itemHiddenStyle));
                    h2("");
                    f2.removeClass(m);
                    b.setState();
                  }).on("click", function(d2) {
                    const c3 = function() {
                      b.setVisible && b.setVisible();
                      h2(b.visible ? "inactive" : "");
                    };
                    f2.removeClass(m);
                    d2 = { browserEvent: d2 };
                    b.firePointEvent ? b.firePointEvent("legendItemClick", d2, c3) : B(b, "legendItemClick", d2, c3);
                  });
            }
            createCheckboxForItem(b) {
              b.checkbox = n("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: b.selected,
                defaultChecked: b.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              p(b.checkbox, "click", function(d) {
                B(b.series || b, "checkboxClick", { checked: d.target.checked, item: b }, function() {
                  b.select();
                });
              });
            }
          }
          (function(b) {
            const d = [];
            b.compose = function(c2) {
              A.pushUnique(d, c2) && p(c2, "beforeMargins", function() {
                this.legend = new b(this, this.options.legend);
              });
            };
          })(u || (u = {}));
          "";
          return u;
        }
      );
      K(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function(a2) {
        const { extend: r, merge: G, pick: I } = a2;
        var y;
        (function(a3) {
          a3.lineMarker = function(a4, y2) {
            y2 = this.legendItem = this.legendItem || {};
            var t = this.options;
            const q = a4.symbolWidth, k = a4.symbolHeight, p = k / 2, n = this.chart.renderer, h = y2.group;
            a4 = a4.baseline - Math.round(0.3 * a4.fontMetrics.b);
            let f = {}, c = t.marker, g = 0;
            this.chart.styledMode || (f = { "stroke-width": Math.min(t.lineWidth || 0, 24) }, t.dashStyle ? f.dashstyle = t.dashStyle : "square" !== t.linecap && (f["stroke-linecap"] = "round"));
            y2.line = n.path().addClass("highcharts-graph").attr(f).add(h);
            f["stroke-linecap"] && (g = Math.min(
              y2.line.strokeWidth(),
              q
            ) / 2);
            q && y2.line.attr({ d: [["M", g, a4], ["L", q - g, a4]] });
            c && false !== c.enabled && q && (t = Math.min(I(c.radius, p), p), 0 === this.symbol.indexOf("url") && (c = G(c, { width: k, height: k }), t = 0), y2.symbol = y2 = n.symbol(this.symbol, q / 2 - t, a4 - t, 2 * t, 2 * t, r({ context: "legend" }, c)).addClass("highcharts-point").add(h), y2.isMarker = true);
          };
          a3.rectangle = function(a4, r2) {
            r2 = r2.legendItem || {};
            const t = a4.symbolHeight, q = a4.options.squareSymbol;
            r2.symbol = this.chart.renderer.rect(q ? (a4.symbolWidth - t) / 2 : 0, a4.baseline - t + 1, q ? t : a4.symbolWidth, t, I(
              a4.options.symbolRadius,
              t / 2
            )).addClass("highcharts-point").attr({ zIndex: 3 }).add(r2.group);
          };
        })(y || (y = {}));
        return y;
      });
      K(a, "Core/Series/SeriesDefaults.js", [], function() {
        return {
          lineWidth: 1,
          allowPointSelect: false,
          crisp: true,
          showCheckbox: false,
          animation: { duration: 1e3 },
          enableMouseTracking: true,
          events: {},
          marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } },
          point: { events: {} },
          dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
            const { numberFormatter: a2 } = this.series.chart;
            return "number" !== typeof this.y ? "" : a2(this.y, -1);
          }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: true,
          states: {
            normal: { animation: true },
            hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } },
            select: { animation: { duration: 0 } },
            inactive: { animation: { duration: 150 }, opacity: 0.2 }
          },
          stickyTracking: true,
          turboThreshold: 1e3,
          findNearestPointBy: "x"
        };
      });
      K(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/Defaults.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, x, G, I) {
        const { defaultOptions: r } = x, { extendClass: A, merge: F } = I;
        var D;
        (function(t) {
          function q(a3, p) {
            const k = r.plotOptions || {}, h = p.defaultOptions, f = p.prototype;
            f.type = a3;
            f.pointClass || (f.pointClass = G);
            h && (k[a3] = h);
            t.seriesTypes[a3] = p;
          }
          t.seriesTypes = a2.seriesTypes;
          t.registerSeriesType = q;
          t.seriesType = function(a3, p, n, h, f) {
            const c = r.plotOptions || {};
            p = p || "";
            c[a3] = F(c[p], n);
            q(a3, A(t.seriesTypes[p] || function() {
            }, h));
            t.seriesTypes[a3].prototype.type = a3;
            f && (t.seriesTypes[a3].prototype.pointClass = A(G, f));
            return t.seriesTypes[a3];
          };
        })(D || (D = {}));
        return D;
      });
      K(a, "Core/Series/Series.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Legend/LegendSymbol.js"],
        a["Core/Series/Point.js"],
        a["Core/Series/SeriesDefaults.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y, A, F, D, t, q) {
        const { animObject: k, setAnimation: p } = a2, { defaultOptions: n } = x, { registerEventOptions: h } = G, { hasTouch: f, svg: c, win: g } = I, { seriesTypes: B } = D, {
          arrayMax: C,
          arrayMin: E,
          clamp: e,
          correctFloat: l,
          defined: v,
          diffObjects: z,
          erase: u,
          error: b,
          extend: d,
          find: m,
          fireEvent: w,
          getClosestDistance: r,
          getNestedProperty: H,
          insertItem: N,
          isArray: ea,
          isNumber: P,
          isString: Y,
          merge: R,
          objectEach: W,
          pick: J,
          removeEvent: K2,
          splat: fa,
          syncTimeout: V
        } = q;
        class T {
          constructor() {
            this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
          }
          init(b2, c2) {
            w(this, "init", { options: c2 });
            const a3 = this, e2 = b2.series;
            this.eventsToUnbind = [];
            a3.chart = b2;
            a3.options = a3.setOptions(c2);
            c2 = a3.options;
            a3.linkedSeries = [];
            a3.bindAxes();
            d(a3, { name: c2.name, state: "", visible: false !== c2.visible, selected: true === c2.selected });
            h(this, c2);
            const f2 = c2.events;
            if (f2 && f2.click || c2.point && c2.point.events && c2.point.events.click || c2.allowPointSelect)
              b2.runTrackerClick = true;
            a3.getColor();
            a3.getSymbol();
            a3.parallelArrays.forEach(function(b3) {
              a3[b3 + "Data"] || (a3[b3 + "Data"] = []);
            });
            a3.isCartesian && (b2.hasCartesianSeries = true);
            let g2;
            e2.length && (g2 = e2[e2.length - 1]);
            a3._i = J(g2 && g2._i, -1) + 1;
            a3.opacity = a3.options.opacity;
            b2.orderItems("series", N(this, e2));
            c2.dataSorting && c2.dataSorting.enabled ? a3.setDataSortingOptions() : a3.points || a3.data || a3.setData(c2.data, false);
            w(
              this,
              "afterInit"
            );
          }
          is(b2) {
            return B[b2] && this instanceof B[b2];
          }
          bindAxes() {
            const d2 = this, c2 = d2.options, a3 = d2.chart;
            let e2;
            w(this, "bindAxes", null, function() {
              (d2.axisTypes || []).forEach(function(f2) {
                a3[f2].forEach(function(b2) {
                  e2 = b2.options;
                  if (J(c2[f2], 0) === b2.index || "undefined" !== typeof c2[f2] && c2[f2] === e2.id)
                    N(d2, b2.series), d2[f2] = b2, b2.isDirty = true;
                });
                d2[f2] || d2.optionalAxis === f2 || b(18, true, a3);
              });
            });
            w(this, "afterBindAxes");
          }
          updateParallelArrays(b2, d2, c2) {
            const a3 = b2.series, e2 = P(d2) ? function(c3) {
              const e3 = "y" === c3 && a3.toYData ? a3.toYData(b2) : b2[c3];
              a3[c3 + "Data"][d2] = e3;
            } : function(b3) {
              Array.prototype[d2].apply(a3[b3 + "Data"], c2);
            };
            a3.parallelArrays.forEach(e2);
          }
          hasData() {
            return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
          }
          autoIncrement(b2) {
            var d2 = this.options;
            const c2 = d2.pointIntervalUnit, a3 = d2.relativeXValue, e2 = this.chart.time;
            let f2 = this.xIncrement, g2;
            f2 = J(f2, d2.pointStart, 0);
            this.pointInterval = g2 = J(this.pointInterval, d2.pointInterval, 1);
            a3 && P(b2) && (g2 *= b2);
            c2 && (d2 = new e2.Date(f2), "day" === c2 ? e2.set("Date", d2, e2.get(
              "Date",
              d2
            ) + g2) : "month" === c2 ? e2.set("Month", d2, e2.get("Month", d2) + g2) : "year" === c2 && e2.set("FullYear", d2, e2.get("FullYear", d2) + g2), g2 = d2.getTime() - f2);
            if (a3 && P(b2))
              return f2 + g2;
            this.xIncrement = f2 + g2;
            return f2;
          }
          setDataSortingOptions() {
            const b2 = this.options;
            d(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false });
            v(b2.pointRange) || (b2.pointRange = 1);
          }
          setOptions(b2) {
            var d2, c2;
            const a3 = this.chart;
            var e2 = a3.options.plotOptions, f2 = a3.userOptions || {};
            const g2 = R(b2);
            b2 = a3.styledMode;
            const m2 = { plotOptions: e2, userOptions: g2 };
            w(
              this,
              "setOptions",
              m2
            );
            const l2 = m2.plotOptions[this.type];
            f2 = f2.plotOptions || {};
            const h2 = f2.series || {}, k2 = n.plotOptions[this.type] || {}, u2 = f2[this.type] || {};
            this.userOptions = m2.userOptions;
            e2 = R(l2, e2.series, u2, g2);
            this.tooltipOptions = R(n.tooltip, null === (d2 = n.plotOptions.series) || void 0 === d2 ? void 0 : d2.tooltip, null === k2 || void 0 === k2 ? void 0 : k2.tooltip, a3.userOptions.tooltip, null === (c2 = f2.series) || void 0 === c2 ? void 0 : c2.tooltip, u2.tooltip, g2.tooltip);
            this.stickyTracking = J(g2.stickyTracking, u2.stickyTracking, h2.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : e2.stickyTracking);
            null === l2.marker && delete e2.marker;
            this.zoneAxis = e2.zoneAxis;
            c2 = this.zones = (e2.zones || []).slice();
            !e2.negativeColor && !e2.negativeFillColor || e2.zones || (d2 = { value: e2[this.zoneAxis + "Threshold"] || e2.threshold || 0, className: "highcharts-negative" }, b2 || (d2.color = e2.negativeColor, d2.fillColor = e2.negativeFillColor), c2.push(d2));
            c2.length && v(c2[c2.length - 1].value) && c2.push(b2 ? {} : { color: this.color, fillColor: this.fillColor });
            w(this, "afterSetOptions", { options: e2 });
            return e2;
          }
          getName() {
            return J(
              this.options.name,
              "Series " + (this.index + 1)
            );
          }
          getCyclic(b2, d2, c2) {
            const a3 = this.chart, e2 = `${b2}Index`, f2 = `${b2}Counter`, g2 = (null === c2 || void 0 === c2 ? void 0 : c2.length) || a3.options.chart.colorCount;
            if (!d2) {
              var m2 = J("color" === b2 ? this.options.colorIndex : void 0, this[e2]);
              v(m2) || (a3.series.length || (a3[f2] = 0), m2 = a3[f2] % g2, a3[f2] += 1);
              c2 && (d2 = c2[m2]);
            }
            "undefined" !== typeof m2 && (this[e2] = m2);
            this[b2] = d2;
          }
          getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic(
              "color",
              this.options.color || n.plotOptions[this.type].color,
              this.chart.options.colors
            );
          }
          getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          }
          getSymbol() {
            this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
          }
          findPointIndex(b2, d2) {
            const c2 = b2.id, a3 = b2.x, e2 = this.points;
            var f2 = this.options.dataSorting, g2;
            let l2, h2;
            if (c2)
              f2 = this.chart.get(c2), f2 instanceof A && (g2 = f2);
            else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
              if (g2 = (d3) => !d3.touched && d3.index === b2.index, f2 && f2.matchByName ? g2 = (d3) => !d3.touched && d3.name === b2.name : this.options.relativeXValue && (g2 = (d3) => !d3.touched && d3.options.x === b2.x), g2 = m(e2, g2), !g2)
                return;
            }
            g2 && (h2 = g2 && g2.index, "undefined" !== typeof h2 && (l2 = true));
            "undefined" === typeof h2 && P(a3) && (h2 = this.xData.indexOf(a3, d2));
            -1 !== h2 && "undefined" !== typeof h2 && this.cropped && (h2 = h2 >= this.cropStart ? h2 - this.cropStart : h2);
            !l2 && P(h2) && e2[h2] && e2[h2].touched && (h2 = void 0);
            return h2;
          }
          updateData(b2, d2) {
            const c2 = this.options, a3 = c2.dataSorting, e2 = this.points, f2 = [], g2 = this.requireSorting, m2 = b2.length === e2.length;
            let l2, h2, k2, n2 = true;
            this.xIncrement = null;
            b2.forEach(function(b3, d3) {
              var h3 = v(b3) && this.pointClass.prototype.optionsToObject.call({ series: this }, b3) || {};
              const n3 = h3.x;
              if (h3.id || P(n3)) {
                if (h3 = this.findPointIndex(h3, k2), -1 === h3 || "undefined" === typeof h3 ? f2.push(b3) : e2[h3] && b3 !== c2.data[h3] ? (e2[h3].update(b3, false, null, false), e2[h3].touched = true, g2 && (k2 = h3 + 1)) : e2[h3] && (e2[h3].touched = true), !m2 || d3 !== h3 || a3 && a3.enabled || this.hasDerivedData)
                  l2 = true;
              } else
                f2.push(b3);
            }, this);
            if (l2)
              for (b2 = e2.length; b2--; )
                (h2 = e2[b2]) && !h2.touched && h2.remove && h2.remove(false, d2);
            else
              !m2 || a3 && a3.enabled ? n2 = false : (b2.forEach(function(b3, d3) {
                b3 === e2[d3].y || e2[d3].destroyed || e2[d3].update(b3, false, null, false);
              }), f2.length = 0);
            e2.forEach(function(b3) {
              b3 && (b3.touched = false);
            });
            if (!n2)
              return false;
            f2.forEach(function(b3) {
              this.addPoint(b3, false, null, null, false);
            }, this);
            null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = C(this.xData), this.autoIncrement());
            return true;
          }
          setData(d2, c2 = true, a3, e2) {
            var f2;
            const g2 = this, m2 = g2.points, l2 = m2 && m2.length || 0, h2 = g2.options, k2 = g2.chart, n2 = h2.dataSorting, u2 = g2.xAxis, v2 = h2.turboThreshold, w2 = this.xData, p2 = this.yData;
            var z2 = g2.pointArrayMap;
            z2 = z2 && z2.length;
            const B2 = h2.keys;
            let q2, C2 = 0, E2 = 1, r2 = null;
            if (!k2.options.chart.allowMutatingData) {
              h2.data && delete g2.options.data;
              g2.userOptions.data && delete g2.userOptions.data;
              var t2 = R(true, d2);
            }
            d2 = t2 || d2 || [];
            t2 = d2.length;
            n2 && n2.enabled && (d2 = this.sortData(d2));
            k2.options.chart.allowMutatingData && false !== e2 && t2 && l2 && !g2.cropped && !g2.hasGroupedData && g2.visible && !g2.boosted && (q2 = this.updateData(d2, a3));
            if (!q2) {
              g2.xIncrement = null;
              g2.colorCounter = 0;
              this.parallelArrays.forEach(function(b2) {
                g2[b2 + "Data"].length = 0;
              });
              if (v2 && t2 > v2)
                if (r2 = g2.getFirstValidPoint(d2), P(r2))
                  for (a3 = 0; a3 < t2; a3++)
                    w2[a3] = this.autoIncrement(), p2[a3] = d2[a3];
                else if (ea(r2))
                  if (z2)
                    if (r2.length === z2)
                      for (a3 = 0; a3 < t2; a3++)
                        w2[a3] = this.autoIncrement(), p2[a3] = d2[a3];
                    else
                      for (a3 = 0; a3 < t2; a3++)
                        e2 = d2[a3], w2[a3] = e2[0], p2[a3] = e2.slice(1, z2 + 1);
                  else if (B2 && (C2 = B2.indexOf("x"), E2 = B2.indexOf("y"), C2 = 0 <= C2 ? C2 : 0, E2 = 0 <= E2 ? E2 : 1), 1 === r2.length && (E2 = 0), C2 === E2)
                    for (a3 = 0; a3 < t2; a3++)
                      w2[a3] = this.autoIncrement(), p2[a3] = d2[a3][E2];
                  else
                    for (a3 = 0; a3 < t2; a3++)
                      e2 = d2[a3], w2[a3] = e2[C2], p2[a3] = e2[E2];
                else
                  b(12, false, k2);
              else
                for (a3 = 0; a3 < t2; a3++)
                  e2 = { series: g2 }, g2.pointClass.prototype.applyOptions.apply(e2, [d2[a3]]), g2.updateParallelArrays(e2, a3);
              p2 && Y(p2[0]) && b(
                14,
                true,
                k2
              );
              g2.data = [];
              g2.options.data = g2.userOptions.data = d2;
              for (a3 = l2; a3--; )
                null === (f2 = m2[a3]) || void 0 === f2 ? void 0 : f2.destroy();
              u2 && (u2.minRange = u2.userMinRange);
              g2.isDirty = k2.isDirtyBox = true;
              g2.isDirtyData = !!m2;
              a3 = false;
            }
            "point" === h2.legendType && (this.processData(), this.generatePoints());
            c2 && k2.redraw(a3);
          }
          sortData(b2) {
            const d2 = this, c2 = d2.options.dataSorting.sortKey || "y", a3 = function(b3, d3) {
              return v(d3) && b3.pointClass.prototype.optionsToObject.call({ series: b3 }, d3) || {};
            };
            b2.forEach(function(c3, e2) {
              b2[e2] = a3(d2, c3);
              b2[e2].index = e2;
            }, this);
            b2.concat().sort((b3, d3) => {
              b3 = H(c2, b3);
              d3 = H(c2, d3);
              return d3 < b3 ? -1 : d3 > b3 ? 1 : 0;
            }).forEach(function(b3, d3) {
              b3.x = d3;
            }, this);
            d2.linkedSeries && d2.linkedSeries.forEach(function(d3) {
              const c3 = d3.options, e2 = c3.data;
              c3.dataSorting && c3.dataSorting.enabled || !e2 || (e2.forEach(function(c4, f2) {
                e2[f2] = a3(d3, c4);
                b2[f2] && (e2[f2].x = b2[f2].x, e2[f2].index = f2);
              }), d3.setData(e2, false));
            });
            return b2;
          }
          getProcessedData(d2) {
            const c2 = this;
            var a3 = c2.xAxis, e2 = c2.options;
            const f2 = e2.cropThreshold, g2 = d2 || c2.getExtremesFromAll || e2.getExtremesFromAll, m2 = null === a3 || void 0 === a3 ? void 0 : a3.logarithmic, l2 = c2.isCartesian;
            let h2 = 0;
            let k2;
            d2 = c2.xData;
            e2 = c2.yData;
            let n2 = false;
            const u2 = d2.length;
            if (a3) {
              var v2 = a3.getExtremes();
              k2 = v2.min;
              v2 = v2.max;
              n2 = !(!a3.categories || a3.names.length);
            }
            if (l2 && c2.sorted && !g2 && (!f2 || u2 > f2 || c2.forceCrop)) {
              if (d2[u2 - 1] < k2 || d2[0] > v2)
                d2 = [], e2 = [];
              else if (c2.yData && (d2[0] < k2 || d2[u2 - 1] > v2)) {
                var w2 = this.cropData(c2.xData, c2.yData, k2, v2);
                d2 = w2.xData;
                e2 = w2.yData;
                h2 = w2.start;
                w2 = true;
              }
            }
            a3 = r([m2 ? d2.map(m2.log2lin) : d2], () => c2.requireSorting && !n2 && b(15, false, c2.chart));
            return { xData: d2, yData: e2, cropped: w2, cropStart: h2, closestPointRange: a3 };
          }
          processData(b2) {
            const d2 = this.xAxis;
            if (this.isCartesian && !this.isDirty && !d2.isDirty && !this.yAxis.isDirty && !b2)
              return false;
            b2 = this.getProcessedData();
            this.cropped = b2.cropped;
            this.cropStart = b2.cropStart;
            this.processedXData = b2.xData;
            this.processedYData = b2.yData;
            this.closestPointRange = this.basePointRange = b2.closestPointRange;
            w(this, "afterProcessData");
          }
          cropData(b2, d2, c2, a3, e2) {
            const f2 = b2.length;
            let g2, m2 = 0, l2 = f2;
            e2 = J(e2, this.cropShoulder);
            for (g2 = 0; g2 < f2; g2++)
              if (b2[g2] >= c2) {
                m2 = Math.max(0, g2 - e2);
                break;
              }
            for (c2 = g2; c2 < f2; c2++)
              if (b2[c2] > a3) {
                l2 = c2 + e2;
                break;
              }
            return {
              xData: b2.slice(m2, l2),
              yData: d2.slice(m2, l2),
              start: m2,
              end: l2
            };
          }
          generatePoints() {
            var b2 = this.options;
            const c2 = this.processedData || b2.data, a3 = this.processedXData, e2 = this.processedYData, f2 = this.pointClass, g2 = a3.length, m2 = this.cropStart || 0, l2 = this.hasGroupedData, h2 = b2.keys, k2 = [];
            b2 = b2.dataGrouping && b2.dataGrouping.groupAll ? m2 : 0;
            let n2;
            let u2, v2, p2 = this.data;
            if (!p2 && !l2) {
              var z2 = [];
              z2.length = c2.length;
              p2 = this.data = z2;
            }
            h2 && l2 && (this.options.keys = false);
            for (v2 = 0; v2 < g2; v2++)
              z2 = m2 + v2, l2 ? (u2 = new f2().init(this, [a3[v2]].concat(fa(e2[v2]))), u2.dataGroup = this.groupMap[b2 + v2], u2.dataGroup.options && (u2.options = u2.dataGroup.options, d(u2, u2.dataGroup.options), delete u2.dataLabels)) : (u2 = p2[z2]) || "undefined" === typeof c2[z2] || (p2[z2] = u2 = new f2().init(this, c2[z2], a3[v2])), u2 && (u2.index = l2 ? b2 + v2 : z2, k2[v2] = u2);
            this.options.keys = h2;
            if (p2 && (g2 !== (n2 = p2.length) || l2))
              for (v2 = 0; v2 < n2; v2++)
                v2 !== m2 || l2 || (v2 += g2), p2[v2] && (p2[v2].destroyElements(), p2[v2].plotX = void 0);
            this.data = p2;
            this.points = k2;
            w(this, "afterGeneratePoints");
          }
          getXExtremes(b2) {
            return { min: E(b2), max: C(b2) };
          }
          getExtremes(b2, d2) {
            const c2 = this.xAxis;
            var a3 = this.yAxis;
            const e2 = this.processedXData || this.xData, f2 = [], g2 = this.requireSorting ? this.cropShoulder : 0;
            a3 = a3 ? a3.positiveValuesOnly : false;
            let m2, l2 = 0, h2 = 0, k2 = 0;
            b2 = b2 || this.stackedYData || this.processedYData || [];
            const n2 = b2.length;
            if (c2) {
              var v2 = c2.getExtremes();
              l2 = v2.min;
              h2 = v2.max;
            }
            for (m2 = 0; m2 < n2; m2++) {
              var u2 = e2[m2];
              v2 = b2[m2];
              var p2 = (P(v2) || ea(v2)) && (v2.length || 0 < v2 || !a3);
              u2 = d2 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c2 || (e2[m2 + g2] || u2) >= l2 && (e2[m2 - g2] || u2) <= h2;
              if (p2 && u2)
                if (p2 = v2.length)
                  for (; p2--; )
                    P(v2[p2]) && (f2[k2++] = v2[p2]);
                else
                  f2[k2++] = v2;
            }
            b2 = { activeYData: f2, dataMin: E(f2), dataMax: C(f2) };
            w(this, "afterGetExtremes", { dataExtremes: b2 });
            return b2;
          }
          applyExtremes() {
            const b2 = this.getExtremes();
            this.dataMin = b2.dataMin;
            this.dataMax = b2.dataMax;
            return b2;
          }
          getFirstValidPoint(b2) {
            const d2 = b2.length;
            let c2 = 0, a3 = null;
            for (; null === a3 && c2 < d2; )
              a3 = b2[c2], c2++;
            return a3;
          }
          translate() {
            var b2;
            this.processedXData || this.processData();
            this.generatePoints();
            var d2 = this.options;
            const c2 = d2.stacking, a3 = this.xAxis, f2 = a3.categories, g2 = this.enabledDataSorting, m2 = this.yAxis, h2 = this.points, k2 = h2.length, n2 = this.pointPlacementToXValue(), u2 = !!n2, p2 = d2.threshold;
            d2 = d2.startFromThreshold ? p2 : 0;
            let z2, B2, C2, q2, E2 = Number.MAX_VALUE;
            for (z2 = 0; z2 < k2; z2++) {
              const k3 = h2[z2], w2 = k3.x;
              let r2, t2, H2 = k3.y, M = k3.low;
              const y2 = c2 && (null === (b2 = m2.stacking) || void 0 === b2 ? void 0 : b2.stacks[(this.negStacks && H2 < (d2 ? 0 : p2) ? "-" : "") + this.stackKey]);
              B2 = a3.translate(w2, false, false, false, true, n2);
              k3.plotX = P(B2) ? l(e(B2, -1e5, 1e5)) : void 0;
              c2 && this.visible && y2 && y2[w2] && (q2 = this.getStackIndicator(q2, w2, this.index), !k3.isNull && q2.key && (r2 = y2[w2], t2 = r2.points[q2.key]), r2 && ea(t2) && (M = t2[0], H2 = t2[1], M === d2 && q2.key === y2[w2].base && (M = J(P(p2) ? p2 : m2.min)), m2.positiveValuesOnly && v(M) && 0 >= M && (M = void 0), k3.total = k3.stackTotal = J(r2.total), k3.percentage = v(k3.y) && r2.total ? k3.y / r2.total * 100 : void 0, k3.stackY = H2, this.irregularWidths || r2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));
              k3.yBottom = v(M) ? e(m2.translate(M, false, true, false, true), -1e5, 1e5) : void 0;
              this.dataModify && (H2 = this.dataModify.modifyValue(H2, z2));
              let L;
              P(H2) && void 0 !== k3.plotX && (L = m2.translate(H2, false, true, false, true), L = P(L) ? e(L, -1e5, 1e5) : void 0);
              k3.plotY = L;
              k3.isInside = this.isPointInside(k3);
              k3.clientX = u2 ? l(a3.translate(w2, false, false, false, true, n2)) : B2;
              k3.negative = (k3.y || 0) < (p2 || 0);
              k3.category = J(f2 && f2[k3.x], k3.x);
              k3.isNull || false === k3.visible || ("undefined" !== typeof C2 && (E2 = Math.min(E2, Math.abs(B2 - C2))), C2 = B2);
              k3.zone = this.zones.length ? k3.getZone() : void 0;
              !k3.graphic && this.group && g2 && (k3.isNew = true);
            }
            this.closestPointRangePx = E2;
            w(this, "afterTranslate");
          }
          getValidPoints(b2, d2, c2) {
            const a3 = this.chart;
            return (b2 || this.points || []).filter(function(b3) {
              const { plotX: e2, plotY: f2 } = b3;
              return !c2 && (b3.isNull || !P(f2)) || d2 && !a3.isInsidePlot(e2, f2, { inverted: a3.inverted }) ? false : false !== b3.visible;
            });
          }
          getClipBox() {
            const { chart: b2, xAxis: d2, yAxis: c2 } = this, a3 = R(b2.clipBox);
            d2 && d2.len !== b2.plotSizeX && (a3.width = d2.len);
            c2 && c2.len !== b2.plotSizeY && (a3.height = c2.len);
            return a3;
          }
          getSharedClipKey() {
            return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
          }
          setClip() {
            const { chart: b2, group: d2, markerGroup: c2 } = this, a3 = b2.sharedClips, e2 = b2.renderer, f2 = this.getClipBox(), g2 = this.getSharedClipKey();
            let m2 = a3[g2];
            m2 ? m2.animate(f2) : a3[g2] = m2 = e2.clipRect(f2);
            d2 && d2.clip(false === this.options.clip ? void 0 : m2);
            c2 && c2.clip();
          }
          animate(b2) {
            const { chart: d2, group: c2, markerGroup: a3 } = this, e2 = d2.inverted;
            var f2 = k(this.options.animation), g2 = [this.getSharedClipKey(), f2.duration, f2.easing, f2.defer].join();
            let m2 = d2.sharedClips[g2], l2 = d2.sharedClips[g2 + "m"];
            if (b2 && c2)
              f2 = this.getClipBox(), m2 ? m2.attr("height", f2.height) : (f2.width = 0, e2 && (f2.x = d2.plotHeight), m2 = d2.renderer.clipRect(f2), d2.sharedClips[g2] = m2, l2 = d2.renderer.clipRect({ x: -99, y: -99, width: e2 ? d2.plotWidth + 199 : 99, height: e2 ? 99 : d2.plotHeight + 199 }), d2.sharedClips[g2 + "m"] = l2), c2.clip(m2), a3 && a3.clip(l2);
            else if (m2 && !m2.hasClass("highcharts-animating")) {
              g2 = this.getClipBox();
              const b3 = f2.step;
              a3 && a3.element.childNodes.length && (f2.step = function(d3, c3) {
                b3 && b3.apply(c3, arguments);
                "width" === c3.prop && l2 && l2.element && l2.attr(e2 ? "height" : "width", d3 + 99);
              });
              m2.addClass("highcharts-animating").animate(g2, f2);
            }
          }
          afterAnimate() {
            this.setClip();
            W(this.chart.sharedClips, (b2, d2, c2) => {
              b2 && !this.chart.container.querySelector(`[clip-path="url(#${b2.id})"]`) && (b2.destroy(), delete c2[d2]);
            });
            this.finishedAnimating = true;
            w(this, "afterAnimate");
          }
          drawPoints(b2 = this.points) {
            const d2 = this.chart, c2 = d2.styledMode, { colorAxis: a3, options: e2 } = this, f2 = e2.marker, g2 = this[this.specialGroup || "markerGroup"], m2 = this.xAxis, l2 = J(f2.enabled, !m2 || m2.isRadial ? true : null, this.closestPointRangePx >= f2.enabledThreshold * f2.radius);
            let h2, k2, n2, v2;
            let u2, w2;
            if (false !== f2.enabled || this._hasPointMarkers)
              for (h2 = 0; h2 < b2.length; h2++) {
                k2 = b2[h2];
                v2 = (n2 = k2.graphic) ? "animate" : "attr";
                var p2 = k2.marker || {};
                u2 = !!k2.marker;
                if ((l2 && "undefined" === typeof p2.enabled || p2.enabled) && !k2.isNull && false !== k2.visible) {
                  const b3 = J(p2.symbol, this.symbol, "rect");
                  w2 = this.markerAttribs(k2, k2.selected && "select");
                  this.enabledDataSorting && (k2.startXPos = m2.reversed ? -(w2.width || 0) : m2.width);
                  const e3 = false !== k2.isInside;
                  !n2 && e3 && (0 < (w2.width || 0) || k2.hasImage) && (k2.graphic = n2 = d2.renderer.symbol(b3, w2.x, w2.y, w2.width, w2.height, u2 ? p2 : f2).add(g2), this.enabledDataSorting && d2.hasRendered && (n2.attr({ x: k2.startXPos }), v2 = "animate"));
                  n2 && "animate" === v2 && n2[e3 ? "show" : "hide"](e3).animate(w2);
                  if (n2)
                    if (p2 = this.pointAttribs(k2, c2 || !k2.selected ? void 0 : "select"), c2)
                      a3 && n2.css({ fill: p2.fill });
                    else
                      n2[v2](p2);
                  n2 && n2.addClass(k2.getClassName(), true);
                } else
                  n2 && (k2.graphic = n2.destroy());
              }
          }
          markerAttribs(b2, d2) {
            const c2 = this.options;
            var a3 = c2.marker;
            const e2 = b2.marker || {}, f2 = e2.symbol || a3.symbol, g2 = {};
            let m2 = J(e2.radius, a3 && a3.radius);
            d2 && (a3 = a3.states[d2], d2 = e2.states && e2.states[d2], m2 = J(d2 && d2.radius, a3 && a3.radius, m2 && m2 + (a3 && a3.radiusPlus || 0)));
            b2.hasImage = f2 && 0 === f2.indexOf("url");
            b2.hasImage && (m2 = 0);
            b2 = b2.pos();
            P(m2) && b2 && (g2.x = b2[0] - m2, g2.y = b2[1] - m2, c2.crisp && (g2.x = Math.floor(g2.x)));
            m2 && (g2.width = g2.height = 2 * m2);
            return g2;
          }
          pointAttribs(b2, d2) {
            var c2 = this.options.marker, a3 = b2 && b2.options;
            const e2 = a3 && a3.marker || {};
            var f2 = a3 && a3.color, g2 = b2 && b2.color;
            const m2 = b2 && b2.zone && b2.zone.color;
            let l2 = this.color;
            b2 = J(e2.lineWidth, c2.lineWidth);
            a3 = 1;
            l2 = f2 || m2 || g2 || l2;
            f2 = e2.fillColor || c2.fillColor || l2;
            g2 = e2.lineColor || c2.lineColor || l2;
            d2 = d2 || "normal";
            c2 = c2.states[d2] || {};
            d2 = e2.states && e2.states[d2] || {};
            b2 = J(d2.lineWidth, c2.lineWidth, b2 + J(d2.lineWidthPlus, c2.lineWidthPlus, 0));
            f2 = d2.fillColor || c2.fillColor || f2;
            g2 = d2.lineColor || c2.lineColor || g2;
            a3 = J(d2.opacity, c2.opacity, a3);
            return { stroke: g2, "stroke-width": b2, fill: f2, opacity: a3 };
          }
          destroy(b2) {
            const d2 = this, c2 = d2.chart, a3 = /AppleWebKit\/533/.test(g.navigator.userAgent), e2 = d2.data || [];
            let f2, m2, l2, h2;
            w(d2, "destroy", { keepEventsForUpdate: b2 });
            this.removeEvents(b2);
            (d2.axisTypes || []).forEach(function(b3) {
              (h2 = d2[b3]) && h2.series && (u(h2.series, d2), h2.isDirty = h2.forceRedraw = true);
            });
            d2.legendItem && d2.chart.legend.destroyItem(d2);
            for (m2 = e2.length; m2--; )
              (l2 = e2[m2]) && l2.destroy && l2.destroy();
            d2.clips && d2.clips.forEach((b3) => b3.destroy());
            q.clearTimeout(d2.animationTimeout);
            W(d2, function(b3, d3) {
              b3 instanceof t && !b3.survive && (f2 = a3 && "group" === d3 ? "hide" : "destroy", b3[f2]());
            });
            c2.hoverSeries === d2 && (c2.hoverSeries = void 0);
            u(c2.series, d2);
            c2.orderItems("series");
            W(d2, function(c3, a4) {
              b2 && "hcEvents" === a4 || delete d2[a4];
            });
          }
          applyZones() {
            const b2 = this, d2 = this.chart, c2 = d2.renderer, a3 = this.zones, f2 = this.clips || [], g2 = this.graph, m2 = this.area, l2 = Math.max(d2.plotWidth, d2.plotHeight), h2 = this[(this.zoneAxis || "y") + "Axis"], k2 = d2.inverted;
            let n2, v2, u2, w2, p2, z2, B2, q2, C2, E2, r2, t2 = false;
            a3.length && (g2 || m2) && h2 && "undefined" !== typeof h2.min ? (p2 = h2.reversed, z2 = h2.horiz, g2 && !this.showLine && g2.hide(), m2 && m2.hide(), w2 = h2.getExtremes(), a3.forEach(function(a4, H2) {
              n2 = p2 ? z2 ? d2.plotWidth : 0 : z2 ? 0 : h2.toPixels(w2.min) || 0;
              n2 = e(J(v2, n2), 0, l2);
              v2 = e(Math.round(h2.toPixels(J(a4.value, w2.max), true) || 0), 0, l2);
              t2 && (n2 = v2 = h2.toPixels(w2.max));
              B2 = Math.abs(n2 - v2);
              q2 = Math.min(n2, v2);
              C2 = Math.max(n2, v2);
              h2.isXAxis ? (u2 = { x: k2 ? C2 : q2, y: 0, width: B2, height: l2 }, z2 || (u2.x = d2.plotHeight - u2.x)) : (u2 = { x: 0, y: k2 ? C2 : q2, width: l2, height: B2 }, z2 && (u2.y = d2.plotWidth - u2.y));
              f2[H2] ? f2[H2].animate(u2) : f2[H2] = c2.clipRect(u2);
              E2 = b2["zone-area-" + H2];
              r2 = b2["zone-graph-" + H2];
              g2 && r2 && r2.clip(f2[H2]);
              m2 && E2 && E2.clip(f2[H2]);
              t2 = a4.value > w2.max;
              b2.resetZones && 0 === v2 && (v2 = void 0);
            }), this.clips = f2) : b2.visible && (g2 && g2.show(), m2 && m2.show());
          }
          plotGroup(b2, d2, c2, a3, e2) {
            let f2 = this[b2];
            const g2 = !f2;
            c2 = { visibility: c2, zIndex: a3 || 0.1 };
            "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c2.opacity = this.opacity);
            g2 && (this[b2] = f2 = this.chart.renderer.g().add(e2));
            f2.addClass("highcharts-" + d2 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (v(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f2.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
            f2.attr(c2)[g2 ? "attr" : "animate"](this.getPlotBox(d2));
            return f2;
          }
          getPlotBox(b2) {
            let d2 = this.xAxis, c2 = this.yAxis;
            const a3 = this.chart;
            b2 = a3.inverted && !a3.polar && d2 && false !== this.invertible && "series" === b2;
            a3.inverted && (d2 = c2, c2 = this.xAxis);
            return { translateX: d2 ? d2.left : a3.plotLeft, translateY: c2 ? c2.top : a3.plotTop, rotation: b2 ? 90 : 0, rotationOriginX: b2 ? (d2.len - c2.len) / 2 : 0, rotationOriginY: b2 ? (d2.len + c2.len) / 2 : 0, scaleX: b2 ? -1 : 1, scaleY: 1 };
          }
          removeEvents(b2) {
            b2 || K2(this);
            this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(b3) {
              b3();
            }), this.eventsToUnbind.length = 0);
          }
          render() {
            const b2 = this;
            var d2 = b2.chart;
            const c2 = b2.options, a3 = k(c2.animation), e2 = b2.visible ? "inherit" : "hidden", f2 = c2.zIndex, g2 = b2.hasRendered;
            d2 = d2.seriesGroup;
            let m2 = b2.finishedAnimating ? 0 : a3.duration;
            w(this, "render");
            b2.plotGroup("group", "series", e2, f2, d2);
            b2.markerGroup = b2.plotGroup("markerGroup", "markers", e2, f2, d2);
            false !== c2.clip && b2.setClip();
            b2.animate && m2 && b2.animate(true);
            b2.drawGraph && (b2.drawGraph(), b2.applyZones());
            b2.visible && b2.drawPoints();
            b2.drawDataLabels && b2.drawDataLabels();
            b2.redrawPoints && b2.redrawPoints();
            b2.drawTracker && c2.enableMouseTracking && b2.drawTracker();
            b2.animate && m2 && b2.animate();
            g2 || (m2 && a3.defer && (m2 += a3.defer), b2.animationTimeout = V(function() {
              b2.afterAnimate();
            }, m2 || 0));
            b2.isDirty = false;
            b2.hasRendered = true;
            w(b2, "afterRender");
          }
          redraw() {
            const b2 = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            b2 && delete this.kdTree;
          }
          searchPoint(b2, d2) {
            const c2 = this.xAxis, a3 = this.yAxis, e2 = this.chart.inverted;
            return this.searchKDTree({ clientX: e2 ? c2.len - b2.chartY + c2.pos : b2.chartX - c2.pos, plotY: e2 ? a3.len - b2.chartX + a3.pos : b2.chartY - a3.pos }, d2, b2);
          }
          buildKDTree(b2) {
            function d2(b3, a4, e2) {
              var f2 = b3 && b3.length;
              let g2;
              if (f2)
                return g2 = c2.kdAxisArray[a4 % e2], b3.sort(function(b4, d3) {
                  return b4[g2] - d3[g2];
                }), f2 = Math.floor(f2 / 2), { point: b3[f2], left: d2(b3.slice(0, f2), a4 + 1, e2), right: d2(b3.slice(f2 + 1), a4 + 1, e2) };
            }
            this.buildingKdTree = true;
            const c2 = this, a3 = -1 < c2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete c2.kdTree;
            V(function() {
              c2.kdTree = d2(c2.getValidPoints(null, !c2.directTouch), a3, a3);
              c2.buildingKdTree = false;
            }, c2.options.kdNow || b2 && "touchstart" === b2.type ? 0 : 1);
          }
          searchKDTree(b2, d2, c2) {
            function a3(b3, d3, c3, l2) {
              const h2 = d3.point;
              var k2 = e2.kdAxisArray[c3 % l2];
              let n2 = h2;
              var u2 = v(b3[f2]) && v(h2[f2]) ? Math.pow(b3[f2] - h2[f2], 2) : null;
              var w2 = v(b3[g2]) && v(h2[g2]) ? Math.pow(b3[g2] - h2[g2], 2) : null;
              w2 = (u2 || 0) + (w2 || 0);
              h2.dist = v(w2) ? Math.sqrt(w2) : Number.MAX_VALUE;
              h2.distX = v(u2) ? Math.sqrt(u2) : Number.MAX_VALUE;
              k2 = b3[k2] - h2[k2];
              w2 = 0 > k2 ? "left" : "right";
              u2 = 0 > k2 ? "right" : "left";
              d3[w2] && (w2 = a3(b3, d3[w2], c3 + 1, l2), n2 = w2[m2] < n2[m2] ? w2 : h2);
              d3[u2] && Math.sqrt(k2 * k2) < n2[m2] && (b3 = a3(b3, d3[u2], c3 + 1, l2), n2 = b3[m2] < n2[m2] ? b3 : n2);
              return n2;
            }
            const e2 = this, f2 = this.kdAxisArray[0], g2 = this.kdAxisArray[1], m2 = d2 ? "distX" : "dist";
            d2 = -1 < e2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree(c2);
            if (this.kdTree)
              return a3(
                b2,
                this.kdTree,
                d2,
                d2
              );
          }
          pointPlacementToXValue() {
            const { options: { pointPlacement: b2, pointRange: d2 }, xAxis: c2 } = this;
            let a3 = b2;
            "between" === a3 && (a3 = c2.reversed ? -0.5 : 0.5);
            return P(a3) ? a3 * (d2 || c2.pointRange) : 0;
          }
          isPointInside(b2) {
            const { chart: d2, xAxis: c2, yAxis: a3 } = this;
            return "undefined" !== typeof b2.plotY && "undefined" !== typeof b2.plotX && 0 <= b2.plotY && b2.plotY <= (a3 ? a3.len : d2.plotHeight) && 0 <= b2.plotX && b2.plotX <= (c2 ? c2.len : d2.plotWidth);
          }
          drawTracker() {
            const b2 = this, d2 = b2.options, a3 = d2.trackByArea, e2 = [].concat(a3 ? b2.areaPath : b2.graphPath), g2 = b2.chart, m2 = g2.pointer, l2 = g2.renderer, h2 = g2.options.tooltip.snap, k2 = b2.tracker, n2 = function(c2) {
              if (d2.enableMouseTracking && g2.hoverSeries !== b2)
                b2.onMouseOver();
            }, v2 = "rgba(192,192,192," + (c ? 1e-4 : 2e-3) + ")";
            k2 ? k2.attr({ d: e2 }) : b2.graph && (b2.tracker = l2.path(e2).attr({ visibility: b2.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(a3 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b2.group), g2.styledMode || b2.tracker.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: v2, fill: a3 ? v2 : "none", "stroke-width": b2.graph.strokeWidth() + (a3 ? 0 : 2 * h2) }), [
              b2.tracker,
              b2.markerGroup,
              b2.dataLabelsGroup
            ].forEach(function(b3) {
              if (b3 && (b3.addClass("highcharts-tracker").on("mouseover", n2).on("mouseout", function(b4) {
                m2.onTrackerMouseOut(b4);
              }), d2.cursor && !g2.styledMode && b3.css({ cursor: d2.cursor }), f))
                b3.on("touchstart", n2);
            }));
            w(this, "afterDrawTracker");
          }
          addPoint(b2, d2, c2, a3, e2) {
            const f2 = this.options, g2 = this.data, m2 = this.chart;
            var l2 = this.xAxis;
            l2 = l2 && l2.hasNames && l2.names;
            const h2 = f2.data, k2 = this.xData;
            let n2, v2;
            d2 = J(d2, true);
            const u2 = { series: this };
            this.pointClass.prototype.applyOptions.apply(u2, [b2]);
            const p2 = u2.x;
            v2 = k2.length;
            if (this.requireSorting && p2 < k2[v2 - 1])
              for (n2 = true; v2 && k2[v2 - 1] > p2; )
                v2--;
            this.updateParallelArrays(u2, "splice", [v2, 0, 0]);
            this.updateParallelArrays(u2, v2);
            l2 && u2.name && (l2[p2] = u2.name);
            h2.splice(v2, 0, b2);
            if (n2 || this.processedData)
              this.data.splice(v2, 0, null), this.processData();
            "point" === f2.legendType && this.generatePoints();
            c2 && (g2[0] && g2[0].remove ? g2[0].remove(false) : (g2.shift(), this.updateParallelArrays(u2, "shift"), h2.shift()));
            false !== e2 && w(this, "addPoint", { point: u2 });
            this.isDirtyData = this.isDirty = true;
            d2 && m2.redraw(a3);
          }
          removePoint(b2, d2, c2) {
            const a3 = this, e2 = a3.data, f2 = e2[b2], g2 = a3.points, m2 = a3.chart, l2 = function() {
              g2 && g2.length === e2.length && g2.splice(b2, 1);
              e2.splice(b2, 1);
              a3.options.data.splice(b2, 1);
              a3.updateParallelArrays(f2 || { series: a3 }, "splice", [b2, 1]);
              f2 && f2.destroy();
              a3.isDirty = true;
              a3.isDirtyData = true;
              d2 && m2.redraw();
            };
            p(c2, m2);
            d2 = J(d2, true);
            f2 ? f2.firePointEvent("remove", null, l2) : l2();
          }
          remove(b2, d2, c2, a3) {
            function e2() {
              f2.destroy(a3);
              g2.isDirtyLegend = g2.isDirtyBox = true;
              g2.linkSeries(a3);
              J(b2, true) && g2.redraw(d2);
            }
            const f2 = this, g2 = f2.chart;
            false !== c2 ? w(f2, "remove", null, e2) : e2();
          }
          update(c2, a3) {
            c2 = z(c2, this.userOptions);
            w(this, "update", { options: c2 });
            const e2 = this, f2 = e2.chart;
            var g2 = e2.userOptions;
            const m2 = e2.initialType || e2.type;
            var l2 = f2.options.plotOptions;
            const h2 = B[m2].prototype;
            var k2 = e2.finishedAnimating && { animation: false };
            const n2 = {};
            let v2, u2 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], p2 = c2.type || g2.type || f2.options.chart.type;
            const q2 = !(this.hasDerivedData || p2 && p2 !== this.type || "undefined" !== typeof c2.pointStart || "undefined" !== typeof c2.pointInterval || "undefined" !== typeof c2.relativeXValue || c2.joinBy || c2.mapData || e2.hasOptionChanged("dataGrouping") || e2.hasOptionChanged("pointStart") || e2.hasOptionChanged("pointInterval") || e2.hasOptionChanged("pointIntervalUnit") || e2.hasOptionChanged("keys"));
            p2 = p2 || m2;
            q2 && (u2.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), false !== c2.visible && u2.push("area", "graph"), e2.parallelArrays.forEach(function(b2) {
              u2.push(b2 + "Data");
            }), c2.data && (c2.dataSorting && d(e2.options.dataSorting, c2.dataSorting), this.setData(c2.data, false)));
            c2 = R(g2, k2, { index: "undefined" === typeof g2.index ? e2.index : g2.index, pointStart: J(l2 && l2.series && l2.series.pointStart, g2.pointStart, e2.xData[0]) }, !q2 && { data: e2.options.data }, c2);
            q2 && c2.data && (c2.data = e2.options.data);
            u2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(u2);
            u2.forEach(function(b2) {
              u2[b2] = e2[b2];
              delete e2[b2];
            });
            l2 = false;
            if (B[p2]) {
              if (l2 = p2 !== e2.type, e2.remove(false, false, false, true), l2)
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(
                    e2,
                    B[p2].prototype
                  );
                else {
                  k2 = Object.hasOwnProperty.call(e2, "hcEvents") && e2.hcEvents;
                  for (v2 in h2)
                    e2[v2] = void 0;
                  d(e2, B[p2].prototype);
                  k2 ? e2.hcEvents = k2 : delete e2.hcEvents;
                }
            } else
              b(17, true, f2, { missingModuleFor: p2 });
            u2.forEach(function(b2) {
              e2[b2] = u2[b2];
            });
            e2.init(f2, c2);
            if (q2 && this.points) {
              c2 = e2.options;
              if (false === c2.visible)
                n2.graphic = 1, n2.dataLabel = 1;
              else if (!e2._hasPointLabels) {
                const { marker: b2, dataLabels: d2 } = c2;
                g2 = g2.marker || {};
                !b2 || false !== b2.enabled && g2.symbol === b2.symbol && g2.height === b2.height && g2.width === b2.width || (n2.graphic = 1);
                d2 && false === d2.enabled && (n2.dataLabel = 1);
              }
              for (const b2 of this.points)
                b2 && b2.series && (b2.resolveColor(), Object.keys(n2).length && b2.destroyElements(n2), false === c2.showInLegend && b2.legendItem && f2.legend.destroyItem(b2));
            }
            e2.initialType = m2;
            f2.linkSeries();
            l2 && e2.linkedSeries.length && (e2.isDirtyData = true);
            w(this, "afterUpdate");
            J(a3, true) && f2.redraw(q2 ? void 0 : false);
          }
          setName(b2) {
            this.name = this.options.name = this.userOptions.name = b2;
            this.chart.isDirtyLegend = true;
          }
          hasOptionChanged(b2) {
            const d2 = this.options[b2], c2 = this.chart.options.plotOptions, a3 = this.userOptions[b2];
            return a3 ? d2 !== a3 : d2 !== J(c2 && c2[this.type] && c2[this.type][b2], c2 && c2.series && c2.series[b2], d2);
          }
          onMouseOver() {
            const b2 = this.chart, d2 = b2.hoverSeries;
            b2.pointer.setHoverChartIndex();
            if (d2 && d2 !== this)
              d2.onMouseOut();
            this.options.events.mouseOver && w(this, "mouseOver");
            this.setState("hover");
            b2.hoverSeries = this;
          }
          onMouseOut() {
            const b2 = this.options, d2 = this.chart, c2 = d2.tooltip, a3 = d2.hoverPoint;
            d2.hoverSeries = null;
            if (a3)
              a3.onMouseOut();
            this && b2.events.mouseOut && w(this, "mouseOut");
            !c2 || this.stickyTracking || c2.shared && !this.noSharedTooltip || c2.hide();
            d2.series.forEach(function(b3) {
              b3.setState(
                "",
                true
              );
            });
          }
          setState(b2, d2) {
            const c2 = this;
            var a3 = c2.options;
            const e2 = c2.graph, f2 = a3.inactiveOtherPoints, g2 = a3.states, m2 = J(g2[b2 || "normal"] && g2[b2 || "normal"].animation, c2.chart.options.chart.animation);
            let l2 = a3.lineWidth, h2 = 0, k2 = a3.opacity;
            b2 = b2 || "";
            if (c2.state !== b2 && ([c2.group, c2.markerGroup, c2.dataLabelsGroup].forEach(function(d3) {
              d3 && (c2.state && d3.removeClass("highcharts-series-" + c2.state), b2 && d3.addClass("highcharts-series-" + b2));
            }), c2.state = b2, !c2.chart.styledMode)) {
              if (g2[b2] && false === g2[b2].enabled)
                return;
              b2 && (l2 = g2[b2].lineWidth || l2 + (g2[b2].lineWidthPlus || 0), k2 = J(g2[b2].opacity, k2));
              if (e2 && !e2.dashstyle && P(l2))
                for (a3 = { "stroke-width": l2 }, e2.animate(a3, m2); c2["zone-graph-" + h2]; )
                  c2["zone-graph-" + h2].animate(a3, m2), h2 += 1;
              f2 || [c2.group, c2.markerGroup, c2.dataLabelsGroup, c2.labelBySeries].forEach(function(b3) {
                b3 && b3.animate({ opacity: k2 }, m2);
              });
            }
            d2 && f2 && c2.points && c2.setAllPointsToState(b2 || void 0);
          }
          setAllPointsToState(b2) {
            this.points.forEach(function(d2) {
              d2.setState && d2.setState(b2);
            });
          }
          setVisible(b2, d2) {
            const c2 = this, a3 = c2.chart, e2 = a3.options.chart.ignoreHiddenSeries, f2 = c2.visible, g2 = (c2.visible = b2 = c2.options.visible = c2.userOptions.visible = "undefined" === typeof b2 ? !f2 : b2) ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function(b3) {
              if (c2[b3])
                c2[b3][g2]();
            });
            if (a3.hoverSeries === c2 || (a3.hoverPoint && a3.hoverPoint.series) === c2)
              c2.onMouseOut();
            c2.legendItem && a3.legend.colorizeItem(c2, b2);
            c2.isDirty = true;
            c2.options.stacking && a3.series.forEach(function(b3) {
              b3.options.stacking && b3.visible && (b3.isDirty = true);
            });
            c2.linkedSeries.forEach(function(d3) {
              d3.setVisible(b2, false);
            });
            e2 && (a3.isDirtyBox = true);
            w(c2, g2);
            false !== d2 && a3.redraw();
          }
          show() {
            this.setVisible(true);
          }
          hide() {
            this.setVisible(false);
          }
          select(b2) {
            this.selected = b2 = this.options.selected = "undefined" === typeof b2 ? !this.selected : b2;
            this.checkbox && (this.checkbox.checked = b2);
            w(this, b2 ? "select" : "unselect");
          }
          shouldShowTooltip(b2, d2, c2 = {}) {
            c2.series = this;
            c2.visiblePlotOnly = true;
            return this.chart.isInsidePlot(b2, d2, c2);
          }
          drawLegendSymbol(b2, d2) {
            var c2;
            null === (c2 = y[this.options.legendSymbol || "rectangle"]) || void 0 === c2 ? void 0 : c2.call(this, b2, d2);
          }
        }
        T.defaultOptions = F;
        T.types = D.seriesTypes;
        T.registerType = D.registerSeriesType;
        d(T.prototype, {
          axisTypes: ["xAxis", "yAxis"],
          coll: "series",
          colorCounter: 0,
          cropShoulder: 1,
          directTouch: false,
          isCartesian: true,
          kdAxisArray: ["clientX", "plotY"],
          parallelArrays: ["x", "y"],
          pointClass: A,
          requireSorting: true,
          sorted: true
        });
        D.series = T;
        "";
        "";
        return T;
      });
      K(a, "Core/Chart/Chart.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Time.js"],
        a["Core/Utilities.js"],
        a["Core/Renderer/HTML/AST.js"]
      ], function(a2, x, G, I, y, A, F, D, t, q, k, p, n) {
        const { animate: h, animObject: f, setAnimation: c } = a2, { defaultOptions: g, defaultTime: B } = G, { numberFormat: C } = I, { registerEventOptions: E } = y, { charts: e, doc: l, marginNames: v, svg: z, win: u } = A, { seriesTypes: b } = t, {
          addEvent: d,
          attr: m,
          createElement: w,
          css: r,
          defined: H,
          diffObjects: N,
          discardElement: ea,
          erase: P,
          error: Y,
          extend: R,
          find: W,
          fireEvent: J,
          getStyle: K2,
          isArray: fa,
          isNumber: V,
          isObject: T,
          isString: L,
          merge: Q,
          objectEach: S,
          pick: O,
          pInt: U,
          relativeLength: Z,
          removeEvent: ia,
          splat: aa,
          syncTimeout: ca,
          uniqueKey: ba
        } = p;
        class da {
          static chart(b2, d2, c2) {
            return new da(b2, d2, c2);
          }
          constructor(b2, d2, c2) {
            this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
            this.sharedClips = {};
            this.zooming = this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
            this.getArgs(b2, d2, c2);
          }
          getArgs(b2, d2, c2) {
            L(b2) || b2.nodeName ? (this.renderTo = b2, this.init(d2, c2)) : this.init(b2, d2);
          }
          setZoomOptions() {
            const b2 = this.options.chart, d2 = b2.zooming;
            this.zooming = Object.assign(Object.assign({}, d2), { type: O(b2.zoomType, d2.type), key: O(b2.zoomKey, d2.key), pinchType: O(b2.pinchType, d2.pinchType), singleTouch: O(b2.zoomBySingleTouch, d2.singleTouch, false), resetButton: Q(
              d2.resetButton,
              b2.resetZoomButton
            ) });
          }
          init(b2, d2) {
            J(this, "init", { args: arguments }, function() {
              const c2 = Q(g, b2), a3 = c2.chart;
              this.userOptions = R({}, b2);
              this.margin = [];
              this.spacing = [];
              this.bounds = { h: {}, v: {} };
              this.labelCollectors = [];
              this.callback = d2;
              this.isResizing = 0;
              this.options = c2;
              this.axes = [];
              this.series = [];
              this.time = b2.time && Object.keys(b2.time).length ? new k(b2.time) : A.time;
              this.numberFormatter = a3.numberFormatter || C;
              this.styledMode = a3.styledMode;
              this.hasCartesianSeries = a3.showAxes;
              this.index = e.length;
              e.push(this);
              A.chartCount++;
              E(
                this,
                a3
              );
              this.xAxis = [];
              this.yAxis = [];
              this.pointCount = this.colorCounter = this.symbolCounter = 0;
              this.setZoomOptions();
              J(this, "afterInit");
              this.firstRender();
            });
          }
          initSeries(d2) {
            var c2 = this.options.chart;
            c2 = d2.type || c2.type;
            const a3 = b[c2];
            a3 || Y(17, true, this, { missingModuleFor: c2 });
            c2 = new a3();
            "function" === typeof c2.init && c2.init(this, d2);
            return c2;
          }
          setSeriesData() {
            this.getSeriesOrderByLinks().forEach(function(b2) {
              b2.points || b2.data || !b2.enabledDataSorting || b2.setData(b2.options.data, false);
            });
          }
          getSeriesOrderByLinks() {
            return this.series.concat().sort(function(b2, d2) {
              return b2.linkedSeries.length || d2.linkedSeries.length ? d2.linkedSeries.length - b2.linkedSeries.length : 0;
            });
          }
          orderItems(b2, d2 = 0) {
            const c2 = this[b2], a3 = this.options[b2] = aa(this.options[b2]).slice();
            b2 = this.userOptions[b2] = this.userOptions[b2] ? aa(this.userOptions[b2]).slice() : [];
            this.hasRendered && (a3.splice(d2), b2.splice(d2));
            if (c2) {
              for (let e2 = d2, f2 = c2.length; e2 < f2; ++e2)
                if (d2 = c2[e2])
                  d2.index = e2, d2 instanceof D && (d2.name = d2.getName()), d2.options.isInternal || (a3[e2] = d2.options, b2[e2] = d2.userOptions);
            }
          }
          isInsidePlot(b2, d2, c2 = {}) {
            const {
              inverted: a3,
              plotBox: e2,
              plotLeft: f2,
              plotTop: g2,
              scrollablePlotBox: m2
            } = this;
            var l2 = 0;
            let h2 = 0;
            c2.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: l2, scrollTop: h2 } = this.scrollingContainer);
            const k2 = c2.series, n2 = c2.visiblePlotOnly && m2 || e2;
            var u2 = c2.inverted ? d2 : b2;
            d2 = c2.inverted ? b2 : d2;
            b2 = { x: u2, y: d2, isInsidePlot: true, options: c2 };
            if (!c2.ignoreX) {
              const d3 = k2 && (a3 && !this.polar ? k2.yAxis : k2.xAxis) || { pos: f2, len: Infinity };
              u2 = c2.paneCoordinates ? d3.pos + u2 : f2 + u2;
              u2 >= Math.max(l2 + f2, d3.pos) && u2 <= Math.min(l2 + f2 + n2.width, d3.pos + d3.len) || (b2.isInsidePlot = false);
            }
            !c2.ignoreY && b2.isInsidePlot && (l2 = !a3 && c2.axis && !c2.axis.isXAxis && c2.axis || k2 && (a3 ? k2.xAxis : k2.yAxis) || { pos: g2, len: Infinity }, c2 = c2.paneCoordinates ? l2.pos + d2 : g2 + d2, c2 >= Math.max(h2 + g2, l2.pos) && c2 <= Math.min(h2 + g2 + n2.height, l2.pos + l2.len) || (b2.isInsidePlot = false));
            J(this, "afterIsInsidePlot", b2);
            return b2.isInsidePlot;
          }
          redraw(b2) {
            J(this, "beforeRedraw");
            const d2 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], a3 = this.series, e2 = this.pointer, f2 = this.legend, g2 = this.userOptions.legend, m2 = this.renderer, l2 = m2.isHidden(), h2 = [];
            let k2, n2, u2 = this.isDirtyBox, v2 = this.isDirtyLegend, w2;
            m2.rootFontSize = m2.boxWrapper.getStyle("font-size");
            this.setResponsive && this.setResponsive(false);
            c(this.hasRendered ? b2 : false, this);
            l2 && this.temporaryDisplay();
            this.layOutTitles(false);
            for (b2 = a3.length; b2--; )
              if (w2 = a3[b2], w2.options.stacking || w2.options.centerInCategory) {
                if (n2 = true, w2.isDirty) {
                  k2 = true;
                  break;
                }
              }
            if (k2)
              for (b2 = a3.length; b2--; )
                w2 = a3[b2], w2.options.stacking && (w2.isDirty = true);
            a3.forEach(function(b3) {
              b3.isDirty && ("point" === b3.options.legendType ? ("function" === typeof b3.updateTotals && b3.updateTotals(), v2 = true) : g2 && (g2.labelFormatter || g2.labelFormat) && (v2 = true));
              b3.isDirtyData && J(b3, "updatedData");
            });
            v2 && f2 && f2.options.enabled && (f2.render(), this.isDirtyLegend = false);
            n2 && this.getStacks();
            d2.forEach(function(b3) {
              b3.updateNames();
              b3.setScale();
            });
            this.getMargins();
            d2.forEach(function(b3) {
              b3.isDirty && (u2 = true);
            });
            d2.forEach(function(b3) {
              const d3 = b3.min + "," + b3.max;
              b3.extKey !== d3 && (b3.extKey = d3, h2.push(function() {
                J(b3, "afterSetExtremes", R(b3.eventArgs, b3.getExtremes()));
                delete b3.eventArgs;
              }));
              (u2 || n2) && b3.redraw();
            });
            u2 && this.drawChartBox();
            J(this, "predraw");
            a3.forEach(function(b3) {
              (u2 || b3.isDirty) && b3.visible && b3.redraw();
              b3.isDirtyData = false;
            });
            e2 && e2.reset(true);
            m2.draw();
            J(this, "redraw");
            J(this, "render");
            l2 && this.temporaryDisplay(true);
            h2.forEach(function(b3) {
              b3.call();
            });
          }
          get(b2) {
            function d2(d3) {
              return d3.id === b2 || d3.options && d3.options.id === b2;
            }
            const c2 = this.series;
            let a3 = W(this.axes, d2) || W(this.series, d2);
            for (let b3 = 0; !a3 && b3 < c2.length; b3++)
              a3 = W(c2[b3].points || [], d2);
            return a3;
          }
          getAxes() {
            const b2 = this.options;
            J(this, "getAxes");
            for (const d2 of ["xAxis", "yAxis"]) {
              const c2 = b2[d2] = aa(b2[d2] || {});
              for (const b3 of c2)
                new x(this, b3, d2);
            }
            J(this, "afterGetAxes");
          }
          getSelectedPoints() {
            return this.series.reduce((b2, d2) => {
              d2.getPointsCollection().forEach((d3) => {
                O(d3.selectedStaging, d3.selected) && b2.push(d3);
              });
              return b2;
            }, []);
          }
          getSelectedSeries() {
            return this.series.filter(function(b2) {
              return b2.selected;
            });
          }
          setTitle(b2, d2, c2) {
            this.applyDescription("title", b2);
            this.applyDescription("subtitle", d2);
            this.applyDescription("caption", void 0);
            this.layOutTitles(c2);
          }
          applyDescription(b2, d2) {
            const c2 = this, a3 = this.options[b2] = Q(this.options[b2], d2);
            let e2 = this[b2];
            e2 && d2 && (this[b2] = e2 = e2.destroy());
            a3 && !e2 && (e2 = this.renderer.text(a3.text, 0, 0, a3.useHTML).attr({
              align: a3.align,
              "class": "highcharts-" + b2,
              zIndex: a3.zIndex || 4
            }).add(), e2.update = function(d3, a4) {
              c2.applyDescription(b2, d3);
              c2.layOutTitles(a4);
            }, this.styledMode || e2.css(R("title" === b2 ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, a3.style)), this[b2] = e2);
          }
          layOutTitles(b2 = true) {
            const d2 = [0, 0, 0], c2 = this.renderer, a3 = this.spacingBox;
            ["title", "subtitle", "caption"].forEach(function(b3) {
              const e3 = this[b3], f2 = this.options[b3], g2 = f2.verticalAlign || "top";
              b3 = "title" === b3 ? "top" === g2 ? -3 : 0 : "top" === g2 ? d2[0] + 2 : 0;
              if (e3) {
                e3.css({ width: (f2.width || a3.width + (f2.widthAdjust || 0)) + "px" });
                const m2 = c2.fontMetrics(e3).b, l2 = Math.round(e3.getBBox(f2.useHTML).height);
                e3.align(R({ y: "bottom" === g2 ? m2 : b3 + m2, height: l2 }, f2), false, "spacingBox");
                f2.floating || ("top" === g2 ? d2[0] = Math.ceil(d2[0] + l2) : "bottom" === g2 && (d2[2] = Math.ceil(d2[2] + l2)));
              }
            }, this);
            d2[0] && "top" === (this.options.title.verticalAlign || "top") && (d2[0] += this.options.title.margin);
            d2[2] && "bottom" === this.options.caption.verticalAlign && (d2[2] += this.options.caption.margin);
            const e2 = !this.titleOffset || this.titleOffset.join(",") !== d2.join(",");
            this.titleOffset = d2;
            J(this, "afterLayOutTitles");
            !this.isDirtyBox && e2 && (this.isDirtyBox = this.isDirtyLegend = e2, this.hasRendered && b2 && this.isDirtyBox && this.redraw());
          }
          getContainerBox() {
            return { width: K2(this.renderTo, "width", true) || 0, height: K2(this.renderTo, "height", true) || 0 };
          }
          getChartSize() {
            var b2 = this.options.chart;
            const d2 = b2.width;
            b2 = b2.height;
            const c2 = this.getContainerBox();
            this.chartWidth = Math.max(0, d2 || c2.width || 600);
            this.chartHeight = Math.max(0, Z(b2, this.chartWidth) || (1 < c2.height ? c2.height : 400));
            this.containerBox = c2;
          }
          temporaryDisplay(b2) {
            let d2 = this.renderTo;
            if (b2)
              for (; d2 && d2.style; )
                d2.hcOrigStyle && (r(d2, d2.hcOrigStyle), delete d2.hcOrigStyle), d2.hcOrigDetached && (l.body.removeChild(d2), d2.hcOrigDetached = false), d2 = d2.parentNode;
            else
              for (; d2 && d2.style; ) {
                l.body.contains(d2) || d2.parentNode || (d2.hcOrigDetached = true, l.body.appendChild(d2));
                if ("none" === K2(d2, "display", false) || d2.hcOricDetached)
                  d2.hcOrigStyle = { display: d2.style.display, height: d2.style.height, overflow: d2.style.overflow }, b2 = { display: "block", overflow: "hidden" }, d2 !== this.renderTo && (b2.height = 0), r(d2, b2), d2.offsetWidth || d2.style.setProperty(
                    "display",
                    "block",
                    "important"
                  );
                d2 = d2.parentNode;
                if (d2 === l.body)
                  break;
              }
          }
          setClassName(b2) {
            this.container.className = "highcharts-container " + (b2 || "");
          }
          getContainer() {
            const b2 = this.options, d2 = b2.chart;
            var a3 = ba();
            let f2, g2 = this.renderTo;
            g2 || (this.renderTo = g2 = d2.renderTo);
            L(g2) && (this.renderTo = g2 = l.getElementById(g2));
            g2 || Y(13, true, this);
            var h2 = U(m(g2, "data-highcharts-chart"));
            V(h2) && e[h2] && e[h2].hasRendered && e[h2].destroy();
            m(g2, "data-highcharts-chart", this.index);
            g2.innerHTML = n.emptyHTML;
            d2.skipClone || g2.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            h2 = this.chartWidth;
            const k2 = this.chartHeight;
            r(g2, { overflow: "hidden" });
            this.styledMode || (f2 = R({ position: "relative", overflow: "hidden", width: h2 + "px", height: k2 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, d2.style || {}));
            this.container = a3 = w("div", { id: a3 }, f2, g2);
            this._cursor = a3.style.cursor;
            this.renderer = new (d2.renderer || !z ? F.getRendererType(d2.renderer) : q)(
              a3,
              h2,
              k2,
              void 0,
              d2.forExport,
              b2.exporting && b2.exporting.allowHTML,
              this.styledMode
            );
            this.containerBox = this.getContainerBox();
            c(void 0, this);
            this.setClassName(d2.className);
            if (this.styledMode)
              for (const d3 in b2.defs)
                this.renderer.definition(b2.defs[d3]);
            else
              this.renderer.setStyle(d2.style);
            this.renderer.chartIndex = this.index;
            J(this, "afterGetContainer");
          }
          getMargins(b2) {
            const { spacing: d2, margin: c2, titleOffset: a3 } = this;
            this.resetMargins();
            a3[0] && !H(c2[0]) && (this.plotTop = Math.max(this.plotTop, a3[0] + d2[0]));
            a3[2] && !H(c2[2]) && (this.marginBottom = Math.max(
              this.marginBottom,
              a3[2] + d2[2]
            ));
            this.legend && this.legend.display && this.legend.adjustMargins(c2, d2);
            J(this, "getMargins");
            b2 || this.getAxisMargins();
          }
          getAxisMargins() {
            const b2 = this, d2 = b2.axisOffset = [0, 0, 0, 0], c2 = b2.colorAxis, a3 = b2.margin, e2 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.getOffset();
              });
            };
            b2.hasCartesianSeries ? e2(b2.axes) : c2 && c2.length && e2(c2);
            v.forEach(function(c3, e3) {
              H(a3[e3]) || (b2[c3] += d2[e3]);
            });
            b2.setChartSize();
          }
          getOptions() {
            return N(this.userOptions, g);
          }
          reflow(b2) {
            const d2 = this;
            var c2 = d2.options.chart;
            c2 = H(c2.width) && H(c2.height);
            const a3 = d2.containerBox, e2 = d2.getContainerBox();
            delete d2.pointer.chartPosition;
            if (!c2 && !d2.isPrinting && a3 && e2.width) {
              if (e2.width !== a3.width || e2.height !== a3.height)
                p.clearTimeout(d2.reflowTimeout), d2.reflowTimeout = ca(function() {
                  d2.container && d2.setSize(void 0, void 0, false);
                }, b2 ? 100 : 0);
              d2.containerBox = e2;
            }
          }
          setReflow() {
            const b2 = this;
            var c2 = (d2) => {
              var c3;
              (null === (c3 = b2.options) || void 0 === c3 ? 0 : c3.chart.reflow) && b2.hasLoaded && b2.reflow(d2);
            };
            "function" === typeof ResizeObserver ? new ResizeObserver(c2).observe(b2.renderTo) : (c2 = d(u, "resize", c2), d(
              this,
              "destroy",
              c2
            ));
          }
          setSize(b2, d2, a3) {
            const e2 = this, g2 = e2.renderer;
            e2.isResizing += 1;
            c(a3, e2);
            a3 = g2.globalAnimation;
            e2.oldChartHeight = e2.chartHeight;
            e2.oldChartWidth = e2.chartWidth;
            "undefined" !== typeof b2 && (e2.options.chart.width = b2);
            "undefined" !== typeof d2 && (e2.options.chart.height = d2);
            e2.getChartSize();
            e2.styledMode || (a3 ? h : r)(e2.container, { width: e2.chartWidth + "px", height: e2.chartHeight + "px" }, a3);
            e2.setChartSize(true);
            g2.setSize(e2.chartWidth, e2.chartHeight, a3);
            e2.axes.forEach(function(b3) {
              b3.isDirty = true;
              b3.setScale();
            });
            e2.isDirtyLegend = true;
            e2.isDirtyBox = true;
            e2.layOutTitles();
            e2.getMargins();
            e2.redraw(a3);
            e2.oldChartHeight = null;
            J(e2, "resize");
            ca(function() {
              e2 && J(e2, "endResize", null, function() {
                --e2.isResizing;
              });
            }, f(a3).duration);
          }
          setChartSize(b2) {
            var d2 = this.inverted;
            const c2 = this.renderer;
            var a3 = this.chartWidth, e2 = this.chartHeight;
            const f2 = this.options.chart, g2 = this.spacing, m2 = this.clipOffset;
            let l2, h2, k2, n2;
            this.plotLeft = l2 = Math.round(this.plotLeft);
            this.plotTop = h2 = Math.round(this.plotTop);
            this.plotWidth = k2 = Math.max(0, Math.round(a3 - l2 - this.marginRight));
            this.plotHeight = n2 = Math.max(
              0,
              Math.round(e2 - h2 - this.marginBottom)
            );
            this.plotSizeX = d2 ? n2 : k2;
            this.plotSizeY = d2 ? k2 : n2;
            this.plotBorderWidth = f2.plotBorderWidth || 0;
            this.spacingBox = c2.spacingBox = { x: g2[3], y: g2[0], width: a3 - g2[3] - g2[1], height: e2 - g2[0] - g2[2] };
            this.plotBox = c2.plotBox = { x: l2, y: h2, width: k2, height: n2 };
            d2 = 2 * Math.floor(this.plotBorderWidth / 2);
            a3 = Math.ceil(Math.max(d2, m2[3]) / 2);
            e2 = Math.ceil(Math.max(d2, m2[0]) / 2);
            this.clipBox = { x: a3, y: e2, width: Math.floor(this.plotSizeX - Math.max(d2, m2[1]) / 2 - a3), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d2, m2[2]) / 2 - e2)) };
            b2 || (this.axes.forEach(function(b3) {
              b3.setAxisSize();
              b3.setAxisTranslation();
            }), c2.alignElements());
            J(this, "afterSetChartSize", { skipAxes: b2 });
          }
          resetMargins() {
            J(this, "resetMargins");
            const b2 = this, d2 = b2.options.chart;
            ["margin", "spacing"].forEach(function(c2) {
              const a3 = d2[c2], e2 = T(a3) ? a3 : [a3, a3, a3, a3];
              ["Top", "Right", "Bottom", "Left"].forEach(function(a4, f2) {
                b2[c2][f2] = O(d2[c2 + a4], e2[f2]);
              });
            });
            v.forEach(function(d3, c2) {
              b2[d3] = O(b2.margin[c2], b2.spacing[c2]);
            });
            b2.axisOffset = [0, 0, 0, 0];
            b2.clipOffset = [0, 0, 0, 0];
          }
          drawChartBox() {
            const b2 = this.options.chart, d2 = this.renderer, c2 = this.chartWidth, a3 = this.chartHeight, e2 = this.styledMode, f2 = this.plotBGImage;
            var g2 = b2.backgroundColor;
            const m2 = b2.plotBackgroundColor, l2 = b2.plotBackgroundImage, h2 = this.plotLeft, k2 = this.plotTop, n2 = this.plotWidth, u2 = this.plotHeight, v2 = this.plotBox, w2 = this.clipRect, p2 = this.clipBox;
            let z2 = this.chartBackground, q2 = this.plotBackground, B2 = this.plotBorder, C2, E2, r2 = "animate";
            z2 || (this.chartBackground = z2 = d2.rect().addClass("highcharts-background").add(), r2 = "attr");
            if (e2)
              C2 = E2 = z2.strokeWidth();
            else {
              C2 = b2.borderWidth || 0;
              E2 = C2 + (b2.shadow ? 8 : 0);
              g2 = { fill: g2 || "none" };
              if (C2 || z2["stroke-width"])
                g2.stroke = b2.borderColor, g2["stroke-width"] = C2;
              z2.attr(g2).shadow(b2.shadow);
            }
            z2[r2]({ x: E2 / 2, y: E2 / 2, width: c2 - E2 - C2 % 2, height: a3 - E2 - C2 % 2, r: b2.borderRadius });
            r2 = "animate";
            q2 || (r2 = "attr", this.plotBackground = q2 = d2.rect().addClass("highcharts-plot-background").add());
            q2[r2](v2);
            e2 || (q2.attr({ fill: m2 || "none" }).shadow(b2.plotShadow), l2 && (f2 ? (l2 !== f2.attr("href") && f2.attr("href", l2), f2.animate(v2)) : this.plotBGImage = d2.image(l2, h2, k2, n2, u2).add()));
            w2 ? w2.animate({ width: p2.width, height: p2.height }) : this.clipRect = d2.clipRect(p2);
            r2 = "animate";
            B2 || (r2 = "attr", this.plotBorder = B2 = d2.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
            e2 || B2.attr({ stroke: b2.plotBorderColor, "stroke-width": b2.plotBorderWidth || 0, fill: "none" });
            B2[r2](B2.crisp({ x: h2, y: k2, width: n2, height: u2 }, -B2.strokeWidth()));
            this.isDirtyBox = false;
            J(this, "afterDrawChartBox");
          }
          propFromSeries() {
            const d2 = this, c2 = d2.options.chart, a3 = d2.options.series;
            let e2, f2, g2;
            ["inverted", "angular", "polar"].forEach(function(m2) {
              f2 = b[c2.type];
              g2 = c2[m2] || f2 && f2.prototype[m2];
              for (e2 = a3 && a3.length; !g2 && e2--; )
                (f2 = b[a3[e2].type]) && f2.prototype[m2] && (g2 = true);
              d2[m2] = g2;
            });
          }
          linkSeries(b2) {
            const d2 = this, c2 = d2.series;
            c2.forEach(function(b3) {
              b3.linkedSeries.length = 0;
            });
            c2.forEach(function(b3) {
              let c3 = b3.options.linkedTo;
              L(c3) && (c3 = ":previous" === c3 ? d2.series[b3.index - 1] : d2.get(c3)) && c3.linkedParent !== b3 && (c3.linkedSeries.push(b3), b3.linkedParent = c3, c3.enabledDataSorting && b3.setDataSortingOptions(), b3.visible = O(b3.options.visible, c3.options.visible, b3.visible));
            });
            J(this, "afterLinkSeries", { isUpdating: b2 });
          }
          renderSeries() {
            this.series.forEach(function(b2) {
              b2.translate();
              b2.render();
            });
          }
          render() {
            const b2 = this.axes, d2 = this.colorAxis, c2 = this.renderer, a3 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.render();
              });
            };
            let e2 = 0;
            this.setTitle();
            J(this, "beforeMargins");
            this.getStacks && this.getStacks();
            this.getMargins(true);
            this.setChartSize();
            const f2 = this.plotWidth;
            b2.some(function(b3) {
              if (b3.horiz && b3.visible && b3.options.labels.enabled && b3.series.length)
                return e2 = 21, true;
            });
            const g2 = this.plotHeight = Math.max(this.plotHeight - e2, 0);
            b2.forEach(function(b3) {
              b3.setScale();
            });
            this.getAxisMargins();
            const m2 = 1.1 < f2 / this.plotWidth, l2 = 1.05 < g2 / this.plotHeight;
            if (m2 || l2)
              b2.forEach(function(b3) {
                (b3.horiz && m2 || !b3.horiz && l2) && b3.setTickInterval(true);
              }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries ? a3(b2) : d2 && d2.length && a3(d2);
            this.seriesGroup || (this.seriesGroup = c2.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add());
            this.renderSeries();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.hasRendered = true;
          }
          addCredits(b2) {
            const d2 = this, c2 = Q(true, this.options.credits, b2);
            c2.enabled && !this.credits && (this.credits = this.renderer.text(c2.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              c2.href && (u.location.href = c2.href);
            }).attr({ align: c2.position.align, zIndex: 8 }), d2.styledMode || this.credits.css(c2.style), this.credits.add().align(c2.position), this.credits.update = function(b3) {
              d2.credits = d2.credits.destroy();
              d2.addCredits(b3);
            });
          }
          destroy() {
            const b2 = this, d2 = b2.axes, c2 = b2.series, a3 = b2.container, f2 = a3 && a3.parentNode;
            let g2;
            J(b2, "destroy");
            b2.renderer.forExport ? P(e, b2) : e[b2.index] = void 0;
            A.chartCount--;
            b2.renderTo.removeAttribute("data-highcharts-chart");
            ia(b2);
            for (g2 = d2.length; g2--; )
              d2[g2] = d2[g2].destroy();
            this.scroller && this.scroller.destroy && this.scroller.destroy();
            for (g2 = c2.length; g2--; )
              c2[g2] = c2[g2].destroy();
            "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(d3) {
              const c3 = b2[d3];
              c3 && c3.destroy && (b2[d3] = c3.destroy());
            });
            a3 && (a3.innerHTML = n.emptyHTML, ia(a3), f2 && ea(a3));
            S(b2, function(d3, c3) {
              delete b2[c3];
            });
          }
          firstRender() {
            const b2 = this, d2 = b2.options;
            b2.getContainer();
            b2.resetMargins();
            b2.setChartSize();
            b2.propFromSeries();
            b2.getAxes();
            const c2 = fa(d2.series) ? d2.series : [];
            d2.series = [];
            c2.forEach(function(d3) {
              b2.initSeries(d3);
            });
            b2.linkSeries();
            b2.setSeriesData();
            J(b2, "beforeRender");
            b2.render();
            b2.pointer.getChartPosition();
            if (!b2.renderer.imgCount && !b2.hasLoaded)
              b2.onload();
            b2.temporaryDisplay(true);
          }
          onload() {
            this.callbacks.concat([this.callback]).forEach(function(b2) {
              b2 && "undefined" !== typeof this.index && b2.apply(this, [this]);
            }, this);
            J(this, "load");
            J(this, "render");
            H(this.index) && this.setReflow();
            this.warnIfA11yModuleNotLoaded();
            this.hasLoaded = true;
          }
          warnIfA11yModuleNotLoaded() {
            const { options: b2, title: d2 } = this;
            b2 && !this.accessibility && (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (d2 && d2.element.textContent || "").replace(/</g, "&lt;") }), b2.accessibility && false === b2.accessibility.enabled || Y(
              'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
              false,
              this
            ));
          }
          addSeries(b2, d2, c2) {
            const a3 = this;
            let e2;
            b2 && (d2 = O(d2, true), J(a3, "addSeries", { options: b2 }, function() {
              e2 = a3.initSeries(b2);
              a3.isDirtyLegend = true;
              a3.linkSeries();
              e2.enabledDataSorting && e2.setData(b2.data, false);
              J(a3, "afterAddSeries", { series: e2 });
              d2 && a3.redraw(c2);
            }));
            return e2;
          }
          addAxis(b2, d2, c2, a3) {
            return this.createAxis(d2 ? "xAxis" : "yAxis", { axis: b2, redraw: c2, animation: a3 });
          }
          addColorAxis(b2, d2, c2) {
            return this.createAxis("colorAxis", { axis: b2, redraw: d2, animation: c2 });
          }
          createAxis(b2, d2) {
            b2 = new x(this, d2.axis, b2);
            O(d2.redraw, true) && this.redraw(d2.animation);
            return b2;
          }
          showLoading(b2) {
            const c2 = this, a3 = c2.options, e2 = a3.loading, f2 = function() {
              g2 && r(g2, { left: c2.plotLeft + "px", top: c2.plotTop + "px", width: c2.plotWidth + "px", height: c2.plotHeight + "px" });
            };
            let g2 = c2.loadingDiv, m2 = c2.loadingSpan;
            g2 || (c2.loadingDiv = g2 = w("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, c2.container));
            m2 || (c2.loadingSpan = m2 = w("span", { className: "highcharts-loading-inner" }, null, g2), d(c2, "redraw", f2));
            g2.className = "highcharts-loading";
            n.setElementHTML(m2, O(b2, a3.lang.loading, ""));
            c2.styledMode || (r(
              g2,
              R(e2.style, { zIndex: 10 })
            ), r(m2, e2.labelStyle), c2.loadingShown || (r(g2, { opacity: 0, display: "" }), h(g2, { opacity: e2.style.opacity || 0.5 }, { duration: e2.showDuration || 0 })));
            c2.loadingShown = true;
            f2();
          }
          hideLoading() {
            const b2 = this.options, d2 = this.loadingDiv;
            d2 && (d2.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || h(d2, { opacity: 0 }, { duration: b2.loading.hideDuration || 100, complete: function() {
              r(d2, { display: "none" });
            } }));
            this.loadingShown = false;
          }
          update(b2, d2, c2, a3) {
            const e2 = this, f2 = {
              credits: "addCredits",
              title: "setTitle",
              subtitle: "setSubtitle",
              caption: "setCaption"
            }, g2 = b2.isResponsiveOptions, m2 = [];
            let l2, h2;
            J(e2, "update", { options: b2 });
            g2 || e2.setResponsive(false, true);
            b2 = N(b2, e2.options);
            e2.userOptions = Q(e2.userOptions, b2);
            var n2 = b2.chart;
            if (n2) {
              Q(true, e2.options.chart, n2);
              this.setZoomOptions();
              "className" in n2 && e2.setClassName(n2.className);
              if ("inverted" in n2 || "polar" in n2 || "type" in n2) {
                e2.propFromSeries();
                var u2 = true;
              }
              "alignTicks" in n2 && (u2 = true);
              "events" in n2 && E(this, n2);
              S(n2, function(b3, d3) {
                -1 !== e2.propsRequireUpdateSeries.indexOf("chart." + d3) && (l2 = true);
                -1 !== e2.propsRequireDirtyBox.indexOf(d3) && (e2.isDirtyBox = true);
                -1 !== e2.propsRequireReflow.indexOf(d3) && (g2 ? e2.isDirtyBox = true : h2 = true);
              });
              !e2.styledMode && n2.style && e2.renderer.setStyle(e2.options.chart.style || {});
            }
            !e2.styledMode && b2.colors && (this.options.colors = b2.colors);
            b2.time && (this.time === B && (this.time = new k(b2.time)), Q(true, e2.options.time, b2.time));
            S(b2, function(d3, c3) {
              if (e2[c3] && "function" === typeof e2[c3].update)
                e2[c3].update(d3, false);
              else if ("function" === typeof e2[f2[c3]])
                e2[f2[c3]](d3);
              else
                "colors" !== c3 && -1 === e2.collectionsWithUpdate.indexOf(c3) && Q(true, e2.options[c3], b2[c3]);
              "chart" !== c3 && -1 !== e2.propsRequireUpdateSeries.indexOf(c3) && (l2 = true);
            });
            this.collectionsWithUpdate.forEach(function(d3) {
              b2[d3] && (aa(b2[d3]).forEach(function(b3, a4) {
                const f3 = H(b3.id);
                let g3;
                f3 && (g3 = e2.get(b3.id));
                !g3 && e2[d3] && (g3 = e2[d3][O(b3.index, a4)]) && (f3 && H(g3.options.id) || g3.options.isInternal) && (g3 = void 0);
                g3 && g3.coll === d3 && (g3.update(b3, false), c2 && (g3.touched = true));
                !g3 && c2 && e2.collectionsWithInit[d3] && (e2.collectionsWithInit[d3][0].apply(e2, [b3].concat(e2.collectionsWithInit[d3][1] || []).concat([false])).touched = true);
              }), c2 && e2[d3].forEach(function(b3) {
                b3.touched || b3.options.isInternal ? delete b3.touched : m2.push(b3);
              }));
            });
            m2.forEach(function(b3) {
              b3.chart && b3.remove && b3.remove(false);
            });
            u2 && e2.axes.forEach(function(b3) {
              b3.update({}, false);
            });
            l2 && e2.getSeriesOrderByLinks().forEach(function(b3) {
              b3.chart && b3.update({}, false);
            }, this);
            u2 = n2 && n2.width;
            n2 = n2 && (L(n2.height) ? Z(n2.height, u2 || e2.chartWidth) : n2.height);
            h2 || V(u2) && u2 !== e2.chartWidth || V(n2) && n2 !== e2.chartHeight ? e2.setSize(u2, n2, a3) : O(d2, true) && e2.redraw(a3);
            J(e2, "afterUpdate", { options: b2, redraw: d2, animation: a3 });
          }
          setSubtitle(b2, d2) {
            this.applyDescription("subtitle", b2);
            this.layOutTitles(d2);
          }
          setCaption(b2, d2) {
            this.applyDescription("caption", b2);
            this.layOutTitles(d2);
          }
          showResetZoom() {
            function b2() {
              d2.zoomOut();
            }
            const d2 = this, c2 = g.lang, a3 = d2.zooming.resetButton, e2 = a3.theme, f2 = "chart" === a3.relativeTo || "spacingBox" === a3.relativeTo ? null : "scrollablePlotBox";
            J(this, "beforeShowResetZoom", null, function() {
              d2.resetZoomButton = d2.renderer.button(c2.resetZoom, null, null, b2, e2).attr({ align: a3.position.align, title: c2.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(a3.position, false, f2);
            });
            J(
              this,
              "afterShowResetZoom"
            );
          }
          zoomOut() {
            J(this, "selection", { resetSelection: true }, this.zoom);
          }
          zoom(b2) {
            const d2 = this, c2 = d2.pointer;
            let a3 = false, e2;
            !b2 || b2.resetSelection ? (d2.axes.forEach(function(b3) {
              e2 = b3.zoom();
            }), c2.initiated = false) : b2.xAxis.concat(b2.yAxis).forEach(function(b3) {
              const f3 = b3.axis;
              if (c2[f3.isXAxis ? "zoomX" : "zoomY"] && H(c2.mouseDownX) && H(c2.mouseDownY) && d2.isInsidePlot(c2.mouseDownX - d2.plotLeft, c2.mouseDownY - d2.plotTop, { axis: f3 }) || !H(d2.inverted ? c2.mouseDownX : c2.mouseDownY))
                e2 = f3.zoom(b3.min, b3.max), f3.displayBtn && (a3 = true);
            });
            const f2 = d2.resetZoomButton;
            a3 && !f2 ? d2.showResetZoom() : !a3 && T(f2) && (d2.resetZoomButton = f2.destroy());
            e2 && d2.redraw(O(d2.options.chart.animation, b2 && b2.animation, 100 > d2.pointCount));
          }
          pan(b2, d2) {
            const c2 = this, a3 = c2.hoverPoints;
            d2 = "object" === typeof d2 ? d2 : { enabled: d2, type: "x" };
            const e2 = c2.options.chart;
            e2 && e2.panning && (e2.panning = d2);
            const f2 = d2.type;
            let g2;
            J(this, "pan", { originalEvent: b2 }, function() {
              a3 && a3.forEach(function(b3) {
                b3.setState();
              });
              let d3 = c2.xAxis;
              "xy" === f2 ? d3 = d3.concat(c2.yAxis) : "y" === f2 && (d3 = c2.yAxis);
              const e3 = {};
              d3.forEach(function(d4) {
                if (d4.options.panningEnabled && !d4.options.isInternal) {
                  var a4 = d4.horiz, m2 = b2[a4 ? "chartX" : "chartY"];
                  a4 = a4 ? "mouseDownX" : "mouseDownY";
                  var l2 = c2[a4], h2 = d4.minPointOffset || 0, k2 = d4.reversed && !c2.inverted || !d4.reversed && c2.inverted ? -1 : 1, n2 = d4.getExtremes(), u2 = d4.toValue(l2 - m2, true) + h2 * k2, v2 = d4.toValue(l2 + d4.len - m2, true) - (h2 * k2 || d4.isXAxis && d4.pointRangePadding || 0), w2 = v2 < u2;
                  k2 = d4.hasVerticalPanning();
                  l2 = w2 ? v2 : u2;
                  u2 = w2 ? u2 : v2;
                  var p2 = d4.panningState;
                  !k2 || d4.isXAxis || p2 && !p2.isDirty || d4.series.forEach(function(b3) {
                    var d5 = b3.getProcessedData(true);
                    d5 = b3.getExtremes(d5.yData, true);
                    p2 || (p2 = {
                      startMin: Number.MAX_VALUE,
                      startMax: -Number.MAX_VALUE
                    });
                    V(d5.dataMin) && V(d5.dataMax) && (p2.startMin = Math.min(O(b3.options.threshold, Infinity), d5.dataMin, p2.startMin), p2.startMax = Math.max(O(b3.options.threshold, -Infinity), d5.dataMax, p2.startMax));
                  });
                  k2 = Math.min(O(p2 && p2.startMin, n2.dataMin), h2 ? n2.min : d4.toValue(d4.toPixels(n2.min) - d4.minPixelPadding));
                  v2 = Math.max(O(p2 && p2.startMax, n2.dataMax), h2 ? n2.max : d4.toValue(d4.toPixels(n2.max) + d4.minPixelPadding));
                  d4.panningState = p2;
                  d4.isOrdinal || (h2 = k2 - l2, 0 < h2 && (u2 += h2, l2 = k2), h2 = u2 - v2, 0 < h2 && (u2 = v2, l2 -= h2), d4.series.length && l2 !== n2.min && u2 !== n2.max && l2 >= k2 && u2 <= v2 && (d4.setExtremes(l2, u2, false, false, { trigger: "pan" }), !c2.resetZoomButton && l2 !== k2 && u2 !== v2 && f2.match("y") && (c2.showResetZoom(), d4.displayBtn = false), g2 = true), e3[a4] = m2);
                }
              });
              S(e3, (b3, d4) => {
                c2[d4] = b3;
              });
              g2 && c2.redraw(false);
              r(c2.container, { cursor: "move" });
            });
          }
        }
        R(da.prototype, {
          callbacks: [],
          collectionsWithInit: { xAxis: [da.prototype.addAxis, [true]], yAxis: [da.prototype.addAxis, [false]], series: [da.prototype.addSeries] },
          collectionsWithUpdate: ["xAxis", "yAxis", "series"],
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
        });
        "";
        return da;
      });
      K(
        a,
        "Extensions/ScrollablePlotArea.js",
        [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]],
        function(a2, x, G, I, y, A) {
          const { stop: r } = a2, { addEvent: D, createElement: t, defined: q, merge: k, pick: p } = A;
          D(G, "afterSetChartSize", function(a3) {
            var h = this.options.chart.scrollablePlotArea, f = h && h.minWidth;
            h = h && h.minHeight;
            let c;
            if (!this.renderer.forExport) {
              if (f) {
                if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth))
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox), this.plotBox.width = this.plotWidth += f, this.inverted ? this.clipBox.height += f : this.clipBox.width += f, c = { 1: { name: "right", value: f } };
              } else
                h && (this.scrollablePixelsY = f = Math.max(0, h - this.chartHeight), q(f) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, c = { 2: { name: "bottom", value: f } }));
              c && !a3.skipAxes && this.axes.forEach(function(a4) {
                c[a4.side] ? a4.getPlotLinePath = function() {
                  let f2 = c[a4.side].name, g = this[f2], h2;
                  this[f2] = g - c[a4.side].value;
                  h2 = x.prototype.getPlotLinePath.apply(this, arguments);
                  this[f2] = g;
                  return h2;
                } : (a4.setAxisSize(), a4.setAxisTranslation());
              });
            }
          });
          D(G, "render", function() {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });
          G.prototype.setUpScrolling = function() {
            const a3 = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
            this.scrollablePixelsX && (a3.overflowX = "auto");
            this.scrollablePixelsY && (a3.overflowY = "auto");
            this.scrollingParent = t("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo);
            this.scrollingContainer = t("div", { className: "highcharts-scrolling" }, a3, this.scrollingParent);
            let h;
            D(this.scrollingContainer, "scroll", () => {
              this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (h = this.hoverPoint), this.pointer.runPointActions(void 0, h, true));
            });
            this.innerContainer = t("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };
          G.prototype.moveFixedElements = function() {
            let a3 = this.container, h = this.fixedRenderer, f = ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), c;
            this.scrollablePixelsX && !this.inverted ? c = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? c = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? c = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (c = ".highcharts-yaxis");
            c && f.push(`${c}:not(.highcharts-radial-axis)`, `${c}-labels:not(.highcharts-radial-axis-labels)`);
            f.forEach(function(c2) {
              [].forEach.call(a3.querySelectorAll(c2), function(c3) {
                (c3.namespaceURI === h.SVG_NS ? h.box : h.box.parentNode).appendChild(c3);
                c3.style.pointerEvents = "auto";
              });
            });
          };
          G.prototype.applyFixed = function() {
            var a3 = !this.fixedDiv, h = this.options.chart, f = h.scrollablePlotArea, c = y.getRendererType();
            a3 ? (this.fixedDiv = t("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (h.style && h.style.zIndex || 0) + 2, top: 0 }, null, true), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = h = new c(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = h.path().attr({ fill: this.options.chart.backgroundColor || "#fff", "fill-opacity": p(
              f.opacity,
              0.85
            ), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), D(this, "afterShowResetZoom", this.moveFixedElements), D(this, "afterApplyDrilldown", this.moveFixedElements), D(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a3)
              this.scrollableDirty = false, this.moveFixedElements();
            h = this.chartWidth + (this.scrollablePixelsX || 0);
            c = this.chartHeight + (this.scrollablePixelsY || 0);
            r(this.container);
            this.container.style.width = h + "px";
            this.container.style.height = c + "px";
            this.renderer.boxWrapper.attr({ width: h, height: c, viewBox: [0, 0, h, c].join(" ") });
            this.chartBackground.attr({ width: h, height: c });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a3 && (f.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f.scrollPositionX), f.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f.scrollPositionY));
            c = this.axisOffset;
            a3 = this.plotTop - c[0] - 1;
            f = this.plotLeft - c[3] - 1;
            h = this.plotTop + this.plotHeight + c[2] + 1;
            c = this.plotLeft + this.plotWidth + c[1] + 1;
            let g = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), k2 = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a3 = this.scrollablePixelsX ? [["M", 0, a3], ["L", this.plotLeft - 1, a3], ["L", this.plotLeft - 1, h], ["L", 0, h], ["Z"], ["M", g, a3], ["L", this.chartWidth, a3], ["L", this.chartWidth, h], ["L", g, h], ["Z"]] : this.scrollablePixelsY ? [["M", f, 0], ["L", f, this.plotTop - 1], ["L", c, this.plotTop - 1], ["L", c, 0], ["Z"], ["M", f, k2], ["L", f, this.chartHeight], ["L", c, this.chartHeight], [
              "L",
              c,
              k2
            ], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({ d: a3 });
          };
          D(x, "afterInit", function() {
            this.chart.scrollableDirty = true;
          });
          D(I, "show", function() {
            this.chart.scrollableDirty = true;
          });
          "";
        }
      );
      K(a, "Core/Axis/Stacking/StackItem.js", [a["Core/Templating.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { format: r } = a2, { series: y } = x, { destroyObjectProperties: A, fireEvent: F, isNumber: D, pick: t } = G;
        class q {
          constructor(a3, p, n, h, f) {
            const c = a3.chart.inverted, g = a3.reversed;
            this.axis = a3;
            a3 = this.isNegative = !!n !== !!g;
            this.options = p = p || {};
            this.x = h;
            this.cumulative = this.total = null;
            this.points = {};
            this.hasValidPoints = false;
            this.stack = f;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = { align: p.align || (c ? a3 ? "left" : "right" : "center"), verticalAlign: p.verticalAlign || (c ? "middle" : a3 ? "bottom" : "top"), y: p.y, x: p.x };
            this.textAlign = p.textAlign || (c ? a3 ? "right" : "left" : "center");
          }
          destroy() {
            A(this, this.axis);
          }
          render(a3) {
            const k = this.axis.chart, n = this.options;
            var h = n.format;
            h = h ? r(h, this, k) : n.formatter.call(this);
            this.label ? this.label.attr({ text: h, visibility: "hidden" }) : (this.label = k.renderer.label(h, null, void 0, n.shape, void 0, void 0, n.useHTML, false, "stack-labels"), h = { r: n.borderRadius || 0, text: h, padding: t(n.padding, 5), visibility: "hidden" }, k.styledMode || (h.fill = n.backgroundColor, h.stroke = n.borderColor, h["stroke-width"] = n.borderWidth, this.label.css(n.style || {})), this.label.attr(h), this.label.added || this.label.add(a3));
            this.label.labelrank = k.plotSizeY;
            F(this, "afterRender");
          }
          setOffset(a3, p, n, h, f, c) {
            const {
              alignOptions: g,
              axis: k,
              label: q2,
              options: r2,
              textAlign: e
            } = this, l = k.chart;
            n = this.getStackBox({ xOffset: a3, width: p, boxBottom: n, boxTop: h, defaultX: f, xAxis: c });
            var { verticalAlign: v } = g;
            if (q2 && n) {
              h = q2.getBBox();
              f = q2.padding;
              c = "justify" === t(r2.overflow, "justify");
              g.x = r2.x || 0;
              g.y = r2.y || 0;
              const { x: a4, y: u } = this.adjustStackPosition({ labelBox: h, verticalAlign: v, textAlign: e });
              n.x -= a4;
              n.y -= u;
              q2.align(g, false, n);
              (v = l.isInsidePlot(q2.alignAttr.x + g.x + a4, q2.alignAttr.y + g.y + u)) || (c = false);
              c && y.prototype.justifyDataLabel.call(k, q2, g, q2.alignAttr, h, n);
              q2.attr({
                x: q2.alignAttr.x,
                y: q2.alignAttr.y,
                rotation: r2.rotation,
                rotationOriginX: h.width / 2,
                rotationOriginY: h.height / 2
              });
              t(!c && r2.crop, true) && (v = D(q2.x) && D(q2.y) && l.isInsidePlot(q2.x - f + q2.width, q2.y) && l.isInsidePlot(q2.x + f, q2.y));
              q2[v ? "show" : "hide"]();
            }
            F(this, "afterSetOffset", { xOffset: a3, width: p });
          }
          adjustStackPosition({ labelBox: a3, verticalAlign: p, textAlign: n }) {
            const h = { bottom: 0, middle: 1, top: 2, right: 1, center: 0, left: -1 };
            return { x: a3.width / 2 + a3.width / 2 * h[n], y: a3.height / 2 * h[p] };
          }
          getStackBox(a3) {
            var k = this.axis;
            const n = k.chart, {
              boxTop: h,
              defaultX: f,
              xOffset: c,
              width: g,
              boxBottom: q2
            } = a3;
            var C = k.stacking.usePercentage ? 100 : t(h, this.total, 0);
            C = k.toPixels(C);
            a3 = a3.xAxis || n.xAxis[0];
            const r2 = t(f, a3.translate(this.x)) + c;
            k = k.toPixels(q2 || D(k.min) && k.logarithmic && k.logarithmic.lin2log(k.min) || 0);
            k = Math.abs(C - k);
            const e = this.isNegative;
            return n.inverted ? { x: (e ? C : C - k) - n.plotLeft, y: a3.height - r2 - g, width: k, height: g } : { x: r2 + a3.transB - n.plotLeft, y: (e ? C - k : C) - n.plotTop, width: g, height: k };
          }
        }
        "";
        return q;
      });
      K(a, "Core/Axis/Stacking/StackingAxis.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y) {
        function r() {
          const b2 = this, c2 = b2.inverted;
          b2.yAxis.forEach((b3) => {
            b3.stacking && b3.stacking.stacks && b3.hasVisibleSeries && (b3.stacking.oldStacks = b3.stacking.stacks);
          });
          b2.series.forEach((d) => {
            const a3 = d.xAxis && d.xAxis.options || {};
            !d.options.stacking || true !== d.visible && false !== b2.options.chart.ignoreHiddenSeries || (d.stackKey = [d.type, z(d.options.stack, ""), c2 ? a3.top : a3.left, c2 ? a3.height : a3.width].join());
          });
        }
        function F() {
          const b2 = this.stacking;
          if (b2) {
            var c2 = b2.stacks;
            v(c2, function(b3, d) {
              C(b3);
              c2[d] = null;
            });
            b2 && b2.stackTotalGroup && b2.stackTotalGroup.destroy();
          }
        }
        function D() {
          "yAxis" !== this.coll || this.stacking || (this.stacking = new u(this));
        }
        function t(b2, c2, a3, e2) {
          !B(b2) || b2.x !== c2 || e2 && b2.stackKey !== e2 ? b2 = { x: c2, index: 0, key: e2, stackKey: e2 } : b2.index++;
          b2.key = [a3, c2, b2.index].join();
          return b2;
        }
        function q() {
          const b2 = this, c2 = b2.stackKey, a3 = b2.yAxis.stacking.stacks, e2 = b2.processedXData, f2 = b2[b2.options.stacking + "Stacker"];
          let g2;
          f2 && [c2, "-" + c2].forEach((d) => {
            let c3 = e2.length;
            let m;
            for (; c3--; ) {
              var l2 = e2[c3];
              g2 = b2.getStackIndicator(g2, l2, b2.index, d);
              (m = (l2 = a3[d] && a3[d][l2]) && l2.points[g2.key]) && f2.call(b2, m, l2, c3);
            }
          });
        }
        function k(b2, c2, a3) {
          c2 = c2.total ? 100 / c2.total : 0;
          b2[0] = g(b2[0] * c2);
          b2[1] = g(b2[1] * c2);
          this.stackedYData[a3] = b2[1];
        }
        function p() {
          const b2 = this.yAxis.stacking;
          this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? f.setStackedPoints.call(this, "group") : b2 && v(b2.stacks, (d, c2) => {
            "group" === c2.slice(-5) && (v(d, (b3) => b3.destroy()), delete b2.stacks[c2]);
          });
        }
        function n(b2) {
          var d = this.chart;
          const c2 = b2 || this.options.stacking;
          if (c2 && (true === this.visible || false === d.options.chart.ignoreHiddenSeries)) {
            var a3 = this.processedXData, f2 = this.processedYData, l2 = [], h2 = f2.length, k2 = this.options, n2 = k2.threshold, u2 = z(k2.startFromThreshold && n2, 0);
            k2 = k2.stack;
            b2 = b2 ? `${this.type},${c2}` : this.stackKey;
            var v2 = "-" + b2, p2 = this.negStacks;
            d = "group" === c2 ? d.yAxis[0] : this.yAxis;
            var q2 = d.stacking.stacks, C2 = d.stacking.oldStacks, r2, E2;
            d.stacking.stacksTouched += 1;
            for (E2 = 0; E2 < h2; E2++) {
              var t2 = a3[E2];
              var y2 = f2[E2];
              var D2 = this.getStackIndicator(D2, t2, this.index);
              var A = D2.key;
              var x2 = (r2 = p2 && y2 < (u2 ? 0 : n2)) ? v2 : b2;
              q2[x2] || (q2[x2] = {});
              q2[x2][t2] || (C2[x2] && C2[x2][t2] ? (q2[x2][t2] = C2[x2][t2], q2[x2][t2].total = null) : q2[x2][t2] = new I(d, d.options.stackLabels, !!r2, t2, k2));
              x2 = q2[x2][t2];
              null !== y2 ? (x2.points[A] = x2.points[this.index] = [z(x2.cumulative, u2)], B(x2.cumulative) || (x2.base = A), x2.touched = d.stacking.stacksTouched, 0 < D2.index && false === this.singleStacks && (x2.points[A][0] = x2.points[this.index + "," + t2 + ",0"][0])) : x2.points[A] = x2.points[this.index] = null;
              "percent" === c2 ? (r2 = r2 ? b2 : v2, p2 && q2[r2] && q2[r2][t2] ? (r2 = q2[r2][t2], x2.total = r2.total = Math.max(r2.total, x2.total) + Math.abs(y2) || 0) : x2.total = g(x2.total + (Math.abs(y2) || 0))) : "group" === c2 ? (e(y2) && (y2 = y2[0]), null !== y2 && (x2.total = (x2.total || 0) + 1)) : x2.total = g(x2.total + (y2 || 0));
              x2.cumulative = "group" === c2 ? (x2.total || 1) - 1 : g(z(x2.cumulative, u2) + (y2 || 0));
              null !== y2 && (x2.points[A].push(x2.cumulative), l2[E2] = x2.cumulative, x2.hasValidPoints = true);
            }
            "percent" === c2 && (d.stacking.usePercentage = true);
            "group" !== c2 && (this.stackedYData = l2);
            d.stacking.oldStacks = {};
          }
        }
        const { getDeferredAnimation: h } = a2, { series: { prototype: f } } = G, { addEvent: c, correctFloat: g, defined: B, destroyObjectProperties: C, fireEvent: E, isArray: e, isNumber: l, objectEach: v, pick: z } = y;
        class u {
          constructor(b2) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = b2;
          }
          buildStacks() {
            const b2 = this.axis, c2 = b2.series, a3 = b2.options.reversedStacks, e2 = c2.length;
            let f2, g2;
            this.usePercentage = false;
            for (g2 = e2; g2--; )
              f2 = c2[a3 ? g2 : e2 - g2 - 1], f2.setStackedPoints(), f2.setGroupedPoints();
            for (g2 = 0; g2 < e2; g2++)
              c2[g2].modifyStacks();
            E(b2, "afterBuildStacks");
          }
          cleanStacks() {
            let b2;
            this.oldStacks && (b2 = this.stacks = this.oldStacks);
            v(b2, function(b3) {
              v(b3, function(b4) {
                b4.cumulative = b4.total;
              });
            });
          }
          resetStacks() {
            v(this.stacks, (b2) => {
              v(b2, (d, c2) => {
                l(d.touched) && d.touched < this.stacksTouched ? (d.destroy(), delete b2[c2]) : (d.total = null, d.cumulative = null);
              });
            });
          }
          renderStackTotals() {
            var b2 = this.axis;
            const c2 = b2.chart, a3 = c2.renderer, e2 = this.stacks;
            b2 = h(c2, b2.options.stackLabels && b2.options.stackLabels.animation || false);
            const f2 = this.stackTotalGroup = this.stackTotalGroup || a3.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
            f2.translate(c2.plotLeft, c2.plotTop);
            v(e2, function(b3) {
              v(b3, function(b4) {
                b4.render(f2);
              });
            });
            f2.animate({ opacity: 1 }, b2);
          }
        }
        var b;
        (function(b2) {
          const d = [];
          b2.compose = function(b3, a3, e2) {
            y.pushUnique(d, b3) && (c(b3, "init", D), c(b3, "destroy", F));
            y.pushUnique(d, a3) && (a3.prototype.getStacks = r);
            y.pushUnique(d, e2) && (b3 = e2.prototype, b3.getStackIndicator = t, b3.modifyStacks = q, b3.percentStacker = k, b3.setGroupedPoints = p, b3.setStackedPoints = n);
          };
        })(b || (b = {}));
        return b;
      });
      K(
        a,
        "Series/Line/LineSeries.js",
        [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, x, G) {
          const { defined: r, merge: y } = G;
          class A extends a2 {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = void 0;
            }
            drawGraph() {
              const a3 = this, r2 = this.options, t = (this.gappedPath || this.getGraphPath).call(this), q = this.chart.styledMode;
              let k = [["graph", "highcharts-graph"]];
              q || k[0].push(r2.lineColor || this.color || "#cccccc", r2.dashStyle);
              k = a3.getZonesGraphs(k);
              k.forEach(function(k2, n) {
                var h = k2[0];
                let f = a3[h];
                const c = f ? "animate" : "attr";
                f ? (f.endX = a3.preventGraphAnimation ? null : t.xMap, f.animate({ d: t })) : t.length && (a3[h] = f = a3.chart.renderer.path(t).addClass(k2[1]).attr({ zIndex: 1 }).add(a3.group));
                f && !q && (h = { stroke: k2[2], "stroke-width": r2.lineWidth || 0, fill: a3.fillGraph && a3.color || "none" }, k2[3] ? h.dashstyle = k2[3] : "square" !== r2.linecap && (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), f[c](h).shadow(2 > n && r2.shadow));
                f && (f.startX = t.xMap, f.isArea = t.isArea);
              });
            }
            getGraphPath(a3, y2, t) {
              const q = this, k = q.options, p = [], n = [];
              let h, f = k.step;
              a3 = a3 || q.points;
              const c = a3.reversed;
              c && a3.reverse();
              (f = { right: 1, center: 2 }[f] || f && 3) && c && (f = 4 - f);
              a3 = this.getValidPoints(a3, false, !(k.connectNulls && !y2 && !t));
              a3.forEach(function(c2, B) {
                const g = c2.plotX, E = c2.plotY, e = a3[B - 1], l = c2.isNull || "number" !== typeof E;
                (c2.leftCliff || e && e.rightCliff) && !t && (h = true);
                l && !r(y2) && 0 < B ? h = !k.connectNulls : l && !y2 ? h = true : (0 === B || h ? B = [["M", c2.plotX, c2.plotY]] : q.getPointSpline ? B = [q.getPointSpline(a3, c2, B)] : f ? (B = 1 === f ? [["L", e.plotX, E]] : 2 === f ? [["L", (e.plotX + g) / 2, e.plotY], ["L", (e.plotX + g) / 2, E]] : [["L", g, e.plotY]], B.push(["L", g, E])) : B = [["L", g, E]], n.push(c2.x), f && (n.push(c2.x), 2 === f && n.push(c2.x)), p.push.apply(p, B), h = false);
              });
              p.xMap = n;
              return q.graphPath = p;
            }
            getZonesGraphs(a3) {
              this.zones.forEach(function(r2, t) {
                t = ["zone-graph-" + t, "highcharts-graph highcharts-zone-graph-" + t + " " + (r2.className || "")];
                this.chart.styledMode || t.push(r2.color || this.color, r2.dashStyle || this.options.dashStyle);
                a3.push(t);
              }, this);
              return a3;
            }
          }
          A.defaultOptions = y(a2.defaultOptions, { legendSymbol: "lineMarker" });
          x.registerSeriesType("line", A);
          "";
          return A;
        }
      );
      K(a, "Series/Area/AreaSeries.js", [
        a["Core/Color/Color.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G) {
        const { seriesTypes: { line: r } } = x, { extend: y, merge: A, objectEach: F, pick: D } = G;
        class t extends r {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            this.areaPath = [];
            super.drawGraph.apply(this);
            const a3 = this, k = this.areaPath, p = this.options, n = [["area", "highcharts-area", this.color, p.fillColor]];
            this.zones.forEach(function(h, f) {
              n.push(["zone-area-" + f, "highcharts-area highcharts-zone-area-" + f + " " + h.className, h.color || a3.color, h.fillColor || p.fillColor]);
            });
            n.forEach(function(h) {
              const f = h[0], c = {};
              let g = a3[f];
              const n2 = g ? "animate" : "attr";
              g ? (g.endX = a3.preventGraphAnimation ? null : k.xMap, g.animate({ d: k })) : (c.zIndex = 0, g = a3[f] = a3.chart.renderer.path(k).addClass(h[1]).add(a3.group), g.isArea = true);
              a3.chart.styledMode || (h[3] ? c.fill = h[3] : (c.fill = h[2], c["fill-opacity"] = D(p.fillOpacity, 0.75)));
              g[n2](c);
              g.startX = k.xMap;
              g.shiftUnit = p.step ? 2 : 1;
            });
          }
          getGraphPath(a3) {
            var k = r.prototype.getGraphPath, p = this.options;
            const n = p.stacking, h = this.yAxis, f = [], c = [], g = this.index, q = h.stacking.stacks[this.stackKey], C = p.threshold, E = Math.round(h.getThreshold(p.threshold));
            p = D(p.connectNulls, "percent" === n);
            var e = function(e2, b, d) {
              var m = a3[e2];
              e2 = n && q[m.x].points[g];
              const k2 = m[d + "Null"] || 0;
              d = m[d + "Cliff"] || 0;
              let u, v2;
              m = true;
              d || k2 ? (u = (k2 ? e2[0] : e2[1]) + d, v2 = e2[0] + d, m = !!k2) : !n && a3[b] && a3[b].isNull && (u = v2 = C);
              "undefined" !== typeof u && (c.push({ plotX: l, plotY: null === u ? E : h.getThreshold(u), isNull: m, isCliff: true }), f.push({ plotX: l, plotY: null === v2 ? E : h.getThreshold(v2), doCurve: false }));
            };
            let l;
            a3 = a3 || this.points;
            n && (a3 = this.getStackPoints(a3));
            for (let g2 = 0, b = a3.length; g2 < b; ++g2) {
              n || (a3[g2].leftCliff = a3[g2].rightCliff = a3[g2].leftNull = a3[g2].rightNull = void 0);
              var v = a3[g2].isNull;
              l = D(a3[g2].rectPlotX, a3[g2].plotX);
              var z = n ? D(a3[g2].yBottom, E) : E;
              if (!v || p)
                p || e(g2, g2 - 1, "left"), v && !n && p || (c.push(a3[g2]), f.push({ x: g2, plotX: l, plotY: z })), p || e(g2, g2 + 1, "right");
            }
            e = k.call(this, c, true, true);
            f.reversed = true;
            v = k.call(this, f, true, true);
            (z = v[0]) && "M" === z[0] && (v[0] = ["L", z[1], z[2]]);
            v = e.concat(v);
            v.length && v.push(["Z"]);
            k = k.call(this, c, false, p);
            v.xMap = e.xMap;
            this.areaPath = v;
            return k;
          }
          getStackPoints(a3) {
            const k = this, p = [], n = [], h = this.xAxis, f = this.yAxis, c = f.stacking.stacks[this.stackKey], g = {}, q = f.series, C = q.length, r2 = f.options.reversedStacks ? 1 : -1, e = q.indexOf(k);
            a3 = a3 || this.points;
            if (this.options.stacking) {
              for (let c2 = 0; c2 < a3.length; c2++)
                a3[c2].leftNull = a3[c2].rightNull = void 0, g[a3[c2].x] = a3[c2];
              F(c, function(c2, a4) {
                null !== c2.total && n.push(a4);
              });
              n.sort(function(c2, a4) {
                return c2 - a4;
              });
              const l = q.map((c2) => c2.visible);
              n.forEach(function(a4, z) {
                let u = 0, b, d;
                if (g[a4] && !g[a4].isNull)
                  p.push(g[a4]), [-1, 1].forEach(function(f2) {
                    const m = 1 === f2 ? "rightNull" : "leftNull", h2 = c[n[z + f2]];
                    let u2 = 0;
                    if (h2) {
                      let f3 = e;
                      for (; 0 <= f3 && f3 < C; ) {
                        const e2 = q[f3].index;
                        b = h2.points[e2];
                        b || (e2 === k.index ? g[a4][m] = true : l[f3] && (d = c[a4].points[e2]) && (u2 -= d[1] - d[0]));
                        f3 += r2;
                      }
                    }
                    g[a4][1 === f2 ? "rightCliff" : "leftCliff"] = u2;
                  });
                else {
                  let d2 = e;
                  for (; 0 <= d2 && d2 < C; ) {
                    if (b = c[a4].points[q[d2].index]) {
                      u = b[1];
                      break;
                    }
                    d2 += r2;
                  }
                  u = D(u, 0);
                  u = f.translate(u, 0, 1, 0, 1);
                  p.push({ isNull: true, plotX: h.translate(a4, 0, 0, 0, 1), x: a4, plotY: u, yBottom: u });
                }
              });
            }
            return p;
          }
        }
        t.defaultOptions = A(r.defaultOptions, { threshold: 0, legendSymbol: "rectangle" });
        y(t.prototype, { singleStacks: false });
        x.registerSeriesType("area", t);
        "";
        return t;
      });
      K(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { line: r } = a2.seriesTypes, { merge: I, pick: y } = x;
        class A extends r {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          getPointSpline(a3, r2, t) {
            const q = r2.plotX || 0, k = r2.plotY || 0, p = a3[t - 1];
            t = a3[t + 1];
            let n, h;
            let f;
            if (p && !p.isNull && false !== p.doCurve && !r2.isCliff && t && !t.isNull && false !== t.doCurve && !r2.isCliff) {
              a3 = p.plotY || 0;
              var c = t.plotX || 0;
              t = t.plotY || 0;
              let g = 0;
              n = (1.5 * q + (p.plotX || 0)) / 2.5;
              h = (1.5 * k + a3) / 2.5;
              c = (1.5 * q + c) / 2.5;
              f = (1.5 * k + t) / 2.5;
              c !== n && (g = (f - h) * (c - q) / (c - n) + k - f);
              h += g;
              f += g;
              h > a3 && h > k ? (h = Math.max(a3, k), f = 2 * k - h) : h < a3 && h < k && (h = Math.min(a3, k), f = 2 * k - h);
              f > t && f > k ? (f = Math.max(t, k), h = 2 * k - f) : f < t && f < k && (f = Math.min(t, k), h = 2 * k - f);
              r2.rightContX = c;
              r2.rightContY = f;
            }
            r2 = ["C", y(p.rightContX, p.plotX, 0), y(p.rightContY, p.plotY, 0), y(n, q, 0), y(h, k, 0), q, k];
            p.rightContX = p.rightContY = void 0;
            return r2;
          }
        }
        A.defaultOptions = I(r.defaultOptions);
        a2.registerSeriesType(
          "spline",
          A
        );
        "";
        return A;
      });
      K(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Spline/SplineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { area: r, area: { prototype: y } } = x.seriesTypes, { extend: A, merge: F } = G;
        class D extends a2 {
          constructor() {
            super(...arguments);
            this.options = this.points = this.data = void 0;
          }
        }
        D.defaultOptions = F(a2.defaultOptions, r.defaultOptions);
        A(D.prototype, { getGraphPath: y.getGraphPath, getStackPoints: y.getStackPoints, drawGraph: y.drawGraph });
        x.registerSeriesType(
          "areaspline",
          D
        );
        "";
        return D;
      });
      K(a, "Series/Column/ColumnSeriesDefaults.js", [], function() {
        "";
        return { borderRadius: 3, centerInCategory: false, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" };
      });
      K(a, "Series/Column/ColumnSeries.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Series/Column/ColumnSeriesDefaults.js"],
        a["Core/Globals.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y, A, F) {
        const { animObject: r } = a2, { parse: t } = x, { hasTouch: q, noop: k } = I, { clamp: p, defined: n, extend: h, fireEvent: f, isArray: c, isNumber: g, merge: B, pick: C, objectEach: E } = F;
        class e extends y {
          constructor() {
            super(...arguments);
            this.points = this.options = this.group = this.data = this.borderWidth = void 0;
          }
          animate(c2) {
            const a3 = this, e2 = this.yAxis, f2 = e2.pos, b = a3.options, d = this.chart.inverted, g2 = {}, l = d ? "translateX" : "translateY";
            let k2;
            c2 ? (g2.scaleY = 1e-3, c2 = p(e2.toPixels(b.threshold), f2, f2 + e2.len), d ? g2.translateX = c2 - e2.len : g2.translateY = c2, a3.clipBox && a3.setClip(), a3.group.attr(g2)) : (k2 = Number(a3.group.attr(l)), a3.group.animate({ scaleY: 1 }, h(r(a3.options.animation), { step: function(b2, d2) {
              a3.group && (g2[l] = k2 + d2.pos * (f2 - k2), a3.group.attr(g2));
            } })));
          }
          init(c2, a3) {
            super.init.apply(this, arguments);
            const e2 = this;
            c2 = e2.chart;
            c2.hasRendered && c2.series.forEach(function(c3) {
              c3.type === e2.type && (c3.isDirty = true);
            });
          }
          getColumnMetrics() {
            const c2 = this;
            var a3 = c2.options;
            const e2 = c2.xAxis, f2 = c2.yAxis;
            var b = e2.options.reversedStacks;
            b = e2.reversed && !b || !e2.reversed && b;
            const d = {};
            let g2, h2 = 0;
            false === a3.grouping ? h2 = 1 : c2.chart.series.forEach(function(b2) {
              const a4 = b2.yAxis, e3 = b2.options;
              let l;
              b2.type !== c2.type || !b2.visible && c2.chart.options.chart.ignoreHiddenSeries || f2.len !== a4.len || f2.pos !== a4.pos || (e3.stacking && "group" !== e3.stacking ? (g2 = b2.stackKey, "undefined" === typeof d[g2] && (d[g2] = h2++), l = d[g2]) : false !== e3.grouping && (l = h2++), b2.columnIndex = l);
            });
            const k2 = Math.min(Math.abs(e2.transA) * (e2.ordinal && e2.ordinal.slope || a3.pointRange || e2.closestPointRange || e2.tickInterval || 1), e2.len), n2 = k2 * a3.groupPadding, p2 = (k2 - 2 * n2) / (h2 || 1);
            a3 = Math.min(a3.maxPointWidth || e2.len, C(a3.pointWidth, p2 * (1 - 2 * a3.pointPadding)));
            c2.columnMetrics = { width: a3, offset: (p2 - a3) / 2 + (n2 + ((c2.columnIndex || 0) + (b ? 1 : 0)) * p2 - k2 / 2) * (b ? -1 : 1), paddedWidth: p2, columnCount: h2 };
            return c2.columnMetrics;
          }
          crispCol(c2, a3, e2, f2) {
            var b = this.borderWidth, d = -(b % 2 ? 0.5 : 0);
            b = b % 2 ? 0.5 : 1;
            this.options.crisp && (e2 = Math.round(c2 + e2) + d, c2 = Math.round(c2) + d, e2 -= c2);
            f2 = Math.round(a3 + f2) + b;
            d = 0.5 >= Math.abs(a3) && 0.5 < f2;
            a3 = Math.round(a3) + b;
            f2 -= a3;
            d && f2 && (--a3, f2 += 1);
            return { x: c2, y: a3, width: e2, height: f2 };
          }
          adjustForMissingColumns(a3, e2, f2, g2) {
            const b = this.options.stacking;
            if (!f2.isNull && 1 < g2.columnCount) {
              const d = this.yAxis.options.reversedStacks;
              let l = 0, h2 = d ? 0 : -g2.columnCount;
              E(this.yAxis.stacking && this.yAxis.stacking.stacks, (a4) => {
                if ("number" === typeof f2.x) {
                  const e3 = a4[f2.x.toString()];
                  e3 && (a4 = e3.points[this.index], b ? (a4 && (l = h2), e3.hasValidPoints && (d ? h2++ : h2--)) : c(a4) && (a4 = Object.keys(e3.points).filter((b2) => !b2.match(",") && e3.points[b2] && 1 < e3.points[b2].length).map(parseFloat).sort((b2, d2) => d2 - b2), l = a4.indexOf(this.index), h2 = a4.length));
                }
              });
              a3 = (f2.plotX || 0) + ((h2 - 1) * g2.paddedWidth + e2) / 2 - e2 - l * g2.paddedWidth;
            }
            return a3;
          }
          translate() {
            const c2 = this, a3 = c2.chart, e2 = c2.options;
            var h2 = c2.dense = 2 > c2.closestPointRange * c2.xAxis.transA;
            h2 = c2.borderWidth = C(e2.borderWidth, h2 ? 0 : 1);
            const b = c2.xAxis, d = c2.yAxis, m = e2.threshold, k2 = C(e2.minPointLength, 5), q2 = c2.getColumnMetrics(), B2 = q2.width, r2 = c2.pointXOffset = q2.offset, E2 = c2.dataMin, t2 = c2.dataMax;
            let x2 = c2.barW = Math.max(B2, 1 + 2 * h2), A2 = c2.translatedThreshold = d.getThreshold(m);
            a3.inverted && (A2 -= 0.5);
            e2.pointPadding && (x2 = Math.ceil(x2));
            y.prototype.translate.apply(c2);
            c2.points.forEach(function(f2) {
              const h3 = C(f2.yBottom, A2);
              var l = 999 + Math.abs(h3), u = f2.plotX || 0;
              l = p(f2.plotY, -l, d.len + l);
              let v = Math.min(l, h3), w = Math.max(l, h3) - v, z = B2, H = u + r2, y2 = x2;
              k2 && Math.abs(w) < k2 && (w = k2, u = !d.reversed && !f2.negative || d.reversed && f2.negative, g(m) && g(t2) && f2.y === m && t2 <= m && (d.min || 0) < m && (E2 !== t2 || (d.max || 0) <= m) && (u = !u, f2.negative = !f2.negative), v = Math.abs(v - A2) > k2 ? h3 - k2 : A2 - (u ? k2 : 0));
              n(f2.options.pointWidth) && (z = y2 = Math.ceil(f2.options.pointWidth), H -= Math.round((z - B2) / 2));
              e2.centerInCategory && (H = c2.adjustForMissingColumns(H, z, f2, q2));
              f2.barX = H;
              f2.pointWidth = z;
              f2.tooltipPos = a3.inverted ? [p(d.len + d.pos - a3.plotLeft - l, d.pos - a3.plotLeft, d.len + d.pos - a3.plotLeft), b.len + b.pos - a3.plotTop - H - y2 / 2, w] : [b.left - a3.plotLeft + H + y2 / 2, p(l + d.pos - a3.plotTop, d.pos - a3.plotTop, d.len + d.pos - a3.plotTop), w];
              f2.shapeType = c2.pointClass.prototype.shapeType || "roundedRect";
              f2.shapeArgs = c2.crispCol(H, f2.isNull ? A2 : v, y2, f2.isNull ? 0 : w);
            });
            f(this, "afterColumnTranslate");
          }
          drawGraph() {
            this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
          }
          pointAttribs(c2, a3) {
            const e2 = this.options;
            var f2 = this.pointAttrToOptions || {}, b = f2.stroke || "borderColor";
            const d = f2["stroke-width"] || "borderWidth";
            let g2, h2 = c2 && c2.color || this.color, l = c2 && c2[b] || e2[b] || h2;
            f2 = c2 && c2.options.dashStyle || e2.dashStyle;
            let k2 = c2 && c2[d] || e2[d] || this[d] || 0, n2 = C(c2 && c2.opacity, e2.opacity, 1);
            c2 && this.zones.length && (g2 = c2.getZone(), h2 = c2.options.color || g2 && (g2.color || c2.nonZonedColor) || this.color, g2 && (l = g2.borderColor || l, f2 = g2.dashStyle || f2, k2 = g2.borderWidth || k2));
            a3 && c2 && (c2 = B(
              e2.states[a3],
              c2.options.states && c2.options.states[a3] || {}
            ), a3 = c2.brightness, h2 = c2.color || "undefined" !== typeof a3 && t(h2).brighten(c2.brightness).get() || h2, l = c2[b] || l, k2 = c2[d] || k2, f2 = c2.dashStyle || f2, n2 = C(c2.opacity, n2));
            b = { fill: h2, stroke: l, "stroke-width": k2, opacity: n2 };
            f2 && (b.dashstyle = f2);
            return b;
          }
          drawPoints(c2 = this.points) {
            const a3 = this, e2 = this.chart, f2 = a3.options, b = e2.renderer, d = f2.animationLimit || 250;
            let h2;
            c2.forEach(function(c3) {
              let l = c3.graphic, m = !!l, k2 = l && e2.pointCount < d ? "animate" : "attr";
              if (g(c3.plotY) && null !== c3.y) {
                h2 = c3.shapeArgs;
                l && c3.hasNewShapeType() && (l = l.destroy());
                a3.enabledDataSorting && (c3.startXPos = a3.xAxis.reversed ? -(h2 ? h2.width || 0 : 0) : a3.xAxis.width);
                l || (c3.graphic = l = b[c3.shapeType](h2).add(c3.group || a3.group)) && a3.enabledDataSorting && e2.hasRendered && e2.pointCount < d && (l.attr({ x: c3.startXPos }), m = true, k2 = "animate");
                if (l && m)
                  l[k2](B(h2));
                e2.styledMode || l[k2](a3.pointAttribs(c3, c3.selected && "select")).shadow(false !== c3.allowShadow && f2.shadow);
                l && (l.addClass(c3.getClassName(), true), l.attr({ visibility: c3.visible ? "inherit" : "hidden" }));
              } else
                l && (c3.graphic = l.destroy());
            });
          }
          drawTracker(a3 = this.points) {
            const e2 = this, g2 = e2.chart, h2 = g2.pointer, b = function(b2) {
              const d2 = h2.getPointFromEvent(b2);
              "undefined" !== typeof d2 && e2.options.enableMouseTracking && (h2.isDirectTouch = true, d2.onMouseOver(b2));
            };
            let d;
            a3.forEach(function(b2) {
              d = c(b2.dataLabels) ? b2.dataLabels : b2.dataLabel ? [b2.dataLabel] : [];
              b2.graphic && (b2.graphic.element.point = b2);
              d.forEach(function(d2) {
                d2.div ? d2.div.point = b2 : d2.element.point = b2;
              });
            });
            e2._hasTracking || (e2.trackerGroups.forEach(function(d2) {
              if (e2[d2]) {
                e2[d2].addClass("highcharts-tracker").on("mouseover", b).on(
                  "mouseout",
                  function(b2) {
                    h2.onTrackerMouseOut(b2);
                  }
                );
                if (q)
                  e2[d2].on("touchstart", b);
                !g2.styledMode && e2.options.cursor && e2[d2].css({ cursor: e2.options.cursor });
              }
            }), e2._hasTracking = true);
            f(this, "afterDrawTracker");
          }
          remove() {
            const c2 = this, a3 = c2.chart;
            a3.hasRendered && a3.series.forEach(function(a4) {
              a4.type === c2.type && (a4.isDirty = true);
            });
            y.prototype.remove.apply(c2, arguments);
          }
        }
        e.defaultOptions = B(y.defaultOptions, G);
        h(e.prototype, { cropShoulder: 0, directTouch: true, getSymbol: k, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] });
        A.registerSeriesType(
          "column",
          e
        );
        "";
        return e;
      });
      K(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { getDeferredAnimation: r } = a2, { format: y } = x, { defined: A, extend: F, fireEvent: D, isArray: t, isString: q, merge: k, objectEach: p, pick: n, splat: h } = G;
        var f;
        (function(c) {
          function a3(b, d, c2, a4, e2) {
            const f3 = this.chart;
            var g = this.isCartesian && f3.inverted;
            const h2 = this.enabledDataSorting;
            var l2 = b.plotX, m = b.plotY;
            const k2 = c2.rotation;
            var u2 = c2.align;
            m = A(l2) && A(m) && f3.isInsidePlot(
              l2,
              Math.round(m),
              { inverted: g, paneCoordinates: true, series: this }
            );
            let v2 = "justify" === n(c2.overflow, h2 ? "none" : "justify");
            g = this.visible && false !== b.visible && A(l2) && (b.series.forceDL || h2 && !v2 || m || n(c2.inside, !!this.options.stacking) && a4 && f3.isInsidePlot(l2, g ? a4.x + 1 : a4.y + a4.height - 1, { inverted: g, paneCoordinates: true, series: this }));
            l2 = b.pos();
            if (g && l2) {
              k2 && d.attr({ align: u2 });
              u2 = d.getBBox(true);
              var p2 = [0, 0];
              var q2 = f3.renderer.fontMetrics(d).b;
              a4 = F({ x: l2[0], y: Math.round(l2[1]), width: 0, height: 0 }, a4);
              F(c2, { width: u2.width, height: u2.height });
              k2 ? (v2 = false, p2 = f3.renderer.rotCorr(q2, k2), q2 = { x: a4.x + (c2.x || 0) + a4.width / 2 + p2.x, y: a4.y + (c2.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[c2.verticalAlign] * a4.height }, p2 = [u2.x - Number(d.attr("x")), u2.y - Number(d.attr("y"))], h2 && this.xAxis && !v2 && this.setDataLabelStartPos(b, d, e2, m, q2), d[e2 ? "attr" : "animate"](q2)) : (h2 && this.xAxis && !v2 && this.setDataLabelStartPos(b, d, e2, m, a4), d.align(c2, void 0, a4), q2 = d.alignAttr);
              if (v2 && 0 <= a4.height)
                this.justifyDataLabel(d, c2, q2, u2, a4, e2);
              else if (n(c2.crop, true)) {
                let { x: b2, y: c3 } = q2;
                b2 += p2[0];
                c3 += p2[1];
                g = f3.isInsidePlot(b2, c3, {
                  paneCoordinates: true,
                  series: this
                }) && f3.isInsidePlot(b2 + u2.width, c3 + u2.height, { paneCoordinates: true, series: this });
              }
              if (c2.shape && !k2)
                d[e2 ? "attr" : "animate"]({ anchorX: l2[0], anchorY: l2[1] });
            }
            e2 && h2 && (d.placed = false);
            g || h2 && !v2 ? d.show() : (d.hide(), d.placed = false);
          }
          function f2(b, c2) {
            var d = c2.filter;
            return d ? (c2 = d.operator, b = b[d.property], d = d.value, ">" === c2 && b > d || "<" === c2 && b < d || ">=" === c2 && b >= d || "<=" === c2 && b <= d || "==" === c2 && b == d || "===" === c2 && b === d ? true : false) : true;
          }
          function C() {
            return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
          }
          function E(b) {
            const c2 = this.hasRendered || 0, a4 = this.initDataLabelsGroup().attr({ opacity: +c2 });
            !c2 && a4 && (this.visible && a4.show(), this.options.animation ? a4.animate({ opacity: 1 }, b) : a4.attr({ opacity: 1 }));
            return a4;
          }
          function e(b = this.points) {
            var c2, a4;
            const e2 = this, g = e2.chart, l2 = e2.options, k2 = g.renderer, { backgroundColor: u2, plotBackgroundColor: B } = g.options.chart, C2 = g.options.plotOptions, z2 = k2.getContrast(q(B) && B || q(u2) && u2 || "#000000");
            let E2 = l2.dataLabels, x2, G2;
            var F2 = h(E2)[0];
            const I = F2.animation;
            F2 = F2.defer ? r(g, I, e2) : { defer: 0, duration: 0 };
            E2 = v(v(null === (c2 = null === C2 || void 0 === C2 ? void 0 : C2.series) || void 0 === c2 ? void 0 : c2.dataLabels, null === (a4 = null === C2 || void 0 === C2 ? void 0 : C2[e2.type]) || void 0 === a4 ? void 0 : a4.dataLabels), E2);
            D(this, "drawDataLabels");
            if (t(E2) || E2.enabled || e2._hasPointLabels)
              G2 = this.initDataLabels(F2), b.forEach((b2) => {
                var c3;
                const d = b2.dataLabels || [];
                x2 = h(v(E2, b2.dlOptions || (null === (c3 = b2.options) || void 0 === c3 ? void 0 : c3.dataLabels)));
                x2.forEach((c4, a5) => {
                  var h2, m = c4.enabled && (!b2.isNull || b2.dataLabelOnNull) && f2(b2, c4);
                  const u3 = b2.connectors ? b2.connectors[a5] : b2.connector, v2 = c4.style || {};
                  let w = {}, B2 = d[a5], C3 = !B2;
                  const r2 = n(c4.distance, b2.labelDistance);
                  if (m) {
                    var E3 = n(c4[b2.formatPrefix + "Format"], c4.format);
                    var t2 = b2.getLabelConfig();
                    t2 = A(E3) ? y(E3, t2, g) : (c4[b2.formatPrefix + "Formatter"] || c4.formatter).call(t2, c4);
                    E3 = c4.rotation;
                    g.styledMode || (v2.color = n(c4.color, v2.color, q(e2.color) ? e2.color : void 0, "#000000"), "contrast" === v2.color ? (b2.contrastColor = k2.getContrast(b2.color || e2.color), v2.color = !A(r2) && c4.inside || 0 > (r2 || 0) || l2.stacking ? b2.contrastColor : z2) : delete b2.contrastColor, l2.cursor && (v2.cursor = l2.cursor));
                    w = { r: c4.borderRadius || 0, rotation: E3, padding: c4.padding, zIndex: 1 };
                    if (!g.styledMode) {
                      const { backgroundColor: d2, borderColor: a6 } = c4;
                      w.fill = "auto" === d2 ? b2.color : d2;
                      w.stroke = "auto" === a6 ? b2.color : a6;
                      w["stroke-width"] = c4.borderWidth;
                    }
                    p(w, (b3, c5) => {
                      "undefined" === typeof b3 && delete w[c5];
                    });
                  }
                  !B2 || m && A(t2) && !!B2.div === !!c4.useHTML && (B2.rotation && c4.rotation || B2.rotation === c4.rotation) || (B2 = void 0, C3 = true, u3 && b2.connector && (b2.connector = b2.connector.destroy(), b2.connectors && (1 === b2.connectors.length ? delete b2.connectors : delete b2.connectors[a5])));
                  m && A(t2) && (B2 ? w.text = t2 : (B2 = E3 ? k2.text(t2, 0, 0, c4.useHTML).addClass("highcharts-data-label") : k2.label(t2, 0, 0, c4.shape, void 0, void 0, c4.useHTML, void 0, "data-label")) && B2.addClass(" highcharts-data-label-color-" + b2.colorIndex + " " + (c4.className || "") + (c4.useHTML ? " highcharts-tracker" : "")), B2 && (B2.options = c4, B2.attr(w), g.styledMode || B2.css(v2).shadow(c4.shadow), (m = c4[b2.formatPrefix + "TextPath"] || c4.textPath) && !c4.useHTML && (B2.setTextPath((null === (h2 = b2.getDataLabelPath) || void 0 === h2 ? void 0 : h2.call(b2, B2)) || b2.graphic, m), b2.dataLabelPath && !m.enabled && (b2.dataLabelPath = b2.dataLabelPath.destroy())), B2.added || B2.add(G2), e2.alignDataLabel(b2, B2, c4, void 0, C3), B2.isActive = true, d[a5] && d[a5] !== B2 && d[a5].destroy(), d[a5] = B2));
                });
                for (c3 = d.length; c3--; )
                  d[c3].isActive ? d[c3].isActive = false : (d[c3].destroy(), d.splice(c3, 1));
                b2.dataLabel = d[0];
                b2.dataLabels = d;
              });
            D(this, "afterDrawDataLabels");
          }
          function l(b, c2, a4, e2, f3, g) {
            const d = this.chart, h2 = c2.align, l2 = c2.verticalAlign, k2 = b.box ? 0 : b.padding || 0;
            let { x: m = 0, y: n2 = 0 } = c2, u2, v2;
            u2 = (a4.x || 0) + k2;
            0 > u2 && ("right" === h2 && 0 <= m ? (c2.align = "left", c2.inside = true) : m -= u2, v2 = true);
            u2 = (a4.x || 0) + e2.width - k2;
            u2 > d.plotWidth && ("left" === h2 && 0 >= m ? (c2.align = "right", c2.inside = true) : m += d.plotWidth - u2, v2 = true);
            u2 = a4.y + k2;
            0 > u2 && ("bottom" === l2 && 0 <= n2 ? (c2.verticalAlign = "top", c2.inside = true) : n2 -= u2, v2 = true);
            u2 = (a4.y || 0) + e2.height - k2;
            u2 > d.plotHeight && ("top" === l2 && 0 >= n2 ? (c2.verticalAlign = "bottom", c2.inside = true) : n2 += d.plotHeight - u2, v2 = true);
            v2 && (c2.x = m, c2.y = n2, b.placed = !g, b.align(c2, void 0, f3));
            return v2;
          }
          function v(b, c2) {
            let d = [], a4;
            if (t(b) && !t(c2))
              d = b.map(function(b2) {
                return k(b2, c2);
              });
            else if (t(c2) && !t(b))
              d = c2.map(function(c3) {
                return k(b, c3);
              });
            else if (!t(b) && !t(c2))
              d = k(b, c2);
            else if (t(b) && t(c2))
              for (a4 = Math.max(b.length, c2.length); a4--; )
                d[a4] = k(b[a4], c2[a4]);
            return d;
          }
          function z(b, c2, a4, e2, f3) {
            const d = this.chart, g = d.inverted, h2 = this.xAxis, l2 = h2.reversed, k2 = g ? c2.height / 2 : c2.width / 2;
            b = (b = b.pointWidth) ? b / 2 : 0;
            c2.startXPos = g ? f3.x : l2 ? -k2 - b : h2.width - k2 + b;
            c2.startYPos = g ? l2 ? this.yAxis.height - k2 + b : -k2 - b : f3.y;
            e2 ? "hidden" === c2.visibility && (c2.show(), c2.attr({ opacity: 0 }).animate({ opacity: 1 })) : c2.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, c2.hide);
            d.hasRendered && (a4 && c2.attr({ x: c2.startXPos, y: c2.startYPos }), c2.placed = true);
          }
          const u = [];
          c.compose = function(b) {
            G.pushUnique(u, b) && (b = b.prototype, b.initDataLabelsGroup = C, b.initDataLabels = E, b.alignDataLabel = a3, b.drawDataLabels = e, b.justifyDataLabel = l, b.setDataLabelStartPos = z);
          };
        })(f || (f = {}));
        "";
        return f;
      });
      K(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { series: r } = x, { merge: y, pick: A } = G;
        var F;
        (function(x2) {
          function t(a3, p, n, h, f) {
            let c = this.chart.inverted;
            var g = a3.series;
            let k = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;
            g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;
            var q2 = a3.dlBox || a3.shapeArgs;
            let E = A(a3.below, a3.plotY > A(this.translatedThreshold, g)), e = A(n.inside, !!this.options.stacking);
            q2 && (h = y(q2), 0 > h.y && (h.height += h.y, h.y = 0), q2 = h.y + h.height - g, 0 < q2 && q2 < h.height && (h.height -= q2), c && (h = { x: g - h.y - h.height, y: k - h.x - h.width, width: h.height, height: h.width }), e || (c ? (h.x += E ? 0 : h.width, h.width = 0) : (h.y += E ? h.height : 0, h.height = 0)));
            n.align = A(n.align, !c || e ? "center" : E ? "right" : "left");
            n.verticalAlign = A(n.verticalAlign, c || e ? "middle" : E ? "top" : "bottom");
            r.prototype.alignDataLabel.call(this, a3, p, n, h, f);
            n.inside && a3.contrastColor && p.css({ color: a3.contrastColor });
          }
          const q = [];
          x2.compose = function(k) {
            a2.compose(r);
            G.pushUnique(q, k) && (k.prototype.alignDataLabel = t);
          };
        })(F || (F = {}));
        return F;
      });
      K(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { extend: r, merge: y } = G;
        class A extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
        }
        A.defaultOptions = y(a2.defaultOptions, {});
        r(A.prototype, { inverted: true });
        x.registerSeriesType("bar", A);
        "";
        return A;
      });
      K(a, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
        "";
        return { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } };
      });
      K(
        a,
        "Series/Scatter/ScatterSeries.js",
        [a["Series/Scatter/ScatterSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, x, G) {
          const { column: r, line: y } = x.seriesTypes, { addEvent: A, extend: F, merge: D } = G;
          class t extends y {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = void 0;
            }
            applyJitter() {
              const a3 = this, k = this.options.jitter, p = this.points.length;
              k && this.points.forEach(function(n, h) {
                ["x", "y"].forEach(function(f, c) {
                  let g = "plot" + f.toUpperCase(), q, C;
                  if (k[f] && !n.isNull) {
                    var r2 = a3[f + "Axis"];
                    C = k[f] * r2.transA;
                    r2 && !r2.isLog && (q = Math.max(0, n[g] - C), r2 = Math.min(r2.len, n[g] + C), c = 1e4 * Math.sin(h + c * p), c -= Math.floor(c), n[g] = q + (r2 - q) * c, "x" === f && (n.clientX = n.plotX));
                  }
                });
              });
            }
            drawGraph() {
              this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
            }
          }
          t.defaultOptions = D(y.defaultOptions, a2);
          F(t.prototype, { drawTracker: r.prototype.drawTracker, sorted: false, requireSorting: false, noSharedTooltip: true, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: false });
          A(t, "afterTranslate", function() {
            this.applyJitter();
          });
          x.registerSeriesType("scatter", t);
          return t;
        }
      );
      K(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { deg2rad: r } = a2, { fireEvent: y, isNumber: A, pick: F, relativeLength: D } = G;
        var t;
        (function(a3) {
          a3.getCenter = function() {
            var a4 = this.options, p = this.chart;
            const n = 2 * (a4.slicedOffset || 0), h = p.plotWidth - 2 * n, f = p.plotHeight - 2 * n;
            var c = a4.center;
            const g = Math.min(h, f), q = a4.thickness;
            var C = a4.size;
            let r2 = a4.innerSize || 0;
            "string" === typeof C && (C = parseFloat(C));
            "string" === typeof r2 && (r2 = parseFloat(r2));
            a4 = [F(c[0], "50%"), F(c[1], "50%"), F(C && 0 > C ? void 0 : a4.size, "100%"), F(r2 && 0 > r2 ? void 0 : a4.innerSize || 0, "0%")];
            !p.angular || this instanceof x || (a4[3] = 0);
            for (c = 0; 4 > c; ++c)
              C = a4[c], p = 2 > c || 2 === c && /%$/.test(C), a4[c] = D(C, [h, f, g, a4[2]][c]) + (p ? n : 0);
            a4[3] > a4[2] && (a4[3] = a4[2]);
            A(q) && 2 * q < a4[2] && 0 < q && (a4[3] = a4[2] - 2 * q);
            y(this, "afterGetCenter", { positions: a4 });
            return a4;
          };
          a3.getStartAndEndRadians = function(a4, p) {
            a4 = A(a4) ? a4 : 0;
            p = A(p) && p > a4 && 360 > p - a4 ? p : a4 + 360;
            return { start: r * (a4 + -90), end: r * (p + -90) };
          };
        })(t || (t = {}));
        "";
        return t;
      });
      K(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        const { setAnimation: r } = a2, { addEvent: y, defined: A, extend: F, isNumber: D, pick: t, relativeLength: q } = G;
        class k extends x {
          constructor() {
            super(...arguments);
            this.series = this.options = this.labelDistance = void 0;
          }
          getConnectorPath() {
            const a3 = this.labelPosition, k2 = this.series.options.dataLabels, h = this.connectorShapes;
            let f = k2.connectorShape;
            h[f] && (f = h[f]);
            return f.call(
              this,
              { x: a3.computed.x, y: a3.computed.y, alignment: a3.alignment },
              a3.connectorPosition,
              k2
            );
          }
          getTranslate() {
            return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
          }
          haloPath(a3) {
            const k2 = this.shapeArgs;
            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(k2.x, k2.y, k2.r + a3, k2.r + a3, { innerR: k2.r - 1, start: k2.start, end: k2.end, borderRadius: k2.borderRadius });
          }
          init() {
            super.init.apply(this, arguments);
            this.name = t(this.name, "Slice");
            const a3 = (a4) => {
              this.slice("select" === a4.type);
            };
            y(this, "select", a3);
            y(
              this,
              "unselect",
              a3
            );
            return this;
          }
          isValid() {
            return D(this.y) && 0 <= this.y;
          }
          setVisible(a3, k2) {
            const h = this.series, f = h.chart, c = h.options.ignoreHiddenPoint;
            k2 = t(k2, c);
            a3 !== this.visible && (this.visible = this.options.visible = a3 = "undefined" === typeof a3 ? !this.visible : a3, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector"].forEach((c2) => {
              if (this[c2])
                this[c2][a3 ? "show" : "hide"](a3);
            }), this.legendItem && f.legend.colorizeItem(this, a3), a3 || "hover" !== this.state || this.setState(""), c && (h.isDirty = true), k2 && f.redraw());
          }
          slice(a3, k2, h) {
            const f = this.series;
            r(h, f.chart);
            t(k2, true);
            this.sliced = this.options.sliced = A(a3) ? a3 : !this.sliced;
            f.options.data[f.data.indexOf(this)] = this.options;
            this.graphic && this.graphic.animate(this.getTranslate());
          }
        }
        F(k.prototype, { connectorShapes: { fixedOffset: function(a3, k2, h) {
          const f = k2.breakAt;
          k2 = k2.touchingSliceAt;
          return [["M", a3.x, a3.y], h.softConnector ? ["C", a3.x + ("left" === a3.alignment ? -5 : 5), a3.y, 2 * f.x - k2.x, 2 * f.y - k2.y, f.x, f.y] : ["L", f.x, f.y], ["L", k2.x, k2.y]];
        }, straight: function(a3, k2) {
          k2 = k2.touchingSliceAt;
          return [
            ["M", a3.x, a3.y],
            ["L", k2.x, k2.y]
          ];
        }, crookedLine: function(a3, k2, h) {
          const { breakAt: f, touchingSliceAt: c } = k2;
          ({ series: k2 } = this);
          const [g, n, p] = k2.center, r2 = p / 2, e = k2.chart.plotWidth, l = k2.chart.plotLeft;
          k2 = "left" === a3.alignment;
          const { x: v, y: z } = a3;
          h.crookDistance ? (a3 = q(h.crookDistance, 1), a3 = k2 ? g + r2 + (e + l - g - r2) * (1 - a3) : l + (g - r2) * a3) : a3 = g + (n - z) * Math.tan((this.angle || 0) - Math.PI / 2);
          h = [["M", v, z]];
          (k2 ? a3 <= v && a3 >= f.x : a3 >= v && a3 <= f.x) && h.push(["L", a3, z]);
          h.push(["L", f.x, f.y], ["L", c.x, c.y]);
          return h;
        } } });
        return k;
      });
      K(a, "Series/Pie/PieSeriesDefaults.js", [], function() {
        "";
        return {
          borderRadius: 3,
          center: [null, null],
          clip: false,
          colorByPoint: true,
          dataLabels: { allowOverlap: true, connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: true, formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          }, softConnector: true, x: 0 },
          fillColor: void 0,
          ignoreHiddenPoint: true,
          inactiveOtherPoints: true,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: false,
          slicedOffset: 10,
          stickyTracking: false,
          tooltip: { followPointer: true },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } }
        };
      });
      K(a, "Series/Pie/PieSeries.js", [a["Series/CenteredUtilities.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Series/Pie/PiePoint.js"], a["Series/Pie/PieSeriesDefaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A, F, D, t) {
        const { getStartAndEndRadians: q } = a2;
        ({ noop: G } = G);
        const { clamp: k, extend: p, fireEvent: n, merge: h, pick: f, relativeLength: c } = t;
        class g extends A {
          constructor() {
            super(...arguments);
            this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;
          }
          animate(c2) {
            const a3 = this, g2 = a3.points, e = a3.startAngleRad;
            c2 || g2.forEach(function(c3) {
              const g3 = c3.graphic, h2 = c3.shapeArgs;
              g3 && h2 && (g3.attr({ r: f(c3.startR, a3.center && a3.center[3] / 2), start: e, end: e }), g3.animate({ r: h2.r, start: h2.start, end: h2.end }, a3.options.animation));
            });
          }
          drawEmpty() {
            const c2 = this.startAngleRad, a3 = this.endAngleRad, f2 = this.options;
            let e, g2;
            0 === this.total && this.center ? (e = this.center[0], g2 = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(
              e,
              g2,
              this.center[1] / 2,
              0,
              c2,
              a3
            ).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: D.arc(e, g2, this.center[2] / 2, 0, { start: c2, end: a3, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": f2.borderWidth, fill: f2.fillColor || "none", stroke: f2.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy());
          }
          drawPoints() {
            const c2 = this.chart.renderer;
            this.points.forEach(function(a3) {
              a3.graphic && a3.hasNewShapeType() && (a3.graphic = a3.graphic.destroy());
              a3.graphic || (a3.graphic = c2[a3.shapeType](a3.shapeArgs).add(a3.series.group), a3.delayedRendering = true);
            });
          }
          generatePoints() {
            super.generatePoints();
            this.updateTotals();
          }
          getX(c2, a3, f2) {
            const e = this.center, g2 = this.radii ? this.radii[f2.index] || 0 : e[2] / 2;
            c2 = Math.asin(k((c2 - e[1]) / (g2 + f2.labelDistance), -1, 1));
            return e[0] + (a3 ? -1 : 1) * Math.cos(c2) * (g2 + f2.labelDistance) + (0 < f2.labelDistance ? (a3 ? -1 : 1) * this.options.dataLabels.padding : 0);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          redrawPoints() {
            const c2 = this, a3 = c2.chart;
            let f2, e, g2, k2;
            this.drawEmpty();
            c2.group && !a3.styledMode && c2.group.shadow(c2.options.shadow);
            c2.points.forEach(function(l) {
              const n2 = {};
              e = l.graphic;
              !l.isNull && e ? (k2 = l.shapeArgs, f2 = l.getTranslate(), a3.styledMode || (g2 = c2.pointAttribs(l, l.selected && "select")), l.delayedRendering ? (e.setRadialReference(c2.center).attr(k2).attr(f2), a3.styledMode || e.attr(g2).attr({ "stroke-linejoin": "round" }), l.delayedRendering = false) : (e.setRadialReference(c2.center), a3.styledMode || h(true, n2, g2), h(true, n2, k2, f2), e.animate(n2)), e.attr({ visibility: l.visible ? "inherit" : "hidden" }), e.addClass(l.getClassName(), true)) : e && (l.graphic = e.destroy());
            });
          }
          sortByAngle(c2, a3) {
            c2.sort(function(c3, e) {
              return "undefined" !== typeof c3.angle && (e.angle - c3.angle) * a3;
            });
          }
          translate(a3) {
            n(this, "translate");
            this.generatePoints();
            var g2 = this.options;
            const h2 = g2.slicedOffset, e = h2 + (g2.borderWidth || 0);
            var l = q(g2.startAngle, g2.endAngle);
            const k2 = this.startAngleRad = l.start;
            l = (this.endAngleRad = l.end) - k2;
            const p2 = this.points, u = g2.dataLabels.distance;
            g2 = g2.ignoreHiddenPoint;
            const b = p2.length;
            let d, m, w, r = 0;
            a3 || (this.center = a3 = this.getCenter());
            for (m = 0; m < b; m++) {
              w = p2[m];
              var B = k2 + r * l;
              !w.isValid() || g2 && !w.visible || (r += w.percentage / 100);
              var t2 = k2 + r * l;
              var y2 = {
                x: a3[0],
                y: a3[1],
                r: a3[2] / 2,
                innerR: a3[3] / 2,
                start: Math.round(1e3 * B) / 1e3,
                end: Math.round(1e3 * t2) / 1e3
              };
              w.shapeType = "arc";
              w.shapeArgs = y2;
              w.labelDistance = f(w.options.dataLabels && w.options.dataLabels.distance, u);
              w.labelDistance = c(w.labelDistance, y2.r);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w.labelDistance);
              t2 = (t2 + B) / 2;
              t2 > 1.5 * Math.PI ? t2 -= 2 * Math.PI : t2 < -Math.PI / 2 && (t2 += 2 * Math.PI);
              w.slicedTranslation = { translateX: Math.round(Math.cos(t2) * h2), translateY: Math.round(Math.sin(t2) * h2) };
              y2 = Math.cos(t2) * a3[2] / 2;
              d = Math.sin(t2) * a3[2] / 2;
              w.tooltipPos = [a3[0] + 0.7 * y2, a3[1] + 0.7 * d];
              w.half = t2 < -Math.PI / 2 || t2 > Math.PI / 2 ? 1 : 0;
              w.angle = t2;
              B = Math.min(e, w.labelDistance / 5);
              w.labelPosition = { natural: { x: a3[0] + y2 + Math.cos(t2) * w.labelDistance, y: a3[1] + d + Math.sin(t2) * w.labelDistance }, computed: {}, alignment: 0 > w.labelDistance ? "center" : w.half ? "right" : "left", connectorPosition: { breakAt: { x: a3[0] + y2 + Math.cos(t2) * B, y: a3[1] + d + Math.sin(t2) * B }, touchingSliceAt: { x: a3[0] + y2, y: a3[1] + d } } };
            }
            n(this, "afterTranslate");
          }
          updateTotals() {
            const c2 = this.points, a3 = c2.length, f2 = this.options.ignoreHiddenPoint;
            let e, g2, h2 = 0;
            for (e = 0; e < a3; e++)
              g2 = c2[e], !g2.isValid() || f2 && !g2.visible || (h2 += g2.y);
            this.total = h2;
            for (e = 0; e < a3; e++)
              g2 = c2[e], g2.percentage = 0 < h2 && (g2.visible || !f2) ? g2.y / h2 * 100 : 0, g2.total = h2;
          }
        }
        g.defaultOptions = h(A.defaultOptions, y);
        p(g.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawTracker: x.prototype.drawTracker, getCenter: a2.getCenter, getSymbol: G, isCartesian: false, noSharedTooltip: true, pointAttribs: x.prototype.pointAttribs, pointClass: I, requireSorting: false, searchPoint: G, trackerGroups: ["group", "dataLabelsGroup"] });
        F.registerSeriesType(
          "pie",
          g
        );
        return g;
      });
      K(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y) {
        const { noop: r } = x, { distribute: F } = G, { series: D } = I, { arrayMax: t, clamp: q, defined: k, merge: p, pick: n, relativeLength: h } = y;
        var f;
        (function(c) {
          function f2() {
            const c2 = this, a3 = c2.data, e2 = c2.chart, f3 = c2.options.dataLabels || {}, b = f3.connectorPadding, d = e2.plotWidth, g = e2.plotHeight, h2 = e2.plotLeft, q2 = Math.round(e2.chartWidth / 3), r2 = c2.center, B2 = r2[2] / 2, C2 = r2[1], E2 = [[], []], y2 = [0, 0, 0, 0], x2 = c2.dataLabelPositioners;
            let A, G2, I2, K2, V, T, L, Q, S, O, U, Z;
            c2.visible && (f3.enabled || c2._hasPointLabels) && (a3.forEach(function(b2) {
              b2.dataLabel && b2.visible && b2.dataLabel.shortened && (b2.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), b2.dataLabel.shortened = false);
            }), D.prototype.drawDataLabels.apply(c2), a3.forEach(function(b2) {
              b2.dataLabel && (b2.visible ? (E2[b2.half].push(b2), b2.dataLabel._pos = null, !k(f3.style.width) && !k(b2.options.dataLabels && b2.options.dataLabels.style && b2.options.dataLabels.style.width) && b2.dataLabel.getBBox().width > q2 && (b2.dataLabel.css({ width: Math.round(0.7 * q2) + "px" }), b2.dataLabel.shortened = true)) : (b2.dataLabel = b2.dataLabel.destroy(), b2.dataLabels && 1 === b2.dataLabels.length && delete b2.dataLabels));
            }), E2.forEach((a4, l) => {
              const m = a4.length, u = [];
              let v, p2 = 0;
              if (m) {
                c2.sortByAngle(a4, l - 0.5);
                if (0 < c2.maxLabelDistance) {
                  var q3 = Math.max(0, C2 - B2 - c2.maxLabelDistance);
                  v = Math.min(C2 + B2 + c2.maxLabelDistance, e2.plotHeight);
                  a4.forEach(function(b2) {
                    0 < b2.labelDistance && b2.dataLabel && (b2.top = Math.max(
                      0,
                      C2 - B2 - b2.labelDistance
                    ), b2.bottom = Math.min(C2 + B2 + b2.labelDistance, e2.plotHeight), p2 = b2.dataLabel.getBBox().height || 21, b2.distributeBox = { target: b2.labelPosition.natural.y - b2.top + p2 / 2, size: p2, rank: b2.y }, u.push(b2.distributeBox));
                  });
                  q3 = v + p2 - q3;
                  F(u, q3, q3 / 5);
                }
                for (U = 0; U < m; U++) {
                  A = a4[U];
                  T = A.labelPosition;
                  K2 = A.dataLabel;
                  O = false === A.visible ? "hidden" : "inherit";
                  S = q3 = T.natural.y;
                  u && k(A.distributeBox) && ("undefined" === typeof A.distributeBox.pos ? O = "hidden" : (L = A.distributeBox.size, S = x2.radialDistributionY(A)));
                  delete A.positionIndex;
                  if (f3.justify)
                    Q = x2.justify(A, B2, r2);
                  else
                    switch (f3.alignTo) {
                      case "connectors":
                        Q = x2.alignToConnectors(a4, l, d, h2);
                        break;
                      case "plotEdges":
                        Q = x2.alignToPlotEdges(K2, l, d, h2);
                        break;
                      default:
                        Q = x2.radialDistributionX(c2, A, S, q3);
                    }
                  K2._attr = { visibility: O, align: T.alignment };
                  Z = A.options.dataLabels || {};
                  K2._pos = { x: Q + n(Z.x, f3.x) + ({ left: b, right: -b }[T.alignment] || 0), y: S + n(Z.y, f3.y) - K2.getBBox().height / 2 };
                  T && (T.computed.x = Q, T.computed.y = S);
                  n(f3.crop, true) && (V = K2.getBBox().width, q3 = null, Q - V < b && 1 === l ? (q3 = Math.round(V - Q + b), y2[3] = Math.max(q3, y2[3])) : Q + V > d - b && 0 === l && (q3 = Math.round(Q + V - d + b), y2[1] = Math.max(q3, y2[1])), 0 > S - L / 2 ? y2[0] = Math.max(Math.round(-S + L / 2), y2[0]) : S + L / 2 > g && (y2[2] = Math.max(Math.round(S + L / 2 - g), y2[2])), K2.sideOverflow = q3);
                }
              }
            }), 0 === t(y2) || this.verifyDataLabelOverflow(y2)) && (this.placeDataLabels(), this.points.forEach(function(b2) {
              Z = p(f3, b2.options.dataLabels);
              if (G2 = n(Z.connectorWidth, 1)) {
                let a4;
                I2 = b2.connector;
                if ((K2 = b2.dataLabel) && K2._pos && b2.visible && 0 < b2.labelDistance) {
                  O = K2._attr.visibility;
                  if (a4 = !I2)
                    b2.connector = I2 = e2.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b2.colorIndex + (b2.className ? " " + b2.className : "")).add(c2.dataLabelsGroup), e2.styledMode || I2.attr({ "stroke-width": G2, stroke: Z.connectorColor || b2.color || "#666666" });
                  I2[a4 ? "attr" : "animate"]({ d: b2.getConnectorPath() });
                  I2.attr("visibility", O);
                } else
                  I2 && (b2.connector = I2.destroy());
              }
            }));
          }
          function B() {
            this.points.forEach(function(c2) {
              let a3 = c2.dataLabel, e2;
              a3 && c2.visible && ((e2 = a3._pos) ? (a3.sideOverflow && (a3._attr.width = Math.max(a3.getBBox().width - a3.sideOverflow, 0), a3.css({ width: a3._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), a3.shortened = true), a3.attr(a3._attr), a3[a3.moved ? "animate" : "attr"](e2), a3.moved = true) : a3 && a3.attr({ y: -9999 }));
              delete c2.distributeBox;
            }, this);
          }
          function C(c2) {
            let a3 = this.center, e2 = this.options, f3 = e2.center, b = e2.minSize || 80, d, g = null !== e2.size;
            g || (null !== f3[0] ? d = Math.max(a3[2] - Math.max(c2[1], c2[3]), b) : (d = Math.max(a3[2] - c2[1] - c2[3], b), a3[0] += (c2[3] - c2[1]) / 2), null !== f3[1] ? d = q(d, b, a3[2] - Math.max(c2[0], c2[2])) : (d = q(d, b, a3[2] - c2[0] - c2[2]), a3[1] += (c2[0] - c2[2]) / 2), d < a3[2] ? (a3[2] = d, a3[3] = Math.min(e2.thickness ? Math.max(0, d - 2 * e2.thickness) : Math.max(0, h(e2.innerSize || 0, d)), d), this.translate(a3), this.drawDataLabels && this.drawDataLabels()) : g = true);
            return g;
          }
          const E = [], e = { radialDistributionY: function(c2) {
            return c2.top + c2.distributeBox.pos;
          }, radialDistributionX: function(c2, a3, e2, f3) {
            return c2.getX(e2 < a3.top + 2 || e2 > a3.bottom - 2 ? f3 : e2, a3.half, a3);
          }, justify: function(c2, a3, e2) {
            return e2[0] + (c2.half ? -1 : 1) * (a3 + c2.labelDistance);
          }, alignToPlotEdges: function(c2, a3, e2, f3) {
            c2 = c2.getBBox().width;
            return a3 ? c2 + f3 : e2 - c2 - f3;
          }, alignToConnectors: function(c2, a3, e2, f3) {
            let b = 0, d;
            c2.forEach(function(c3) {
              d = c3.dataLabel.getBBox().width;
              d > b && (b = d);
            });
            return a3 ? b + f3 : e2 - b - f3;
          } };
          c.compose = function(c2) {
            a2.compose(D);
            y.pushUnique(E, c2) && (c2 = c2.prototype, c2.dataLabelPositioners = e, c2.alignDataLabel = r, c2.drawDataLabels = f2, c2.placeDataLabels = B, c2.verifyDataLabelOverflow = C);
          };
        })(f || (f = {}));
        return f;
      });
      K(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function(a2, x) {
        function r(a3, k) {
          let p, n = false;
          a3 && (p = a3.newOpacity, a3.oldOpacity !== p && (a3.alignAttr && a3.placed ? (a3[p ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), n = true, a3.alignAttr.opacity = p, a3[a3.isOld ? "animate" : "attr"](a3.alignAttr, null, function() {
            k.styledMode || a3.css({ pointerEvents: p ? "auto" : "none" });
          }), y(k, "afterHideOverlappingLabel")) : a3.attr({ opacity: p })), a3.isOld = true);
          return n;
        }
        const { addEvent: I, fireEvent: y, isArray: A, isNumber: F, objectEach: D, pick: t } = x;
        I(a2, "render", function() {
          let a3 = this, k = [];
          (this.labelCollectors || []).forEach(function(a4) {
            k = k.concat(a4());
          });
          (this.yAxis || []).forEach(function(a4) {
            a4.stacking && a4.options.stackLabels && !a4.options.stackLabels.allowOverlap && D(a4.stacking.stacks, function(a5) {
              D(a5, function(a6) {
                a6.label && k.push(a6.label);
              });
            });
          });
          (this.series || []).forEach(function(p) {
            var n = p.options.dataLabels;
            p.visible && (false !== n.enabled || p._hasPointLabels) && (n = (h) => h.forEach((f) => {
              f.visible && (A(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function(c) {
                const g = c.options;
                c.labelrank = t(g.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);
                g.allowOverlap ? (c.oldOpacity = c.opacity, c.newOpacity = 1, r(c, a3)) : k.push(c);
              });
            }), n(p.nodes || []), n(p.points));
          });
          this.hideOverlappingLabels(k);
        });
        a2.prototype.hideOverlappingLabels = function(a3) {
          let k = this, p = a3.length, n = k.renderer;
          var h;
          let f;
          let c, g, q, C = false;
          var t2 = function(c2) {
            let a4, e;
            var f2;
            let g2 = c2.box ? 0 : c2.padding || 0, b = f2 = 0, d, h2;
            if (c2 && (!c2.alignAttr || c2.placed))
              return a4 = c2.alignAttr || { x: c2.attr("x"), y: c2.attr("y") }, e = c2.parentGroup, c2.width || (f2 = c2.getBBox(), c2.width = f2.width, c2.height = f2.height, f2 = n.fontMetrics(c2.element).h), d = c2.width - 2 * g2, (h2 = { left: "0", center: "0.5", right: "1" }[c2.alignValue]) ? b = +h2 * d : F(c2.x) && Math.round(c2.x) !== c2.translateX && (b = c2.x - c2.translateX), { x: a4.x + (e.translateX || 0) + g2 - (b || 0), y: a4.y + (e.translateY || 0) + g2 - f2, width: c2.width - 2 * g2, height: c2.height - 2 * g2 };
          };
          for (f = 0; f < p; f++)
            if (h = a3[f])
              h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = t2(h);
          a3.sort(function(c2, a4) {
            return (a4.labelrank || 0) - (c2.labelrank || 0);
          });
          for (f = 0; f < p; f++)
            for (g = (t2 = a3[f]) && t2.absoluteBox, h = f + 1; h < p; ++h)
              q = (c = a3[h]) && c.absoluteBox, !g || !q || t2 === c || 0 === t2.newOpacity || 0 === c.newOpacity || "hidden" === t2.visibility || "hidden" === c.visibility || q.x >= g.x + g.width || q.x + q.width <= g.x || q.y >= g.y + g.height || q.y + q.height <= g.y || ((t2.labelrank < c.labelrank ? t2 : c).newOpacity = 0);
          a3.forEach(function(c2) {
            r(c2, k) && (C = true);
          });
          C && y(k, "afterHideAllOverlappingLabels");
        };
      });
      K(a, "Extensions/BorderRadius.js", [a["Core/Defaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A) {
        const { defaultOptions: r } = a2;
        ({ seriesTypes: a2 } = G);
        const { addEvent: D, extend: t, isObject: q, merge: k, relativeLength: p } = A, n = {
          radius: 0,
          scope: "stack",
          where: void 0
        }, h = (a3, c) => {
          q(a3) || (a3 = { radius: a3 || 0 });
          return k(n, c, a3);
        };
        if (-1 === I.symbolCustomAttribs.indexOf("borderRadius")) {
          I.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
          const f = y.prototype.symbols.arc;
          y.prototype.symbols.arc = function(c2, a3, h2, k2, e = {}) {
            c2 = f(c2, a3, h2, k2, e);
            const { innerR: g = 0, r: n2 = h2, start: q2 = 0, end: u = 0 } = e;
            if (e.open || !e.borderRadius)
              return c2;
            h2 = u - q2;
            a3 = Math.sin(h2 / 2);
            e = Math.max(Math.min(p(e.borderRadius || 0, n2 - g), (n2 - g) / 2, n2 * a3 / (1 + a3)), 0);
            h2 = Math.min(e, h2 / Math.PI * 2 * g);
            for (a3 = c2.length - 1; a3--; ) {
              {
                let f2 = void 0, g2 = void 0, l = void 0;
                k2 = c2;
                var b = a3, d = 1 < a3 ? h2 : e, m = k2[b], w = k2[b + 1];
                "Z" === w[0] && (w = k2[0]);
                "M" !== m[0] && "L" !== m[0] || "A" !== w[0] ? "A" !== m[0] || "M" !== w[0] && "L" !== w[0] || (l = w, g2 = m) : (l = m, g2 = w, f2 = true);
                if (l && g2 && g2.params) {
                  m = g2[1];
                  var r2 = g2[5];
                  w = g2.params;
                  const { start: c3, end: a4, cx: e2, cy: h3 } = w;
                  var B = r2 ? m - d : m + d;
                  const n3 = B ? Math.asin(d / B) : 0;
                  r2 = r2 ? n3 : -n3;
                  B *= Math.cos(n3);
                  f2 ? (w.start = c3 + r2, l[1] = e2 + B * Math.cos(c3), l[2] = h3 + B * Math.sin(c3), k2.splice(b + 1, 0, ["A", d, d, 0, 0, 1, e2 + m * Math.cos(w.start), h3 + m * Math.sin(w.start)])) : (w.end = a4 - r2, g2[6] = e2 + m * Math.cos(w.end), g2[7] = h3 + m * Math.sin(w.end), k2.splice(b + 1, 0, ["A", d, d, 0, 0, 1, e2 + B * Math.cos(a4), h3 + B * Math.sin(a4)]));
                  g2[4] = Math.abs(w.end - w.start) < Math.PI ? 0 : 1;
                }
              }
            }
            return c2;
          };
          const c = y.prototype.symbols.roundedRect;
          y.prototype.symbols.roundedRect = function(a3, f2, h2, k2, e = {}) {
            const g = c(a3, f2, h2, k2, e), { r: n2 = 0, brBoxHeight: p2 = k2, brBoxY: u = f2 } = e;
            var b = f2 - u, d = u + p2 - (f2 + k2);
            e = -0.1 < b - n2 ? 0 : n2;
            const m = -0.1 < d - n2 ? 0 : n2;
            var q2 = Math.max(e && b, 0);
            const r2 = Math.max(m && d, 0);
            d = [a3 + e, f2];
            b = [a3 + h2 - e, f2];
            const t2 = [a3 + h2, f2 + e], B = [a3 + h2, f2 + k2 - m], C = [a3 + h2 - m, f2 + k2], E = [a3 + m, f2 + k2], y2 = [a3, f2 + k2 - m], x2 = [a3, f2 + e];
            if (q2) {
              const c2 = Math.sqrt(Math.pow(e, 2) - Math.pow(e - q2, 2));
              d[0] -= c2;
              b[0] += c2;
              t2[1] = x2[1] = f2 + e - q2;
            }
            k2 < e - q2 && (q2 = Math.sqrt(Math.pow(e, 2) - Math.pow(e - q2 - k2, 2)), t2[0] = B[0] = a3 + h2 - e + q2, C[0] = Math.min(t2[0], C[0]), E[0] = Math.max(B[0], E[0]), y2[0] = x2[0] = a3 + e - q2, t2[1] = x2[1] = f2 + k2);
            r2 && (q2 = Math.sqrt(Math.pow(m, 2) - Math.pow(m - r2, 2)), C[0] += q2, E[0] -= q2, B[1] = y2[1] = f2 + k2 - m + r2);
            k2 < m - r2 && (k2 = Math.sqrt(Math.pow(m, 2) - Math.pow(m - r2 - k2, 2)), t2[0] = B[0] = a3 + h2 - m + k2, b[0] = Math.min(t2[0], b[0]), d[0] = Math.max(B[0], d[0]), y2[0] = x2[0] = a3 + m - k2, B[1] = y2[1] = f2);
            g.length = 0;
            g.push(["M", ...d], ["L", ...b], [
              "A",
              e,
              e,
              0,
              0,
              1,
              ...t2
            ], ["L", ...B], ["A", m, m, 0, 0, 1, ...C], ["L", ...E], ["A", m, m, 0, 0, 1, ...y2], ["L", ...x2], ["A", e, e, 0, 0, 1, ...d], ["Z"]);
            return g;
          };
          D(a2.pie, "afterTranslate", function() {
            const c2 = h(this.options.borderRadius);
            for (const a3 of this.points) {
              const f2 = a3.shapeArgs;
              f2 && (f2.borderRadius = p(c2.radius, (f2.r || 0) - (f2.innerR || 0)));
            }
          });
          D(x, "afterColumnTranslate", function() {
            var c2, a3;
            if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {
              const { options: g, yAxis: n2 } = this, B = "percent" === g.stacking;
              var f2 = null === (a3 = null === (c2 = r.plotOptions) || void 0 === c2 ? void 0 : c2[this.type]) || void 0 === a3 ? void 0 : a3.borderRadius;
              c2 = h(g.borderRadius, q(f2) ? f2 : {});
              a3 = n2.options.reversed;
              for (const h2 of this.points)
                if ({ shapeArgs: f2 } = h2, "roundedRect" === h2.shapeType && f2) {
                  const { width: b = 0, height: d = 0, y: l = 0 } = f2;
                  var k2 = l, e = d;
                  "stack" === c2.scope && h2.stackTotal && (k2 = n2.translate(B ? 100 : h2.stackTotal, false, true, false, true), e = n2.translate(g.threshold || 0, false, true, false, true), e = this.crispCol(0, Math.min(k2, e), 0, Math.abs(k2 - e)), k2 = e.y, e = e.height);
                  const u = -1 === (h2.negative ? -1 : 1) * (a3 ? -1 : 1);
                  let q2 = c2.where;
                  !q2 && this.is("waterfall") && Math.abs((h2.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (q2 = "all");
                  q2 || (q2 = "end");
                  const v = Math.min(p(c2.radius, b), b / 2, "all" === q2 ? d / 2 : Infinity) || 0;
                  "end" === q2 && (u && (k2 -= v), e += v);
                  t(f2, { brBoxHeight: e, brBoxY: k2, r: v });
                }
            }
          }, { order: 9 });
        }
        x = { optionsToObject: h };
        "";
        return x;
      });
      K(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function(a2) {
        const { diffObjects: r, extend: G, find: I, merge: y, pick: A, uniqueKey: F } = a2;
        var D;
        (function(t) {
          function q(a3, h) {
            const f = a3.condition;
            (f.callback || function() {
              return this.chartWidth <= A(f.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(f.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(f.minWidth, 0) && this.chartHeight >= A(f.minHeight, 0);
            }).call(this) && h.push(a3._id);
          }
          function k(a3, h) {
            const f = this.options.responsive;
            var c = this.currentResponsive;
            let g = [];
            !h && f && f.rules && f.rules.forEach((a4) => {
              "undefined" === typeof a4._id && (a4._id = F());
              this.matchResponsiveRule(a4, g);
            }, this);
            h = y(...g.map((a4) => I((f || {}).rules || [], (c2) => c2._id === a4)).map((a4) => a4 && a4.chartOptions));
            h.isResponsiveOptions = true;
            g = g.toString() || void 0;
            g !== (c && c.ruleIds) && (c && this.update(c.undoOptions, a3, true), g ? (c = r(h, this.options, true, this.collectionsWithUpdate), c.isResponsiveOptions = true, this.currentResponsive = { ruleIds: g, mergedOptions: h, undoOptions: c }, this.update(h, a3, true)) : this.currentResponsive = void 0);
          }
          const p = [];
          t.compose = function(n) {
            a2.pushUnique(p, n) && G(n.prototype, { matchResponsiveRule: q, setResponsive: k });
            return n;
          };
        })(D || (D = {}));
        "";
        "";
        return D;
      });
      K(a, "masters/highcharts.src.js", [
        a["Core/Globals.js"],
        a["Core/Utilities.js"],
        a["Core/Defaults.js"],
        a["Core/Animation/Fx.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Templating.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Renderer/HTML/HTMLElement.js"],
        a["Core/Renderer/HTML/HTMLRenderer.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Axis/DateTimeAxis.js"],
        a["Core/Axis/LogarithmicAxis.js"],
        a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
        a["Core/Axis/Tick.js"],
        a["Core/Tooltip.js"],
        a["Core/Series/Point.js"],
        a["Core/Pointer.js"],
        a["Core/Legend/Legend.js"],
        a["Core/Chart/Chart.js"],
        a["Core/Axis/Stacking/StackingAxis.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Series/Column/ColumnDataLabel.js"],
        a["Series/Pie/PieSeries.js"],
        a["Series/Pie/PieDataLabel.js"],
        a["Core/Series/DataLabel.js"],
        a["Core/Responsive.js"],
        a["Core/Color/Color.js"],
        a["Core/Time.js"]
      ], function(a2, x, G, I, y, A, F, D, t, q, k, p, n, h, f, c, g, B, C, E, e, l, v, z, u, b, d, m, w, M, H, N, K2, P) {
        a2.animate = y.animate;
        a2.animObject = y.animObject;
        a2.getDeferredAnimation = y.getDeferredAnimation;
        a2.setAnimation = y.setAnimation;
        a2.stop = y.stop;
        a2.timers = I.timers;
        a2.AST = A;
        a2.Axis = n;
        a2.Chart = l;
        a2.chart = l.chart;
        a2.Fx = I;
        a2.Legend = e;
        a2.PlotLineOrBand = c;
        a2.Point = C;
        a2.Pointer = E;
        a2.Series = u;
        a2.StackItem = z;
        a2.SVGElement = t;
        a2.SVGRenderer = q;
        a2.Templating = F;
        a2.Tick = g;
        a2.Time = P;
        a2.Tooltip = B;
        a2.Color = K2;
        a2.color = K2.parse;
        p.compose(q);
        k.compose(t);
        E.compose(l);
        e.compose(l);
        a2.defaultOptions = G.defaultOptions;
        a2.getOptions = G.getOptions;
        a2.time = G.defaultTime;
        a2.setOptions = G.setOptions;
        a2.dateFormat = F.dateFormat;
        a2.format = F.format;
        a2.numberFormat = F.numberFormat;
        a2.addEvent = x.addEvent;
        a2.arrayMax = x.arrayMax;
        a2.arrayMin = x.arrayMin;
        a2.attr = x.attr;
        a2.clearTimeout = x.clearTimeout;
        a2.correctFloat = x.correctFloat;
        a2.createElement = x.createElement;
        a2.css = x.css;
        a2.defined = x.defined;
        a2.destroyObjectProperties = x.destroyObjectProperties;
        a2.discardElement = x.discardElement;
        a2.distribute = D.distribute;
        a2.erase = x.erase;
        a2.error = x.error;
        a2.extend = x.extend;
        a2.extendClass = x.extendClass;
        a2.find = x.find;
        a2.fireEvent = x.fireEvent;
        a2.getMagnitude = x.getMagnitude;
        a2.getStyle = x.getStyle;
        a2.inArray = x.inArray;
        a2.isArray = x.isArray;
        a2.isClass = x.isClass;
        a2.isDOMElement = x.isDOMElement;
        a2.isFunction = x.isFunction;
        a2.isNumber = x.isNumber;
        a2.isObject = x.isObject;
        a2.isString = x.isString;
        a2.keys = x.keys;
        a2.merge = x.merge;
        a2.normalizeTickInterval = x.normalizeTickInterval;
        a2.objectEach = x.objectEach;
        a2.offset = x.offset;
        a2.pad = x.pad;
        a2.pick = x.pick;
        a2.pInt = x.pInt;
        a2.relativeLength = x.relativeLength;
        a2.removeEvent = x.removeEvent;
        a2.seriesType = b.seriesType;
        a2.splat = x.splat;
        a2.stableSort = x.stableSort;
        a2.syncTimeout = x.syncTimeout;
        a2.timeUnits = x.timeUnits;
        a2.uniqueKey = x.uniqueKey;
        a2.useSerialIds = x.useSerialIds;
        a2.wrap = x.wrap;
        m.compose(d);
        H.compose(u);
        h.compose(n);
        f.compose(n);
        M.compose(w);
        c.compose(n);
        N.compose(l);
        v.compose(n, l, u);
        B.compose(E);
        return a2;
      });
      K(a, "Core/Axis/Color/ColorAxisComposition.js", [a["Core/Color/Color.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { parse: r } = a2, { addEvent: I, extend: y, merge: A, pick: F, splat: D } = x;
        var t;
        (function(a3) {
          function k() {
            const a4 = this.options;
            this.colorAxis = [];
            a4.colorAxis && (a4.colorAxis = D(a4.colorAxis), a4.colorAxis.forEach((a5) => {
              new v(this, a5);
            }));
          }
          function q(a4) {
            const c2 = (b2) => {
              b2 = a4.allItems.indexOf(b2);
              -1 !== b2 && (this.destroyItem(a4.allItems[b2]), a4.allItems.splice(b2, 1));
            };
            let b = [], d, e2;
            (this.chart.colorAxis || []).forEach(function(a5) {
              (d = a5.options) && d.showInLegend && (d.dataClasses && d.visible ? b = b.concat(a5.getDataClassLegendSymbols()) : d.visible && b.push(a5), a5.series.forEach(function(b2) {
                if (!b2.options.showInLegend || d.dataClasses)
                  "point" === b2.options.legendType ? b2.points.forEach(function(b3) {
                    c2(b3);
                  }) : c2(b2);
              }));
            });
            for (e2 = b.length; e2--; )
              a4.allItems.unshift(b[e2]);
          }
          function n(a4) {
            a4.visible && a4.item.legendColor && a4.item.legendItem.symbol.attr({ fill: a4.item.legendColor });
          }
          function h() {
            const a4 = this.chart.colorAxis;
            a4 && a4.forEach(function(a5, b, c2) {
              a5.update({}, c2);
            });
          }
          function f() {
            (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
          }
          function c() {
            const a4 = this.axisTypes;
            a4 ? -1 === a4.indexOf("colorAxis") && a4.push("colorAxis") : this.axisTypes = ["colorAxis"];
          }
          function g(a4) {
            const c2 = this, b = a4 ? "show" : "hide";
            c2.visible = c2.options.visible = !!a4;
            ["graphic", "dataLabel"].forEach(function(a5) {
              if (c2[a5])
                c2[a5][b]();
            });
            this.series.buildKDTree();
          }
          function t2() {
            const a4 = this, c2 = this.options.nullColor, b = this.colorAxis, d = this.colorKey;
            (this.data.length ? this.data : this.points).forEach((e2) => {
              var f2 = e2.getNestedProperty(d);
              (f2 = e2.options.color || (e2.isNull || null === e2.value ? c2 : b && "undefined" !== typeof f2 ? b.toColor(f2, e2) : e2.color || a4.color)) && e2.color !== f2 && (e2.color = f2, "point" === a4.options.legendType && e2.legendItem && e2.legendItem.label && a4.chart.legend.colorizeItem(e2, e2.visible));
            });
          }
          function C(a4) {
            const c2 = a4.prototype.createAxis;
            a4.prototype.createAxis = function(b, a5) {
              if ("colorAxis" !== b)
                return c2.apply(this, arguments);
              const d = new v(this, A(a5.axis, { index: this[b].length, isX: false }));
              this.isDirtyLegend = true;
              this.axes.forEach(function(b2) {
                b2.series = [];
              });
              this.series.forEach(function(b2) {
                b2.bindAxes();
                b2.isDirtyData = true;
              });
              F(a5.redraw, true) && this.redraw(a5.animation);
              return d;
            };
          }
          function E() {
            this.elem.attr("fill", r(this.start).tweenTo(
              r(this.end),
              this.pos
            ), void 0, true);
          }
          function e() {
            this.elem.attr("stroke", r(this.start).tweenTo(r(this.end), this.pos), void 0, true);
          }
          const l = [];
          let v;
          a3.compose = function(a4, u, b, d, m) {
            v || (v = a4);
            x.pushUnique(l, u) && (a4 = u.prototype, a4.collectionsWithUpdate.push("colorAxis"), a4.collectionsWithInit.colorAxis = [a4.addColorAxis], I(u, "afterGetAxes", k), C(u));
            x.pushUnique(l, b) && (u = b.prototype, u.fillSetter = E, u.strokeSetter = e);
            x.pushUnique(l, d) && (I(d, "afterGetAllItems", q), I(d, "afterColorizeItem", n), I(d, "afterUpdate", h));
            x.pushUnique(l, m) && (y(m.prototype, { optionalAxis: "colorAxis", translateColors: t2 }), y(m.prototype.pointClass.prototype, { setVisible: g }), I(m, "afterTranslate", f, { order: 1 }), I(m, "bindAxes", c));
          };
          a3.pointSetVisible = g;
        })(t || (t = {}));
        return t;
      });
      K(a, "Core/Axis/Color/ColorAxisDefaults.js", [], function() {
        return { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineColor: "#ffffff", gridLineWidth: 1, tickPixelInterval: 72, startOnTick: true, endOnTick: true, offset: 0, marker: { animation: { duration: 50 }, width: 0.01, color: "#999999" }, labels: {
          distance: 8,
          overflow: "justify",
          rotation: 0
        }, minColor: "#e6e9ff", maxColor: "#0022ff", tickLength: 5, showInLegend: true };
      });
      K(a, "Core/Axis/Color/ColorAxis.js", [a["Core/Axis/Axis.js"], a["Core/Color/Color.js"], a["Core/Axis/Color/ColorAxisComposition.js"], a["Core/Axis/Color/ColorAxisDefaults.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A, F) {
        const { parse: r } = x, { series: t } = A, { extend: q, isArray: k, isNumber: p, merge: n, pick: h } = F;
        class f extends a2 {
          static compose(a3, g, h2, k2) {
            G.compose(
              f,
              a3,
              g,
              h2,
              k2
            );
          }
          constructor(a3, f2) {
            super(a3, f2);
            this.beforePadding = false;
            this.chart = void 0;
            this.coll = "colorAxis";
            this.stops = this.options = this.dataClasses = void 0;
            this.visible = true;
            this.init(a3, f2);
          }
          init(a3, g) {
            var c = a3.options.legend || {};
            const h2 = g.layout ? "vertical" !== g.layout : "vertical" !== c.layout, q2 = g.visible;
            c = n(f.defaultColorAxisOptions, g, { showEmpty: false, title: null, visible: c.enabled && false !== q2 });
            this.side = g.side || h2 ? 2 : 1;
            this.reversed = g.reversed || !h2;
            this.opposite = !h2;
            super.init(a3, c, "colorAxis");
            this.userOptions = g;
            k(a3.userOptions.colorAxis) && (a3.userOptions.colorAxis[this.index] = g);
            g.dataClasses && this.initDataClasses(g);
            this.initStops();
            this.horiz = h2;
            this.zoomEnabled = false;
          }
          initDataClasses(a3) {
            const c = this.chart, f2 = this.legendItem = this.legendItem || {}, h2 = a3.dataClasses.length, k2 = this.options;
            let e, l = 0, q2 = c.options.chart.colorCount;
            this.dataClasses = e = [];
            f2.labels = [];
            (a3.dataClasses || []).forEach(function(a4, f3) {
              a4 = n(a4);
              e.push(a4);
              if (c.styledMode || !a4.color)
                "category" === k2.dataClassColor ? (c.styledMode || (f3 = c.options.colors, q2 = f3.length, a4.color = f3[l]), a4.colorIndex = l, l++, l === q2 && (l = 0)) : a4.color = r(k2.minColor).tweenTo(r(k2.maxColor), 2 > h2 ? 0.5 : f3 / (h2 - 1));
            });
          }
          hasData() {
            return !!(this.tickPositions || []).length;
          }
          setTickPositions() {
            if (!this.dataClasses)
              return super.setTickPositions();
          }
          initStops() {
            this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
            this.stops.forEach(function(a3) {
              a3.color = r(a3[1]);
            });
          }
          setOptions(a3) {
            super.setOptions(a3);
            this.options.crosshair = this.options.marker;
          }
          setAxisSize() {
            var a3 = this.legendItem && this.legendItem.symbol;
            const g = this.chart;
            var h2 = g.options.legend || {};
            let k2, n2;
            a3 ? (this.left = h2 = a3.attr("x"), this.top = k2 = a3.attr("y"), this.width = n2 = a3.attr("width"), this.height = a3 = a3.attr("height"), this.right = g.chartWidth - h2 - n2, this.bottom = g.chartHeight - k2 - a3, this.len = this.horiz ? n2 : a3, this.pos = this.horiz ? h2 : k2) : this.len = (this.horiz ? h2.symbolWidth : h2.symbolHeight) || f.defaultLegendLength;
          }
          normalizedValue(a3) {
            this.logarithmic && (a3 = this.logarithmic.log2lin(a3));
            return 1 - (this.max - a3) / (this.max - this.min || 1);
          }
          toColor(a3, f2) {
            const c = this.dataClasses;
            var g = this.stops;
            let h2, e, k2, n2;
            if (c)
              for (n2 = c.length; n2--; ) {
                if (k2 = c[n2], h2 = k2.from, g = k2.to, ("undefined" === typeof h2 || a3 >= h2) && ("undefined" === typeof g || a3 <= g)) {
                  e = k2.color;
                  f2 && (f2.dataClass = n2, f2.colorIndex = k2.colorIndex);
                  break;
                }
              }
            else {
              a3 = this.normalizedValue(a3);
              for (n2 = g.length; n2-- && !(a3 > g[n2][0]); )
                ;
              h2 = g[n2] || g[n2 + 1];
              g = g[n2 + 1] || h2;
              a3 = 1 - (g[0] - a3) / (g[0] - h2[0] || 1);
              e = h2.color.tweenTo(g.color, a3);
            }
            return e;
          }
          getOffset() {
            const a3 = this.legendItem && this.legendItem.group, g = this.chart.axisOffset[this.side];
            if (a3) {
              this.axisParent = a3;
              super.getOffset();
              const c = this.chart.legend;
              c.allItems.forEach(function(a4) {
                a4 instanceof f && a4.drawLegendSymbol(c, a4);
              });
              c.render();
              this.chart.getMargins(true);
              this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width);
              this.chart.axisOffset[this.side] = g;
            }
          }
          setLegendColor() {
            var a3 = this.reversed, f2 = a3 ? 1 : 0;
            a3 = a3 ? 0 : 1;
            f2 = this.horiz ? [f2, 0, a3, 0] : [0, a3, 0, f2];
            this.legendColor = { linearGradient: { x1: f2[0], y1: f2[1], x2: f2[2], y2: f2[3] }, stops: this.stops };
          }
          drawLegendSymbol(a3, g) {
            var c;
            g = g.legendItem || {};
            const k2 = a3.padding, n2 = a3.options, e = this.options.labels, l = h(
              n2.itemDistance,
              10
            ), q2 = this.horiz, p2 = h(n2.symbolWidth, q2 ? f.defaultLegendLength : 12), u = h(n2.symbolHeight, q2 ? 12 : f.defaultLegendLength), b = h(n2.labelPadding, q2 ? 16 : 30);
            this.setLegendColor();
            g.symbol || (g.symbol = this.chart.renderer.symbol("roundedRect", 0, a3.baseline - 11, p2, u, { r: null !== (c = n2.symbolRadius) && void 0 !== c ? c : 3 }).attr({ zIndex: 1 }).add(g.group));
            g.labelWidth = p2 + k2 + (q2 ? l : h(e.x, e.distance) + this.maxLabelLength);
            g.labelHeight = u + k2 + (q2 ? b : 0);
          }
          setState(a3) {
            this.series.forEach(function(c) {
              c.setState(a3);
            });
          }
          setVisible() {
          }
          getSeriesExtremes() {
            const a3 = this.series;
            let f2;
            let k2, n2, q2 = a3.length, e, l;
            this.dataMin = Infinity;
            for (this.dataMax = -Infinity; q2--; ) {
              n2 = a3[q2];
              f2 = n2.colorKey = h(n2.options.colorKey, n2.colorKey, n2.pointValKey, n2.zoneAxis, "y");
              var p2 = n2.pointArrayMap;
              k2 = n2[f2 + "Min"] && n2[f2 + "Max"];
              if (n2[f2 + "Data"])
                var r2 = n2[f2 + "Data"];
              else if (p2) {
                if (r2 = [], p2 = p2.indexOf(f2), e = n2.yData, 0 <= p2 && e)
                  for (l = 0; l < e.length; l++)
                    r2.push(h(e[l][p2], e[l]));
              } else
                r2 = n2.yData;
              k2 ? (n2.minColorValue = n2[f2 + "Min"], n2.maxColorValue = n2[f2 + "Max"]) : (r2 = t.prototype.getExtremes.call(n2, r2), n2.minColorValue = r2.dataMin, n2.maxColorValue = r2.dataMax);
              "undefined" !== typeof n2.minColorValue && (this.dataMin = Math.min(this.dataMin, n2.minColorValue), this.dataMax = Math.max(this.dataMax, n2.maxColorValue));
              k2 || t.prototype.applyExtremes.call(n2);
            }
          }
          drawCrosshair(a3, f2) {
            const c = this.legendItem || {}, g = f2 && f2.plotX, h2 = f2 && f2.plotY, e = this.pos, k2 = this.len;
            let n2;
            f2 && (n2 = this.toPixels(f2.getNestedProperty(f2.series.colorKey)), n2 < e ? n2 = e - 2 : n2 > e + k2 && (n2 = e + k2 + 2), f2.plotX = n2, f2.plotY = this.len - n2, super.drawCrosshair(a3, f2), f2.plotX = g, f2.plotY = h2, this.cross && !this.cross.addedToColorAxis && c.group && (this.cross.addClass("highcharts-coloraxis-marker").add(c.group), this.cross.addedToColorAxis = true, this.chart.styledMode || "object" !== typeof this.crosshair || this.cross.attr({ fill: this.crosshair.color })));
          }
          getPlotLinePath(a3) {
            const c = this.left, f2 = a3.translatedValue, h2 = this.top;
            return p(f2) ? this.horiz ? [["M", f2 - 4, h2 - 6], ["L", f2 + 4, h2 - 6], ["L", f2, h2], ["Z"]] : [["M", c, f2], ["L", c - 6, f2 + 6], ["L", c - 6, f2 - 6], ["Z"]] : super.getPlotLinePath(a3);
          }
          update(a3, f2) {
            const c = this.chart.legend;
            this.series.forEach((a4) => {
              a4.isDirtyData = true;
            });
            (a3.dataClasses && c.allItems || this.dataClasses) && this.destroyItems();
            super.update(a3, f2);
            this.legendItem && this.legendItem.label && (this.setLegendColor(), c.colorizeItem(this, true));
          }
          destroyItems() {
            const a3 = this.chart, f2 = this.legendItem || {};
            if (f2.label)
              a3.legend.destroyItem(this);
            else if (f2.labels)
              for (const c of f2.labels)
                a3.legend.destroyItem(c);
            a3.isDirtyLegend = true;
          }
          destroy() {
            this.chart.isDirtyLegend = true;
            this.destroyItems();
            super.destroy(...[].slice.call(arguments));
          }
          remove(a3) {
            this.destroyItems();
            super.remove(a3);
          }
          getDataClassLegendSymbols() {
            const a3 = this, f2 = a3.chart, k2 = a3.legendItem && a3.legendItem.labels || [], n2 = f2.options.legend, p2 = h(n2.valueDecimals, -1), e = h(n2.valueSuffix, ""), l = (c) => a3.series.reduce((a4, b) => {
              a4.push(...b.points.filter((b2) => b2.dataClass === c));
              return a4;
            }, []);
            let v;
            k2.length || a3.dataClasses.forEach((c, g) => {
              const b = c.from, d = c.to, { numberFormatter: h2 } = f2;
              let n3 = true;
              v = "";
              "undefined" === typeof b ? v = "< " : "undefined" === typeof d && (v = "> ");
              "undefined" !== typeof b && (v += h2(b, p2) + e);
              "undefined" !== typeof b && "undefined" !== typeof d && (v += " - ");
              "undefined" !== typeof d && (v += h2(d, p2) + e);
              k2.push(q({ chart: f2, name: v, options: {}, drawLegendSymbol: y.rectangle, visible: true, isDataClass: true, setState: (b2) => {
                for (const a4 of l(g))
                  a4.setState(b2);
              }, setVisible: function() {
                this.visible = n3 = a3.visible = !n3;
                for (const b2 of l(g))
                  b2.setVisible(n3);
                f2.legend.colorizeItem(this, n3);
              } }, c));
            });
            return k2;
          }
        }
        f.defaultColorAxisOptions = I;
        f.defaultLegendLength = 200;
        f.keepProps = ["legendItem"];
        Array.prototype.push.apply(a2.keepProps, f.keepProps);
        "";
        return f;
      });
      K(
        a,
        "Maps/MapNavigationDefaults.js",
        [a["Core/Defaults.js"], a["Core/Utilities.js"]],
        function(a2, x) {
          ({ extend: x } = x);
          const r = { buttonOptions: { alignTo: "plotBox", align: "left", verticalAlign: "top", x: 0, width: 18, height: 18, padding: 5, style: { color: "#666666", fontSize: "1em", fontWeight: "bold" }, theme: { fill: "#ffffff", stroke: "#e6e6e6", "stroke-width": 1, "text-align": "center" } }, buttons: { zoomIn: { onclick: function() {
            this.mapZoom(0.5);
          }, text: "+", y: 0 }, zoomOut: { onclick: function() {
            this.mapZoom(2);
          }, text: "-", y: 28 } }, mouseWheelSensitivity: 1.1 };
          x(a2.defaultOptions.lang, { zoomIn: "Zoom in", zoomOut: "Zoom out" });
          return a2.defaultOptions.mapNavigation = r;
        }
      );
      K(a, "Maps/MapNavigation.js", [a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G) {
        function r(a3) {
          a3 && (a3.preventDefault && a3.preventDefault(), a3.stopPropagation && a3.stopPropagation(), a3.cancelBubble = true);
        }
        function y(a3) {
          this.navButtons = [];
          this.init(a3);
        }
        const { doc: A } = x, { addEvent: F, extend: D, isNumber: t, merge: q, objectEach: k, pick: p } = G;
        y.prototype.init = function(a3) {
          this.chart = a3;
        };
        y.prototype.update = function(a3) {
          let h = this, f = this.chart, c = f.options.mapNavigation, g, n = function(a4) {
            this.handler.call(
              f,
              a4
            );
            r(a4);
          }, t2 = h.navButtons;
          a3 && (c = f.options.mapNavigation = q(f.options.mapNavigation, a3));
          for (; t2.length; )
            t2.pop().destroy();
          p(c.enableButtons, c.enabled) && !f.renderer.forExport && (h.navButtonsGroup || (h.navButtonsGroup = f.renderer.g().attr({ zIndex: 4 }).add()), k(c.buttons, function(a4, e) {
            var k2;
            a4 = q(c.buttonOptions, a4);
            !f.styledMode && a4.theme && (g = a4.theme, g.style = q(a4.theme.style, a4.style));
            const { text: p2, width: B = 0, height: u = 0, padding: b = 0 } = a4, d = f.renderer.button("+" !== p2 && "-" !== p2 && p2 || "", 0, 0, n, g, void 0, void 0, void 0, "zoomIn" === e ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + { zoomIn: "zoom-in", zoomOut: "zoom-out" }[e]).attr({ width: B, height: u, title: f.options.lang[e], padding: a4.padding, zIndex: 5 }).add(h.navButtonsGroup);
            if ("+" === p2 || "-" === p2) {
              e = B + 1;
              const c2 = [["M", b + 3, b + u / 2], ["L", b + e - 3, b + u / 2]];
              "+" === p2 && c2.push(["M", b + e / 2, b + 3], ["L", b + e / 2, b + u - 3]);
              f.renderer.path(c2).addClass("highcharts-button-symbol").attr(f.styledMode ? {} : { stroke: null === (k2 = a4.style) || void 0 === k2 ? void 0 : k2.color, "stroke-width": 3, "stroke-linecap": "round" }).add(d);
            }
            d.handler = a4.onclick;
            F(d.element, "dblclick", r);
            t2.push(d);
            D(a4, { width: d.width, height: 2 * d.height });
            if (f.hasLoaded)
              d.align(a4, false, a4.alignTo);
            else {
              const b2 = F(f, "load", () => {
                d.element && d.align(a4, false, a4.alignTo);
                b2();
              });
            }
          }), a3 = function() {
            var a4 = f.exportingGroup && f.exportingGroup.getBBox();
            if (a4) {
              const e = h.navButtonsGroup.getBBox();
              if (!(e.x >= a4.x + a4.width || e.x + e.width <= a4.x || e.y >= a4.y + a4.height || e.y + e.height <= a4.y)) {
                const f2 = -e.y - e.height + a4.y - 5;
                a4 = a4.y + a4.height - e.y + 5;
                h.navButtonsGroup.attr({ translateY: "bottom" === (c.buttonOptions && c.buttonOptions.verticalAlign) ? f2 : a4 });
              }
            }
          }, f.hasLoaded || F(f, "render", a3));
          this.updateEvents(c);
        };
        y.prototype.updateEvents = function(a3) {
          const h = this.chart;
          p(a3.enableDoubleClickZoom, a3.enabled) || a3.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || F(h.container, "dblclick", function(a4) {
            h.pointer.onContainerDblClick(a4);
          }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
          p(a3.enableMouseWheelZoom, a3.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || F(h.container, void 0 !== A.onwheel ? "wheel" : void 0 !== A.onmousewheel ? "mousewheel" : "DOMMouseScroll", function(a4) {
            h.pointer.inClass(a4.target, "highcharts-no-mousewheel") || (h.pointer.onContainerMouseWheel(a4), r(a4));
            return false;
          }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
        };
        D(a2.prototype, { fitToBox: function(a3, h) {
          [["x", "width"], ["y", "height"]].forEach(function(f) {
            const c = f[0];
            f = f[1];
            a3[c] + a3[f] > h[c] + h[f] && (a3[f] > h[f] ? (a3[f] = h[f], a3[c] = h[c]) : a3[c] = h[c] + h[f] - a3[f]);
            a3[f] > h[f] && (a3[f] = h[f]);
            a3[c] < h[c] && (a3[c] = h[c]);
          });
          return a3;
        }, mapZoom: function(a3, h, f, c, g) {
          this.mapView && (t(a3) && (a3 = Math.log(a3) / Math.log(0.5)), this.mapView.zoomBy(a3, t(h) && t(f) ? this.mapView.projection.inverse([h, f]) : void 0, t(c) && t(g) ? [c, g] : void 0));
        } });
        F(a2, "beforeRender", function() {
          this.mapNavigation = new y(this);
          this.mapNavigation.update();
        });
        x.MapNavigation = y;
      });
      K(a, "Maps/MapPointer.js", [a["Core/Pointer.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { defined: r, extend: I, pick: y, wrap: A } = x, F = a2.prototype.normalize;
        let D = 0, t;
        I(a2.prototype, { normalize: function(a3, k) {
          const q = this.chart;
          a3 = F.call(this, a3, k);
          q && q.mapView && (k = q.mapView.pixelsToLonLat({ x: a3.chartX - q.plotLeft, y: a3.chartY - q.plotTop })) && I(a3, k);
          return a3;
        }, onContainerDblClick: function(a3) {
          const k = this.chart;
          a3 = this.normalize(a3);
          k.options.mapNavigation.enableDoubleClickZoomTo ? k.pointer.inClass(a3.target, "highcharts-tracker") && k.hoverPoint && k.hoverPoint.zoomTo() : k.isInsidePlot(a3.chartX - k.plotLeft, a3.chartY - k.plotTop) && k.mapZoom(0.5, void 0, void 0, a3.chartX, a3.chartY);
        }, onContainerMouseWheel: function(a3) {
          const k = this.chart;
          a3 = this.normalize(a3);
          const p = r(a3.wheelDelta) && -a3.wheelDelta / 120 || a3.deltaY || a3.detail;
          1 <= Math.abs(p) && (D += Math.abs(p), t && clearTimeout(t), t = setTimeout(() => {
            D = 0;
          }, 50));
          10 > D && k.isInsidePlot(a3.chartX - k.plotLeft, a3.chartY - k.plotTop) && k.mapView && k.mapView.zoomBy((k.options.mapNavigation.mouseWheelSensitivity - 1) * -p, void 0, [a3.chartX, a3.chartY], 1 > Math.abs(p) ? false : void 0);
        } });
        A(a2.prototype, "zoomOption", function(a3) {
          const k = this.chart.options.mapNavigation;
          y(k.enableTouchZoom, k.enabled) && (this.chart.zooming.pinchType = "xy");
          a3.apply(this, [].slice.call(arguments, 1));
        });
        A(
          a2.prototype,
          "pinchTranslate",
          function(a3, k, p, n, h, f, c) {
            a3.call(this, k, p, n, h, f, c);
            "map" === this.chart.options.chart.type && this.hasZoom && (a3 = n.scaleX > n.scaleY, this.pinchTranslateDirection(!a3, k, p, n, h, f, c, a3 ? n.scaleX : n.scaleY));
          }
        );
      });
      K(a, "Series/ColorMapComposition.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x) {
        const { column: { prototype: r } } = a2.seriesTypes, { addEvent: I, defined: y } = x;
        var A;
        (function(a3) {
          function A2(a4) {
            this.moveToTopOnHover && this.graphic && this.graphic.attr({ zIndex: a4 && "hover" === a4.state ? 1 : 0 });
          }
          const t = [];
          a3.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
            return null !== this.value && Infinity !== this.value && -Infinity !== this.value && (void 0 === this.value || !isNaN(this.value));
          } };
          a3.seriesMembers = { colorKey: "value", axisTypes: ["xAxis", "yAxis", "colorAxis"], parallelArrays: ["x", "y", "value"], pointArrayMap: ["value"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], colorAttribs: function(a4) {
            const k = {};
            !y(a4.color) || a4.state && "normal" !== a4.state || (k[this.colorProp || "fill"] = a4.color);
            return k;
          }, pointAttribs: r.pointAttribs };
          a3.compose = function(a4) {
            const k = a4.prototype.pointClass;
            x.pushUnique(t, k) && I(k, "afterSetState", A2);
            return a4;
          };
        })(A || (A = {}));
        return A;
      });
      K(a, "Maps/MapSymbols.js", [a["Core/Renderer/SVG/SVGRenderer.js"]], function(a2) {
        const { prototype: { symbols: r } } = a2;
        r.bottombutton = function(a3, x, y, A, F) {
          if (F) {
            const a4 = (null === F || void 0 === F ? void 0 : F.r) || 0;
            F.brBoxY = x - a4;
            F.brBoxHeight = A + a4;
          }
          return r.roundedRect(a3, x, y, A, F);
        };
        r.topbutton = function(a3, x, y, A, F) {
          F && (F.brBoxHeight = A + ((null === F || void 0 === F ? void 0 : F.r) || 0));
          return r.roundedRect(a3, x, y, A, F);
        };
        return r;
      });
      K(a, "Core/Chart/MapChart.js", [a["Core/Chart/Chart.js"], a["Core/Defaults.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, x, G, I) {
        const { getOptions: r } = x, { merge: A, pick: F } = I;
        class D extends a2 {
          init(a3, q) {
            const k = r().credits;
            a3 = A({
              chart: { panning: { enabled: true, type: "xy" }, type: "map" },
              credits: { mapText: F(k.mapText, ' © <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'), mapTextFull: F(k.mapTextFull, "{geojson.copyright}") },
              mapView: {},
              tooltip: { followTouchMove: false }
            }, a3);
            super.init(a3, q);
          }
        }
        (function(a3) {
          a3.maps = {};
          a3.mapChart = function(q, k, p) {
            return new a3(q, k, p);
          };
          a3.splitPath = function(a4) {
            "string" === typeof a4 && (a4 = a4.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), a4 = a4.split(/[ ,;]+/).map((a5) => /[A-za-z]/.test(a5) ? a5 : parseFloat(a5)));
            return G.prototype.pathToSegments(a4);
          };
        })(D || (D = {}));
        return D;
      });
      K(a, "Maps/MapUtilities.js", [], function() {
        return { boundsFromPath: function(a2) {
          let r = -Number.MAX_VALUE, G = Number.MAX_VALUE, I = -Number.MAX_VALUE, y = Number.MAX_VALUE, A;
          a2.forEach((a3) => {
            const x = a3[a3.length - 2];
            a3 = a3[a3.length - 1];
            "number" === typeof x && "number" === typeof a3 && (G = Math.min(G, x), r = Math.max(r, x), y = Math.min(y, a3), I = Math.max(I, a3), A = true);
          });
          if (A)
            return { x1: G, y1: y, x2: r, y2: I };
        }, pointInPolygon: function(a2, x) {
          let r, I, y, A = false, F = a2.x, D = a2.y;
          a2 = 0;
          for (r = x.length - 1; a2 < x.length; r = a2++)
            I = x[a2][1] > D, y = x[r][1] > D, I !== y && F < (x[r][0] - x[a2][0]) * (D - x[a2][1]) / (x[r][1] - x[a2][1]) + x[a2][0] && (A = !A);
          return A;
        } };
      });
      K(a, "Series/Map/MapPoint.js", [
        a["Series/ColorMapComposition.js"],
        a["Maps/MapUtilities.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I) {
        const { boundsFromPath: r } = x;
        ({ seriesTypes: { scatter: x } } = G);
        const { extend: A, isNumber: F, pick: D } = I;
        class t extends x.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.path = this.options = void 0;
          }
          static getProjectedPath(a3, k) {
            a3.projectedPath || (k && a3.geometry ? (k.hasCoordinates = true, a3.projectedPath = k.path(a3.geometry)) : a3.projectedPath = a3.path);
            return a3.projectedPath || [];
          }
          applyOptions(a3, k) {
            const p = this.series;
            a3 = super.applyOptions.call(
              this,
              a3,
              k
            );
            k = p.joinBy;
            p.mapData && p.mapMap && (k = super.getNestedProperty.call(a3, k[1]), (k = "undefined" !== typeof k && p.mapMap[k]) ? A(a3, k) : -1 !== p.pointArrayMap.indexOf("value") && (a3.value = a3.value || null));
            return a3;
          }
          getProjectedBounds(a3) {
            var k = t.getProjectedPath(this, a3);
            k = r(k);
            var p = this.properties;
            const n = this.series.chart.mapView;
            if (k) {
              const h = p && p["hc-middle-lon"], f = p && p["hc-middle-lat"];
              n && F(h) && F(f) ? (a3 = a3.forward([h, f]), k.midX = a3[0], k.midY = a3[1]) : (a3 = p && p["hc-middle-x"], p = p && p["hc-middle-y"], k.midX = k.x1 + (k.x2 - k.x1) * D(this.middleX, F(a3) ? a3 : 0.5), a3 = D(this.middleY, F(p) ? p : 0.5), this.geometry || (a3 = 1 - a3), k.midY = k.y2 - (k.y2 - k.y1) * a3);
              return k;
            }
          }
          onMouseOver(a3) {
            I.clearTimeout(this.colorInterval);
            if (!this.isNull && this.visible || this.series.options.nullInteraction)
              super.onMouseOver.call(this, a3);
            else
              this.series.onMouseOut(a3);
          }
          setVisible(a3) {
            const k = a3 ? "show" : "hide";
            this.visible = this.options.visible = !!a3;
            if (this.dataLabel)
              this.dataLabel[k]();
            this.graphic && this.graphic.attr(this.series.pointAttribs(this));
          }
          zoomTo(a3) {
            const k = this.series.chart, p = k.mapView;
            var n = this.bounds;
            if (p && n) {
              const f = F(this.insetIndex) && p.insets[this.insetIndex];
              if (f) {
                var h = f.projectedUnitsToPixels({ x: n.x1, y: n.y1 });
                n = f.projectedUnitsToPixels({ x: n.x2, y: n.y2 });
                h = p.pixelsToProjectedUnits({ x: h.x, y: h.y });
                n = p.pixelsToProjectedUnits({ x: n.x, y: n.y });
                n = { x1: h.x, y1: h.y, x2: n.x, y2: n.y };
              }
              p.fitToBounds(n, void 0, false);
              this.series.isDirty = true;
              k.redraw(a3);
            }
          }
        }
        A(t.prototype, { dataLabelOnNull: a2.pointMembers.dataLabelOnNull, moveToTopOnHover: a2.pointMembers.moveToTopOnHover, isValid: a2.pointMembers.isValid });
        return t;
      });
      K(a, "Maps/MapViewOptionsDefault.js", [], function() {
        return { center: [0, 0], fitToGeometry: void 0, maxZoom: void 0, padding: 0, projection: { name: void 0, parallels: void 0, rotation: void 0 }, zoom: void 0 };
      });
      K(a, "Maps/MapViewInsetsOptionsDefault.js", [], function() {
        return { borderColor: "#cccccc", borderWidth: 1, center: [0, 0], padding: "10%", relativeTo: "mapBoundingBox", units: "percent" };
      });
      K(a, "Extensions/GeoJSON.js", [a["Core/Chart/Chart.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G, I) {
        function r(a3, h) {
          h || (h = Object.keys(a3.objects)[0]);
          h = a3.objects[h];
          if (h["hc-decoded-geojson"])
            return h["hc-decoded-geojson"];
          let f = a3.arcs;
          if (a3.transform) {
            const { scale: c2, translate: g2 } = a3.transform;
            f = a3.arcs.map((a4) => {
              let e = 0, f2 = 0;
              return a4.map((a5) => {
                a5 = a5.slice();
                a5[0] = (e += a5[0]) * c2[0] + g2[0];
                a5[1] = (f2 += a5[1]) * c2[1] + g2[1];
                return a5;
              });
            });
          }
          const c = (a4) => "number" === typeof a4[0] ? a4.reduce((a5, c2, e) => {
            let g2 = 0 > c2 ? f[~c2] : f[c2];
            0 > c2 ? (g2 = g2.slice(0, 0 === e ? g2.length : g2.length - 1), g2.reverse()) : e && (g2 = g2.slice(1));
            return a5.concat(g2);
          }, []) : a4.map(c), g = h.geometries.map((a4) => ({ type: "Feature", properties: a4.properties, geometry: { type: a4.type, coordinates: a4.coordinates || c(a4.arcs) } }));
          a3 = { type: "FeatureCollection", copyright: a3.copyright, copyrightShort: a3.copyrightShort, copyrightUrl: a3.copyrightUrl, features: g, "hc-recommended-mapview": h["hc-recommended-mapview"], bbox: a3.bbox, title: a3.title };
          return h["hc-decoded-geojson"] = a3;
        }
        function A(a3, h = "map", f) {
          const c = [];
          a3 = "Topology" === a3.type ? r(a3) : a3;
          a3.features.forEach(function(a4) {
            var f2 = a4.geometry || {}, g = f2.type;
            f2 = f2.coordinates;
            a4 = a4.properties;
            let k2;
            "map" !== h && "mapbubble" !== h || "Polygon" !== g && "MultiPolygon" !== g ? "mapline" !== h || "LineString" !== g && "MultiLineString" !== g ? "mappoint" === h && "Point" === g && f2.length && (k2 = { geometry: { coordinates: f2, type: g } }) : f2.length && (k2 = { geometry: { coordinates: f2, type: g } }) : f2.length && (k2 = { geometry: { coordinates: f2, type: g } });
            if (k2) {
              g = a4 && (a4.name || a4.NAME);
              f2 = a4 && a4.lon;
              const e = a4 && a4.lat;
              c.push(q(k2, { lat: "number" === typeof e ? e : void 0, lon: "number" === typeof f2 ? f2 : void 0, name: "string" === typeof g ? g : void 0, properties: a4 }));
            }
          });
          f && a3.copyrightShort && (f.chart.mapCredits = F(f.chart.options.credits.mapText, { geojson: a3 }), f.chart.mapCreditsFull = F(f.chart.options.credits.mapTextFull, { geojson: a3 }));
          return c;
        }
        const { format: F } = x, { win: D } = G, { error: t, extend: q, merge: k, wrap: p } = I;
        "";
        a2.prototype.transformFromLatLon = function(a3, h) {
          var f = this.options.chart.proj4 || D.proj4;
          if (f) {
            var { jsonmarginX: c = 0, jsonmarginY: g = 0, jsonres: k2 = 1, scale: n = 1, xoffset: p2 = 0, xpan: e = 0, yoffset: l = 0, ypan: q2 = 0 } = h;
            a3 = f(h.crs, [a3.lon, a3.lat]);
            f = h.cosAngle || h.rotation && Math.cos(h.rotation);
            var r2 = h.sinAngle || h.rotation && Math.sin(h.rotation);
            h = h.rotation ? [a3[0] * f + a3[1] * r2, -a3[0] * r2 + a3[1] * f] : a3;
            return { x: ((h[0] - p2) * n + e) * k2 + c, y: -(((l - h[1]) * n + q2) * k2 - g) };
          }
          t(21, false, this);
        };
        a2.prototype.transformToLatLon = function(a3, h) {
          const f = this.options.chart.proj4 || D.proj4;
          if (!f)
            t(21, false, this);
          else if (null !== a3.y) {
            var { jsonmarginX: c = 0, jsonmarginY: g = 0, jsonres: k2 = 1, scale: n = 1, xoffset: p2 = 0, xpan: e = 0, yoffset: l = 0, ypan: q2 = 0 } = h;
            a3 = { x: ((a3.x - c) / k2 - e) / n + p2, y: ((a3.y - g) / k2 + q2) / n + l };
            var r2 = h.cosAngle || h.rotation && Math.cos(h.rotation), u = h.sinAngle || h.rotation && Math.sin(h.rotation);
            h = f(h.crs, "WGS84", h.rotation ? { x: a3.x * r2 + a3.y * -u, y: a3.x * u + a3.y * r2 } : a3);
            return { lat: h.y, lon: h.x };
          }
        };
        a2.prototype.fromPointToLatLon = function(a3) {
          return this.mapView && this.mapView.projectedUnitsToLonLat(a3);
        };
        a2.prototype.fromLatLonToPoint = function(a3) {
          return this.mapView && this.mapView.lonLatToProjectedUnits(a3);
        };
        p(a2.prototype, "addCredits", function(a3, h) {
          h = k(true, this.options.credits, h);
          this.mapCredits && (h.href = null);
          a3.call(this, h);
          this.credits && this.mapCreditsFull && this.credits.attr({ title: this.mapCreditsFull });
        });
        G.geojson = A;
        G.topo2geo = r;
        return { geojson: A, topo2geo: r };
      });
      K(a, "Core/Geometry/PolygonClip.js", [], function() {
        const a2 = (a3, r, x2) => (r[0] - a3[0]) * (x2[1] - a3[1]) > (r[1] - a3[1]) * (x2[0] - a3[0]), x = (a3, r, x2, F) => {
          var y = [a3[0] - r[0], a3[1] - r[1]];
          const t = [x2[0] - F[0], x2[1] - F[1]];
          a3 = a3[0] * r[1] - a3[1] * r[0];
          x2 = x2[0] * F[1] - x2[1] * F[0];
          F = 1 / (y[0] * t[1] - y[1] * t[0]);
          y = [(a3 * t[0] - x2 * y[0]) * F, (a3 * t[1] - x2 * y[1]) * F];
          y.isIntersection = true;
          return y;
        };
        var G;
        (function(r) {
          r.clipLineString = (a3, x2) => {
            const y = [];
            a3 = r.clipPolygon(a3, x2, false);
            for (x2 = 1; x2 < a3.length; x2++)
              a3[x2].isIntersection && a3[x2 - 1].isIntersection && (y.push(a3.splice(0, x2)), x2 = 0), x2 === a3.length - 1 && y.push(a3);
            return y;
          };
          r.clipPolygon = (r2, A, G2 = true) => {
            let y = A[A.length - 1], t, q, k = r2;
            for (let p = 0; p < A.length; p++) {
              const n = k;
              r2 = A[p];
              k = [];
              t = G2 ? n[n.length - 1] : n[0];
              for (let h = 0; h < n.length; h++)
                q = n[h], a2(y, r2, q) ? (a2(y, r2, t) || k.push(x(y, r2, t, q)), k.push(q)) : a2(y, r2, t) && k.push(x(y, r2, t, q)), t = q;
              y = r2;
            }
            return k;
          };
        })(G || (G = {}));
        return G;
      });
      K(a, "Maps/Projections/LambertConformalConic.js", [], function() {
        const a2 = Math.sign || ((a3) => 0 === a3 ? 0 : 0 < a3 ? 1 : -1), x = Math.PI / 180, G = Math.PI / 2;
        class I {
          constructor(r) {
            var y, F = (r.parallels || []).map((a3) => a3 * x);
            const D = F[0] || 0;
            F = null !== (y = F[1]) && void 0 !== y ? y : D;
            y = Math.cos(D);
            "object" === typeof r.projectedBounds && (this.projectedBounds = r.projectedBounds);
            r = D === F ? Math.sin(D) : Math.log(y / Math.cos(F)) / Math.log(Math.tan((G + F) / 2) / Math.tan((G + D) / 2));
            1e-10 > Math.abs(r) && (r = 1e-10 * (a2(r) || 1));
            this.n = r;
            this.c = y * Math.pow(Math.tan((G + D) / 2), r) / r;
          }
          forward(a3) {
            var r = a3[0] * x;
            const { c: y, n: D, projectedBounds: t } = this;
            a3 = a3[1] * x;
            0 < y ? a3 < -G + 1e-6 && (a3 = -G + 1e-6) : a3 > G - 1e-6 && (a3 = G - 1e-6);
            var q = y / Math.pow(Math.tan((G + a3) / 2), D);
            a3 = q * Math.sin(D * r) * 63.78137;
            r = 63.78137 * (y - q * Math.cos(D * r));
            q = [a3, r];
            t && (a3 < t.x1 || a3 > t.x2 || r < t.y1 || r > t.y2) && (q.outside = true);
            return q;
          }
          inverse(r) {
            const y = r[0] / 63.78137;
            r = r[1] / 63.78137;
            const { c: F, n: D } = this;
            r = F - r;
            const t = a2(D) * Math.sqrt(y * y + r * r);
            let q = Math.atan2(y, Math.abs(r)) * a2(r);
            0 > r * D && (q -= Math.PI * a2(y) * a2(r));
            return [q / D / x, (2 * Math.atan(Math.pow(F / t, 1 / D)) - G) / x];
          }
        }
        return I;
      });
      K(a, "Maps/Projections/EqualEarth.js", [], function() {
        const a2 = Math.sqrt(3) / 2;
        class x {
          constructor() {
            this.bounds = {
              x1: -200.37508342789243,
              x2: 200.37508342789243,
              y1: -97.52595454902263,
              y2: 97.52595454902263
            };
          }
          forward(r) {
            const x2 = Math.PI / 180, y = Math.asin(a2 * Math.sin(r[1] * x2)), A = y * y, G = A * A * A;
            return [r[0] * x2 * Math.cos(y) * 74.03120656864502 / (a2 * (1.340264 + 3 * -0.081106 * A + G * (7 * 893e-6 + 0.034164 * A))), 74.03120656864502 * y * (1.340264 + -0.081106 * A + G * (893e-6 + 3796e-6 * A))];
          }
          inverse(r) {
            const x2 = r[0] / 74.03120656864502;
            r = r[1] / 74.03120656864502;
            const y = 180 / Math.PI;
            let A = r;
            let G;
            let D;
            for (D = 0; 12 > D; ++D) {
              var t = A * A;
              G = t * t * t;
              var q = A * (1.340264 + -0.081106 * t + G * (893e-6 + 3796e-6 * t)) - r;
              t = 1.340264 + 3 * -0.081106 * t + G * (7 * 893e-6 + 0.034164 * t);
              A -= q /= t;
              if (1e-9 > Math.abs(q))
                break;
            }
            t = A * A;
            return [y * a2 * x2 * (1.340264 + 3 * -0.081106 * t + t * t * t * (7 * 893e-6 + 0.034164 * t)) / Math.cos(A), y * Math.asin(Math.sin(A) / a2)];
          }
        }
        return x;
      });
      K(a, "Maps/Projections/Miller.js", [], function() {
        const a2 = Math.PI / 4, x = Math.PI / 180;
        class G {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -146.91480769173063, y2: 146.91480769173063 };
          }
          forward(r) {
            return [r[0] * x * 63.78137, 79.7267125 * Math.log(Math.tan(a2 + 0.4 * r[1] * x))];
          }
          inverse(r) {
            return [r[0] / 63.78137 / x, 2.5 * (Math.atan(Math.exp(r[1] / 63.78137 * 0.8)) - a2) / x];
          }
        }
        return G;
      });
      K(a, "Maps/Projections/Orthographic.js", [], function() {
        const a2 = Math.PI / 180;
        class x {
          constructor() {
            this.antimeridianCutting = false;
            this.bounds = { x1: -63.78460826781007, x2: 63.78460826781007, y1: -63.78460826781007, y2: 63.78460826781007 };
          }
          forward(r) {
            const x2 = r[0];
            r = r[1] * a2;
            r = [Math.cos(r) * Math.sin(x2 * a2) * 63.78460826781007, 63.78460826781007 * Math.sin(r)];
            if (-90 > x2 || 90 < x2)
              r.outside = true;
            return r;
          }
          inverse(r) {
            const x2 = r[0] / 63.78460826781007;
            r = r[1] / 63.78460826781007;
            const y = Math.sqrt(x2 * x2 + r * r), A = Math.asin(y), G = Math.sin(A);
            return [Math.atan2(x2 * G, y * Math.cos(A)) / a2, Math.asin(y && r * G / y) / a2];
          }
        }
        return x;
      });
      K(a, "Maps/Projections/WebMercator.js", [], function() {
        const a2 = Math.PI / 180;
        class x {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -200.3750834278071, y2: 200.3750834278071 };
            this.maxLatitude = 85.0511287798;
          }
          forward(r) {
            var x2 = Math.sin(r[1] * a2);
            x2 = [63.78137 * r[0] * a2, 63.78137 * Math.log((1 + x2) / (1 - x2)) / 2];
            85.0511287798 < Math.abs(r[1]) && (x2.outside = true);
            return x2;
          }
          inverse(r) {
            return [r[0] / (63.78137 * a2), (2 * Math.atan(Math.exp(r[1] / 63.78137)) - Math.PI / 2) / a2];
          }
        }
        return x;
      });
      K(a, "Maps/Projections/ProjectionRegistry.js", [a["Maps/Projections/LambertConformalConic.js"], a["Maps/Projections/EqualEarth.js"], a["Maps/Projections/Miller.js"], a["Maps/Projections/Orthographic.js"], a["Maps/Projections/WebMercator.js"]], function(a2, x, G, I, y) {
        return { EqualEarth: x, LambertConformalConic: a2, Miller: G, Orthographic: I, WebMercator: y };
      });
      K(a, "Maps/Projection.js", [
        a["Core/Geometry/PolygonClip.js"],
        a["Maps/Projections/ProjectionRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G) {
        const { clipLineString: r, clipPolygon: y } = a2, { clamp: A, erase: F } = G, D = 2 * Math.PI / 360, t = (a3) => {
          -180 > a3 && (a3 += 360);
          180 < a3 && (a3 -= 360);
          return a3;
        };
        class q {
          static add(a3, p) {
            q.registry[a3] = p;
          }
          static greatCircle(a3, p, n) {
            const { atan2: h, cos: f, sin: c, sqrt: g } = Math, k = a3[1] * D, q2 = a3[0] * D, r2 = p[1] * D, e = p[0] * D;
            var l = r2 - k, v = e - q2;
            l = c(l / 2) * c(l / 2) + f(k) * f(r2) * c(v / 2) * c(v / 2);
            l = 2 * h(g(l), g(1 - l));
            var t2 = Math.round(6371e3 * l / 5e5);
            v = [];
            n && v.push(a3);
            if (1 < t2)
              for (a3 = 1 / t2, t2 = a3; 0.999 > t2; t2 += a3) {
                var u = c((1 - t2) * l) / c(l);
                const a4 = c(t2 * l) / c(l);
                var b = u * f(k) * f(q2) + a4 * f(r2) * f(e);
                const m = u * f(k) * c(q2) + a4 * f(r2) * c(e);
                u = u * c(k) + a4 * c(r2);
                u = h(u, g(b * b + m * m));
                b = h(m, b);
                v.push([b / D, u / D]);
              }
            n && v.push(p);
            return v;
          }
          static insertGreatCircles(a3) {
            let k = a3.length - 1;
            for (; k--; )
              if (10 < Math.max(Math.abs(a3[k][0] - a3[k + 1][0]), Math.abs(a3[k][1] - a3[k + 1][1]))) {
                const n = q.greatCircle(a3[k], a3[k + 1]);
                n.length && a3.splice(k + 1, 0, ...n);
              }
          }
          static toString(a3) {
            const { name: k, rotation: n } = a3 || {};
            return [k, n && n.join(",")].join(";");
          }
          constructor(a3 = {}) {
            this.hasGeoProjection = this.hasCoordinates = false;
            this.maxLatitude = 90;
            this.options = a3;
            const { name: k, projectedBounds: n, rotation: h } = a3;
            this.rotator = h ? this.getRotator(h) : void 0;
            const f = k ? q.registry[k] : void 0;
            f && (this.def = new f(a3));
            const { def: c, rotator: g } = this;
            c && (this.maxLatitude = c.maxLatitude || 90, this.hasGeoProjection = true);
            g && c ? (this.forward = (a4) => c.forward(g.forward(a4)), this.inverse = (a4) => g.inverse(c.inverse(a4))) : c ? (this.forward = (a4) => c.forward(a4), this.inverse = (a4) => c.inverse(a4)) : g && (this.forward = g.forward, this.inverse = g.inverse);
            this.bounds = "world" === n ? c && c.bounds : n;
          }
          lineIntersectsBounds(a3) {
            const {
              x1: k,
              x2: n,
              y1: h,
              y2: f
            } = this.bounds || {}, c = (a4, c2, e) => {
              const [f2, g2] = a4;
              a4 = c2 ? 0 : 1;
              if ("number" === typeof e && f2[c2] >= e !== g2[c2] >= e)
                return a4 = f2[a4] + (e - f2[c2]) / (g2[c2] - f2[c2]) * (g2[a4] - f2[a4]), c2 ? [a4, e] : [e, a4];
            };
            let g, q2 = a3[0];
            if (g = c(a3, 0, k))
              q2 = g, a3[1] = g;
            else if (g = c(a3, 0, n))
              q2 = g, a3[1] = g;
            if (g = c(a3, 1, h))
              q2 = g;
            else if (g = c(a3, 1, f))
              q2 = g;
            return q2;
          }
          getRotator(a3) {
            const k = a3[0] * D, n = (a3[1] || 0) * D;
            a3 = (a3[2] || 0) * D;
            const h = Math.cos(n), f = Math.sin(n), c = Math.cos(a3), g = Math.sin(a3);
            if (0 !== k || 0 !== n || 0 !== a3)
              return { forward: (a4) => {
                var n2 = a4[0] * D + k, p = a4[1] * D, e = Math.cos(p);
                a4 = Math.cos(n2) * e;
                n2 = Math.sin(n2) * e;
                p = Math.sin(p);
                e = p * h + a4 * f;
                return [Math.atan2(n2 * c - e * g, a4 * h - p * f) / D, Math.asin(e * c + n2 * g) / D];
              }, inverse: (a4) => {
                var n2 = a4[0] * D, p = a4[1] * D, e = Math.cos(p);
                a4 = Math.cos(n2) * e;
                n2 = Math.sin(n2) * e;
                p = Math.sin(p);
                e = p * c - n2 * g;
                return [(Math.atan2(n2 * c + p * g, a4 * h + e * f) - k) / D, Math.asin(e * h - a4 * f) / D];
              } };
          }
          forward(a3) {
            return a3;
          }
          inverse(a3) {
            return a3;
          }
          cutOnAntimeridian(a3, p) {
            const k = [], h = [a3];
            a3.forEach((c2, f2) => {
              let e = a3[f2 - 1];
              if (!f2) {
                if (!p)
                  return;
                e = a3[a3.length - 1];
              }
              const g2 = e[0];
              var h2 = c2[0];
              (-90 > g2 || 90 < g2) && (-90 > h2 || 90 < h2) && 0 < g2 !== 0 < h2 && (h2 = A((180 - (g2 + 360) % 360) / ((h2 + 360) % 360 - (g2 + 360) % 360), 0, 1), k.push({ i: f2, lat: e[1] + h2 * (c2[1] - e[1]), direction: 0 > g2 ? 1 : -1, previousLonLat: e, lonLat: c2 }));
            });
            if (k.length)
              if (p) {
                if (1 === k.length % 2) {
                  var f = k.slice().sort((a4, c2) => Math.abs(c2.lat) - Math.abs(a4.lat))[0];
                  F(k, f);
                }
                for (var c = k.length - 2; 0 <= c; ) {
                  var g = k[c].i, r2 = t(180 + 1e-6 * k[c].direction), x2 = t(180 - 1e-6 * k[c].direction);
                  g = a3.splice(g, k[c + 1].i - g, ...q.greatCircle([r2, k[c].lat], [r2, k[c + 1].lat], true));
                  g.push(...q.greatCircle([x2, k[c + 1].lat], [x2, k[c].lat], true));
                  h.push(g);
                  c -= 2;
                }
                if (f)
                  for (g = 0; g < h.length; g++) {
                    const {
                      direction: a4,
                      lat: k2
                    } = f;
                    c = h[g];
                    x2 = c.indexOf(f.lonLat);
                    if (-1 < x2) {
                      g = (0 > k2 ? -1 : 1) * this.maxLatitude;
                      var y2 = t(180 + 1e-6 * a4);
                      r2 = t(180 - 1e-6 * a4);
                      const e = q.greatCircle([y2, k2], [y2, g], true);
                      for (y2 += 120 * a4; -180 < y2 && 180 > y2; y2 += 120 * a4)
                        e.push([y2, g]);
                      e.push(...q.greatCircle([r2, g], [r2, f.lat], true));
                      c.splice(x2, 0, ...e);
                      break;
                    }
                  }
              } else
                for (f = k.length; f--; )
                  c = a3.splice(k[f].i, a3.length, [t(180 + 1e-6 * k[f].direction), k[f].lat]), c.unshift([t(180 - 1e-6 * k[f].direction), k[f].lat]), h.push(c);
            return h;
          }
          path(a3) {
            const { bounds: k, def: n, rotator: h } = this, f = [], c = "Polygon" === a3.type || "MultiPolygon" === a3.type, g = this.hasGeoProjection, t2 = !n || false !== n.antimeridianCutting, x2 = t2 ? h : void 0, A2 = t2 ? n || this : this;
            let e;
            k && (e = [[k.x1, k.y1], [k.x2, k.y1], [k.x2, k.y2], [k.x1, k.y2]]);
            const l = (a4) => {
              a4 = a4.map((a5) => {
                if (t2) {
                  x2 && (a5 = x2.forward(a5));
                  let b = a5[0];
                  1e-6 > Math.abs(b - 180) && (b = 180 > b ? 179.999999 : 180.000001);
                  a5 = [b, a5[1]];
                }
                return a5;
              });
              let h2 = [a4];
              g && (q.insertGreatCircles(a4), t2 && (h2 = this.cutOnAntimeridian(a4, c)));
              h2.forEach((a5) => {
                if (!(2 > a5.length)) {
                  var b = false, d = false, h3 = (a6) => {
                    b ? f.push(["L", a6[0], a6[1]]) : (f.push(["M", a6[0], a6[1]]), b = true);
                  }, l2 = false, n2 = false, u = a5.map((a6) => {
                    a6 = A2.forward(a6);
                    a6.outside ? l2 = true : n2 = true;
                    Infinity === a6[1] ? a6[1] = 1e10 : -Infinity === a6[1] && (a6[1] = -1e10);
                    return a6;
                  });
                  if (t2) {
                    c && u.push(u[0]);
                    if (l2) {
                      if (!n2)
                        return;
                      if (e) {
                        if (c)
                          u = y(u, e);
                        else if (k) {
                          r(u, e).forEach((a6) => {
                            b = false;
                            a6.forEach(h3);
                          });
                          return;
                        }
                      }
                    }
                    u.forEach(h3);
                  } else
                    for (let e2 = 0; e2 < u.length; e2++) {
                      const f2 = a5[e2], k2 = u[e2];
                      if (k2.outside)
                        d = true;
                      else {
                        if (c && !p) {
                          var p = f2;
                          a5.push(f2);
                          u.push(k2);
                        }
                        d && v && (c && g ? q.greatCircle(v, f2).forEach((a6) => h3(A2.forward(a6))) : b = false);
                        h3(k2);
                        var v = f2;
                        d = false;
                      }
                    }
                }
              });
            };
            "LineString" === a3.type ? l(a3.coordinates) : "MultiLineString" === a3.type ? a3.coordinates.forEach((a4) => l(a4)) : "Polygon" === a3.type ? (a3.coordinates.forEach((a4) => l(a4)), f.length && f.push(["Z"])) : "MultiPolygon" === a3.type && (a3.coordinates.forEach((a4) => {
              a4.forEach((a5) => l(a5));
            }), f.length && f.push(["Z"]));
            return f;
          }
        }
        q.registry = x;
        return q;
      });
      K(a, "Maps/MapView.js", [a["Maps/MapViewOptionsDefault.js"], a["Maps/MapViewInsetsOptionsDefault.js"], a["Extensions/GeoJSON.js"], a["Core/Chart/MapChart.js"], a["Maps/MapUtilities.js"], a["Maps/Projection.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A, F) {
        const { topo2geo: r } = G, { maps: t } = I, { boundsFromPath: q, pointInPolygon: k } = y, { addEvent: p, clamp: n, fireEvent: h, isArray: f, isNumber: c, isObject: g, isString: B, merge: C, pick: E, relativeLength: e } = F, l = (a3, b) => {
          const { width: c2, height: e2 } = b;
          return Math.log(400.979322 / Math.max((a3.x2 - a3.x1) / (c2 / 256), (a3.y2 - a3.y1) / (e2 / 256))) / Math.log(2);
        };
        class v {
          static mergeInsets(a3, b) {
            const c2 = (a4) => {
              const b2 = {};
              a4.forEach((a5, c3) => {
                b2[a5 && a5.id || `i${c3}`] = a5;
              });
              return b2;
            }, e2 = C(c2(a3), c2(b));
            return Object.keys(e2).map((a4) => e2[a4]);
          }
          createInsets() {
            const a3 = this.options, b = a3.insets;
            b && b.forEach((b2) => {
              b2 = new z(this, C(a3.insetOptions, b2));
              this.insets.push(b2);
            });
          }
          constructor(e2, b) {
            this.allowTransformAnimation = true;
            this.insets = [];
            this.padding = [0, 0, 0, 0];
            this.eventsToUnbind = [];
            let d, f2;
            if (!(this instanceof z)) {
              var g2 = [e2.options.chart.map, ...(e2.options.series || []).map((a4) => a4.mapData)].map((a4) => this.getGeoMap(a4));
              const a3 = [];
              g2.forEach((b3) => {
                if (b3 && (d || (d = b3["hc-recommended-mapview"]), b3.bbox)) {
                  const [c2, d2, e3, f3] = b3.bbox;
                  a3.push({ x1: c2, y1: d2, x2: e3, y2: f3 });
                }
              });
              const b2 = a3.length && v.compositeBounds(a3);
              h(e2, "beforeMapViewInit", { geoBounds: b2 }, function() {
                if (b2) {
                  const { x1: a4, y1: c2, x2: d2, y2: e3 } = b2;
                  f2 = 180 < d2 - a4 && 90 < e3 - c2 ? { name: "EqualEarth" } : { name: "LambertConformalConic", parallels: [c2, e3], rotation: [-(a4 + d2) / 2] };
                }
              });
              this.geoMap = g2[0];
            }
            this.userOptions = b || {};
            e2.options.mapView && e2.options.mapView.recommendedMapView && (d = e2.options.mapView.recommendedMapView);
            g2 = C(a2, { projection: f2 }, d, b);
            const k2 = d && d.insets;
            b = b && b.insets;
            k2 && b && (g2.insets = v.mergeInsets(k2, b));
            this.chart = e2;
            this.center = g2.center;
            this.options = g2;
            this.projection = new A(g2.projection);
            this.playingField = e2.plotBox;
            this.zoom = g2.zoom || 0;
            this.minZoom = g2.minZoom;
            this.createInsets();
            this.eventsToUnbind.push(p(e2, "afterSetChartSize", () => {
              this.playingField = this.getField();
              if (void 0 === this.minZoom || this.minZoom === this.zoom)
                this.fitToBounds(void 0, void 0, false), !this.chart.hasRendered && c(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && C(true, this.center, this.userOptions.center);
            }));
            this.setUpEvents();
          }
          fitToBounds(a3, b, c2 = true, g2) {
            const d = a3 || this.getProjectedBounds();
            if (d) {
              var h2 = E(b, a3 ? 0 : this.options.padding);
              b = this.getField(false);
              h2 = f(h2) ? h2 : [h2, h2, h2, h2];
              this.padding = [e(h2[0], b.height), e(h2[1], b.width), e(h2[2], b.height), e(h2[3], b.width)];
              this.playingField = this.getField();
              b = l(d, this.playingField);
              a3 || (this.minZoom = b);
              a3 = this.projection.inverse([(d.x2 + d.x1) / 2, (d.y2 + d.y1) / 2]);
              this.setView(a3, b, c2, g2);
            }
          }
          getField(a3 = true) {
            a3 = a3 ? this.padding : [0, 0, 0, 0];
            return { x: a3[3], y: a3[0], width: this.chart.plotWidth - a3[1] - a3[3], height: this.chart.plotHeight - a3[0] - a3[2] };
          }
          getGeoMap(a3) {
            if (B(a3))
              return t[a3] && "Topology" === t[a3].type ? r(t[a3]) : t[a3];
            if (g(a3, true)) {
              if ("FeatureCollection" === a3.type)
                return a3;
              if ("Topology" === a3.type)
                return r(a3);
            }
          }
          getMapBBox() {
            const a3 = this.getProjectedBounds(), b = this.getScale();
            if (a3) {
              const c2 = this.padding, e2 = this.projectedUnitsToPixels({ x: a3.x1, y: a3.y2 });
              return { width: (a3.x2 - a3.x1) * b + c2[1] + c2[3], height: (a3.y2 - a3.y1) * b + c2[0] + c2[2], x: e2.x - c2[3], y: e2.y - c2[0] };
            }
          }
          getProjectedBounds() {
            const a3 = this.projection;
            var b = this.chart.series.reduce((a4, b2) => {
              const c3 = b2.getProjectedBounds && b2.getProjectedBounds();
              c3 && false !== b2.options.affectsMapView && a4.push(c3);
              return a4;
            }, []), c2 = this.options.fitToGeometry;
            return c2 ? (this.fitToGeometryCache || ("MultiPoint" === c2.type ? (c2 = c2.coordinates.map((b2) => a3.forward(b2)), b = c2.map((a4) => a4[0]), c2 = c2.map((a4) => a4[1]), this.fitToGeometryCache = { x1: Math.min.apply(0, b), x2: Math.max.apply(0, b), y1: Math.min.apply(0, c2), y2: Math.max.apply(0, c2) }) : this.fitToGeometryCache = q(a3.path(c2))), this.fitToGeometryCache) : this.projection.bounds || v.compositeBounds(b);
          }
          getScale() {
            return 256 / 400.979322 * Math.pow(2, this.zoom);
          }
          getSVGTransform() {
            const {
              x: a3,
              y: b,
              width: c2,
              height: e2
            } = this.playingField, f2 = this.projection.forward(this.center);
            var g2 = this.projection.hasCoordinates ? -1 : 1;
            const h2 = this.getScale();
            g2 *= h2;
            return { scaleX: h2, scaleY: g2, translateX: a3 + c2 / 2 - f2[0] * h2, translateY: b + e2 / 2 - f2[1] * g2 };
          }
          lonLatToPixels(a3) {
            if (a3 = this.lonLatToProjectedUnits(a3))
              return this.projectedUnitsToPixels(a3);
          }
          lonLatToProjectedUnits(a3) {
            const b = this.chart, c2 = b.mapTransforms;
            if (c2) {
              for (const d in c2)
                if (Object.hasOwnProperty.call(c2, d) && c2[d].hitZone) {
                  var e2 = b.transformFromLatLon(a3, c2[d]);
                  if (e2 && k(e2, c2[d].hitZone.coordinates[0]))
                    return e2;
                }
              return b.transformFromLatLon(
                a3,
                c2["default"]
              );
            }
            for (e2 of this.insets)
              if (e2.options.geoBounds && k({ x: a3.lon, y: a3.lat }, e2.options.geoBounds.coordinates[0]))
                return a3 = e2.projection.forward([a3.lon, a3.lat]), a3 = e2.projectedUnitsToPixels({ x: a3[0], y: a3[1] }), this.pixelsToProjectedUnits(a3);
            a3 = this.projection.forward([a3.lon, a3.lat]);
            if (!a3.outside)
              return { x: a3[0], y: a3[1] };
          }
          projectedUnitsToLonLat(a3) {
            var b = this.chart;
            const c2 = b.mapTransforms;
            if (c2) {
              for (const d in c2)
                if (Object.hasOwnProperty.call(c2, d) && c2[d].hitZone && k(a3, c2[d].hitZone.coordinates[0]))
                  return b.transformToLatLon(
                    a3,
                    c2[d]
                  );
              return b.transformToLatLon(a3, c2["default"]);
            }
            b = this.projectedUnitsToPixels(a3);
            for (var e2 of this.insets)
              if (e2.hitZone && k(b, e2.hitZone.coordinates[0]))
                return a3 = e2.pixelsToProjectedUnits(b), e2 = e2.projection.inverse([a3.x, a3.y]), { lon: e2[0], lat: e2[1] };
            e2 = this.projection.inverse([a3.x, a3.y]);
            return { lon: e2[0], lat: e2[1] };
          }
          redraw(a3) {
            this.chart.series.forEach((a4) => {
              a4.useMapGeometry && (a4.isDirty = true);
            });
            this.chart.redraw(a3);
          }
          setView(a3, b, d = true, e2) {
            a3 && (this.center = a3);
            "number" === typeof b && ("number" === typeof this.minZoom && (b = Math.max(
              b,
              this.minZoom
            )), "number" === typeof this.options.maxZoom && (b = Math.min(b, this.options.maxZoom)), c(b) && (this.zoom = b));
            var f2 = this.getProjectedBounds();
            if (f2) {
              a3 = this.projection.forward(this.center);
              const { x: c2, y: d2, width: e3, height: h2 } = this.playingField;
              b = this.getScale();
              var g2 = this.projectedUnitsToPixels({ x: f2.x1, y: f2.y1 }), k2 = this.projectedUnitsToPixels({ x: f2.x2, y: f2.y2 });
              f2 = [(f2.x1 + f2.x2) / 2, (f2.y1 + f2.y2) / 2];
              if (!this.chart.series.some((a4) => a4.isDrilling)) {
                const l2 = g2.x, m = k2.y;
                k2 = k2.x;
                g2 = g2.y;
                k2 - l2 < e3 ? a3[0] = f2[0] : l2 < c2 && k2 < c2 + e3 ? a3[0] += Math.max(l2 - c2, k2 - e3 - c2) / b : k2 > c2 + e3 && l2 > c2 && (a3[0] += Math.min(k2 - e3 - c2, l2 - c2) / b);
                g2 - m < h2 ? a3[1] = f2[1] : m < d2 && g2 < d2 + h2 ? a3[1] -= Math.max(m - d2, g2 - h2 - d2) / b : g2 > d2 + h2 && m > d2 && (a3[1] -= Math.min(g2 - h2 - d2, m - d2) / b);
                this.center = this.projection.inverse(a3);
              }
              this.insets.forEach((a4) => {
                a4.options.field && (a4.hitZone = a4.getHitZone(), a4.playingField = a4.getField());
              });
              this.render();
            }
            h(this, "afterSetView");
            d && this.redraw(e2);
          }
          projectedUnitsToPixels(a3) {
            const b = this.getScale(), c2 = this.projection.forward(this.center), e2 = this.playingField;
            return { x: e2.x + e2.width / 2 - b * (c2[0] - a3.x), y: e2.y + e2.height / 2 + b * (c2[1] - a3.y) };
          }
          pixelsToLonLat(a3) {
            return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(a3));
          }
          pixelsToProjectedUnits(a3) {
            const { x: b, y: c2 } = a3;
            a3 = this.getScale();
            const e2 = this.projection.forward(this.center), f2 = this.playingField;
            return { x: e2[0] + (b - (f2.x + f2.width / 2)) / a3, y: e2[1] - (c2 - (f2.y + f2.height / 2)) / a3 };
          }
          setUpEvents() {
            const { chart: a3 } = this;
            let b, d, e2;
            const f2 = (f3) => {
              var g2 = a3.pointer.pinchDown, h2 = this.projection;
              let { mouseDownX: k2, mouseDownY: m } = a3;
              1 === g2.length && (k2 = g2[0].chartX, m = g2[0].chartY);
              if ("number" === typeof k2 && "number" === typeof m) {
                g2 = `${k2},${m}`;
                const { chartX: p2, chartY: q2 } = f3.originalEvent;
                g2 !== d && (d = g2, b = this.projection.forward(this.center), e2 = (this.projection.options.rotation || [0, 0]).slice());
                g2 = (g2 = h2.def && h2.def.bounds) && l(g2, this.playingField) || -Infinity;
                if ("Orthographic" === h2.options.name && (this.minZoom || Infinity) < 1.3 * g2) {
                  if (g2 = 440 / (this.getScale() * Math.min(a3.plotWidth, a3.plotHeight)), e2) {
                    h2 = (k2 - p2) * g2 - e2[0];
                    g2 = n(-e2[1] - (m - q2) * g2, -80, 80);
                    const b2 = this.zoom;
                    this.update({ projection: { rotation: [-h2, -g2] } }, false);
                    this.fitToBounds(
                      void 0,
                      void 0,
                      false
                    );
                    this.zoom = b2;
                    a3.redraw(false);
                  }
                } else
                  c(p2) && c(q2) && (h2 = this.getScale(), h2 = this.projection.inverse([b[0] + (k2 - p2) / h2, b[1] - (m - q2) / h2 * (this.projection.hasCoordinates ? 1 : -1)]), this.setView(h2, void 0, true, false));
                f3.preventDefault();
              }
            };
            p(a3, "pan", f2);
            p(a3, "touchpan", f2);
            p(a3, "selection", (b2) => {
              if (b2.resetSelection)
                this.zoomBy();
              else {
                const c2 = b2.x - a3.plotLeft, d2 = b2.y - a3.plotTop, { y: e3, x: f3 } = this.pixelsToProjectedUnits({ x: c2, y: d2 }), { y: g2, x: h2 } = this.pixelsToProjectedUnits({ x: c2 + b2.width, y: d2 + b2.height });
                this.fitToBounds(
                  { x1: f3, y1: e3, x2: h2, y2: g2 },
                  void 0,
                  true,
                  b2.originalEvent.touches ? false : void 0
                );
                /^touch/.test(b2.originalEvent.type) || a3.showResetZoom();
                b2.preventDefault();
              }
            });
          }
          render() {
            this.group || (this.group = this.chart.renderer.g("map-view").attr({ zIndex: 4 }).add());
          }
          update(a3, b = true, d) {
            var e2 = a3.projection;
            e2 = e2 && A.toString(e2) !== A.toString(this.options.projection);
            let f2 = false;
            C(true, this.userOptions, a3);
            C(true, this.options, a3);
            "insets" in a3 && (this.insets.forEach((a4) => a4.destroy()), this.insets.length = 0, f2 = true);
            (e2 || "fitToGeometry" in a3) && delete this.fitToGeometryCache;
            if (e2 || f2)
              this.chart.series.forEach((a4) => {
                const b2 = a4.transformGroups;
                a4.clearBounds && a4.clearBounds();
                a4.isDirty = true;
                a4.isDirtyData = true;
                if (f2 && b2)
                  for (; 1 < b2.length; )
                    (a4 = b2.pop()) && a4.destroy();
              }), e2 && (this.projection = new A(this.options.projection)), f2 && this.createInsets(), a3.center || !Object.hasOwnProperty.call(a3, "zoom") || c(a3.zoom) || this.fitToBounds(void 0, void 0, false);
            a3.center || c(a3.zoom) ? this.setView(this.options.center, a3.zoom, false) : "fitToGeometry" in a3 && this.fitToBounds(void 0, void 0, false);
            b && this.chart.redraw(d);
          }
          zoomBy(a3, b, c2, e2) {
            var d = this.chart;
            const f2 = this.projection.forward(this.center);
            let [g2, h2] = b ? this.projection.forward(b) : [];
            if ("number" === typeof a3) {
              a3 = this.zoom + a3;
              if (c2) {
                const [a4, e3] = c2;
                c2 = this.getScale();
                b = e3 - d.plotTop - d.plotHeight / 2;
                g2 = f2[0] + (a4 - d.plotLeft - d.plotWidth / 2) / c2;
                h2 = f2[1] + b / c2;
              }
              if ("number" === typeof g2 && "number" === typeof h2) {
                d = 1 - Math.pow(2, this.zoom) / Math.pow(2, a3);
                var k2 = f2[1] - h2;
                f2[0] -= (f2[0] - g2) * d;
                f2[1] += k2 * d;
                k2 = this.projection.inverse(f2);
              }
              this.setView(k2, a3, void 0, e2);
            } else
              this.fitToBounds(void 0, void 0, void 0, e2);
          }
        }
        v.compositeBounds = (a3) => {
          if (a3.length)
            return a3.slice(1).reduce((a4, c2) => {
              a4.x1 = Math.min(
                a4.x1,
                c2.x1
              );
              a4.y1 = Math.min(a4.y1, c2.y1);
              a4.x2 = Math.max(a4.x2, c2.x2);
              a4.y2 = Math.max(a4.y2, c2.y2);
              return a4;
            }, C(a3[0]));
        };
        class z extends v {
          constructor(a3, b) {
            super(a3.chart, b);
            this.id = b.id;
            this.mapView = a3;
            this.options = C(x, b);
            this.allBounds = [];
            this.options.geoBounds && (a3 = a3.projection.path(this.options.geoBounds), this.geoBoundsProjectedBox = q(a3), this.geoBoundsProjectedPolygon = a3.map((a4) => [a4[1] || 0, a4[2] || 0]));
          }
          getField(a3 = true) {
            var b = this.hitZone;
            if (b) {
              var d = a3 ? this.padding : [0, 0, 0, 0];
              b = b.coordinates[0];
              var e2 = b.map((a4) => a4[0]);
              const f2 = b.map((a4) => a4[1]);
              b = Math.min.apply(0, e2) + d[3];
              e2 = Math.max.apply(0, e2) - d[1];
              const g2 = Math.min.apply(0, f2) + d[0];
              d = Math.max.apply(0, f2) - d[2];
              if (c(b) && c(g2))
                return { x: b, y: g2, width: e2 - b, height: d - g2 };
            }
            return super.getField.call(this, a3);
          }
          getHitZone() {
            const { chart: a3, mapView: b, options: c2 } = this;
            var { coordinates: f2 } = c2.field || {};
            if (f2) {
              f2 = f2[0];
              if ("percent" === c2.units) {
                const d = "mapBoundingBox" === c2.relativeTo && b.getMapBBox() || C(a3.plotBox, { x: 0, y: 0 });
                f2 = f2.map((a4) => [e(`${a4[0]}%`, d.width, d.x), e(`${a4[1]}%`, d.height, d.y)]);
              }
              return { type: "Polygon", coordinates: [f2] };
            }
          }
          getProjectedBounds() {
            return v.compositeBounds(this.allBounds);
          }
          isInside(a3) {
            const {
              geoBoundsProjectedBox: b,
              geoBoundsProjectedPolygon: c2
            } = this;
            return !!(b && a3.x >= b.x1 && a3.x <= b.x2 && a3.y >= b.y1 && a3.y <= b.y2 && c2 && k(a3, c2));
          }
          render() {
            const { chart: a3, mapView: b, options: c2 } = this;
            var f2 = c2.borderPath || c2.field;
            if (f2 && b.group) {
              let d = true;
              this.border || (this.border = a3.renderer.path().addClass("highcharts-mapview-inset-border").add(b.group), d = false);
              a3.styledMode || this.border.attr({ stroke: c2.borderColor, "stroke-width": c2.borderWidth });
              const g2 = Math.round(this.border.strokeWidth()) % 2 / 2, h2 = "mapBoundingBox" === c2.relativeTo && b.getMapBBox() || b.playingField;
              f2 = (f2.coordinates || []).reduce((b2, d2) => d2.reduce((b3, d3, f3) => {
                let [k2, l2] = d3;
                "percent" === c2.units && (k2 = a3.plotLeft + e(`${k2}%`, h2.width, h2.x), l2 = a3.plotTop + e(`${l2}%`, h2.height, h2.y));
                k2 = Math.floor(k2) + g2;
                l2 = Math.floor(l2) + g2;
                b3.push(0 === f3 ? ["M", k2, l2] : ["L", k2, l2]);
                return b3;
              }, b2), []);
              this.border[d ? "animate" : "attr"]({ d: f2 });
            }
          }
          destroy() {
            this.border && (this.border = this.border.destroy());
            this.eventsToUnbind.forEach((a3) => a3());
          }
          setUpEvents() {
          }
        }
        p(I, "afterInit", function() {
          this.mapView = new v(this, this.options.mapView);
        });
        return v;
      });
      K(
        a,
        "Series/Map/MapSeries.js",
        [a["Core/Animation/AnimationUtilities.js"], a["Series/ColorMapComposition.js"], a["Series/CenteredUtilities.js"], a["Core/Globals.js"], a["Core/Chart/MapChart.js"], a["Series/Map/MapPoint.js"], a["Maps/MapView.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]],
        function(a2, x, G, I, y, A, F, D, t, q, k) {
          const { animObject: p, stop: n } = a2;
          ({ noop: a2 } = I);
          const { splitPath: h } = y, { seriesTypes: { column: f, scatter: c } } = t, {
            extend: g,
            find: r,
            fireEvent: C,
            getNestedProperty: E,
            isArray: e,
            defined: l,
            isNumber: v,
            isObject: z,
            merge: u,
            objectEach: b,
            pick: d,
            splat: m
          } = k;
          class w extends c {
            constructor() {
              super(...arguments);
              this.points = this.options = this.joinBy = this.group = this.data = this.chart = void 0;
              this.processedData = [];
            }
            animate(a3) {
              const { chart: b2, group: c2 } = this, d2 = p(this.options.animation);
              a3 ? c2.attr({ translateX: b2.plotLeft + b2.plotWidth / 2, translateY: b2.plotTop + b2.plotHeight / 2, scaleX: 1e-3, scaleY: 1e-3 }) : c2.animate({ translateX: b2.plotLeft, translateY: b2.plotTop, scaleX: 1, scaleY: 1 }, d2);
            }
            clearBounds() {
              this.points.forEach((a3) => {
                delete a3.bounds;
                delete a3.insetIndex;
                delete a3.projectedPath;
              });
              delete this.bounds;
            }
            doFullTranslate() {
              return !(!this.isDirtyData && !this.chart.isResizing && this.hasRendered);
            }
            drawMapDataLabels() {
              D.prototype.drawDataLabels.call(this);
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            }
            drawPoints() {
              const a3 = this, { chart: b2, group: c2, transformGroups: e2 = [] } = this, { mapView: g2, renderer: h2 } = b2;
              g2 && (this.transformGroups = e2, e2[0] || (e2[0] = h2.g().add(c2)), g2.insets.forEach((a4, b3) => {
                e2[b3 + 1] || e2.push(h2.g().add(c2));
              }), this.doFullTranslate() && (this.points.forEach((a4) => {
                const { graphic: c3, shapeArgs: d2 } = a4;
                a4.group = e2["number" === typeof a4.insetIndex ? a4.insetIndex + 1 : 0];
                c3 && c3.parentGroup !== a4.group && c3.add(a4.group);
                d2 && b2.hasRendered && !b2.styledMode && (d2.fill = this.pointAttribs(a4, a4.state).fill);
              }), f.prototype.drawPoints.apply(this), this.points.forEach((c3) => {
                const e3 = c3.graphic;
                if (e3) {
                  const f2 = e3.animate;
                  let g3 = "";
                  c3.name && (g3 += "highcharts-name-" + c3.name.replace(/ /g, "-").toLowerCase());
                  c3.properties && c3.properties["hc-key"] && (g3 += " highcharts-key-" + c3.properties["hc-key"].toString().toLowerCase());
                  g3 && e3.addClass(g3);
                  b2.styledMode && e3.css(this.pointAttribs(c3, c3.selected && "select" || void 0));
                  e3.animate = function(c4, g4, h3) {
                    const k2 = v(c4["stroke-width"]) && !v(e3["stroke-width"]), l2 = v(e3["stroke-width"]) && !v(c4["stroke-width"]);
                    if (k2 || l2) {
                      const f3 = d(a3.getStrokeWidth(a3.options), 1) / (b2.mapView && b2.mapView.getScale() || 1);
                      k2 && (e3["stroke-width"] = f3);
                      l2 && (c4["stroke-width"] = f3);
                    }
                    return f2.call(e3, c4, g4, l2 ? function() {
                      e3.element.removeAttribute("stroke-width");
                      delete e3["stroke-width"];
                      h3 && h3.apply(this, arguments);
                    } : h3);
                  };
                }
              })), e2.forEach((c3, e3) => {
                const f2 = (0 === e3 ? g2 : g2.insets[e3 - 1]).getSVGTransform(), k2 = d(this.getStrokeWidth(this.options), 1), l2 = f2.scaleX, m2 = 0 < f2.scaleY ? 1 : -1, q2 = (b3) => {
                  (a3.points || []).forEach((a4) => {
                    const c4 = a4.graphic;
                    let d2;
                    c4 && c4["stroke-width"] && (d2 = this.getStrokeWidth(a4.options)) && c4.attr({ "stroke-width": d2 / b3 });
                  });
                };
                if (h2.globalAnimation && b2.hasRendered && g2.allowTransformAnimation) {
                  const a4 = Number(c3.attr("translateX")), b3 = Number(c3.attr("translateY")), d2 = Number(c3.attr("scaleX")), g3 = (e4, g4) => {
                    e4 = d2 + (l2 - d2) * g4.pos;
                    c3.attr({ translateX: a4 + (f2.translateX - a4) * g4.pos, translateY: b3 + (f2.translateY - b3) * g4.pos, scaleX: e4, scaleY: e4 * m2, "stroke-width": k2 / e4 });
                    q2(e4);
                  };
                  e3 = u(p(h2.globalAnimation));
                  const n2 = e3.step;
                  e3.step = function(a5) {
                    n2 && n2.apply(this, arguments);
                    g3.apply(this, arguments);
                  };
                  c3.attr({ animator: 0 }).animate({ animator: 1 }, e3, function() {
                    "boolean" !== typeof h2.globalAnimation && h2.globalAnimation.complete && h2.globalAnimation.complete({ applyDrilldown: true });
                  });
                } else
                  n(c3), c3.attr(u(f2, { "stroke-width": k2 / l2 })), q2(l2);
              }), this.isDrilling || this.drawMapDataLabels());
            }
            getProjectedBounds() {
              if (!this.bounds && this.chart.mapView) {
                const {
                  insets: a3,
                  projection: b2
                } = this.chart.mapView, c2 = [];
                (this.points || []).forEach(function(f2) {
                  if (f2.path || f2.geometry) {
                    "string" === typeof f2.path ? f2.path = h(f2.path) : e(f2.path) && "M" === f2.path[0] && (f2.path = q.prototype.pathToSegments(f2.path));
                    if (!f2.bounds) {
                      let c3 = f2.getProjectedBounds(b2);
                      if (c3) {
                        f2.labelrank = d(f2.labelrank, (c3.x2 - c3.x1) * (c3.y2 - c3.y1));
                        const { midX: b3, midY: e2 } = c3;
                        if (a3 && v(b3) && v(e2)) {
                          const d2 = r(a3, (a4) => a4.isInside({ x: b3, y: e2 }));
                          d2 && (delete f2.projectedPath, (c3 = f2.getProjectedBounds(d2.projection)) && d2.allBounds.push(c3), f2.insetIndex = a3.indexOf(d2));
                        }
                        f2.bounds = c3;
                      }
                    }
                    f2.bounds && void 0 === f2.insetIndex && c2.push(f2.bounds);
                  }
                });
                this.bounds = F.compositeBounds(c2);
              }
              return this.bounds;
            }
            getStrokeWidth(a3) {
              const b2 = this.pointAttrToOptions;
              return a3[b2 && b2["stroke-width"] || "borderWidth"];
            }
            hasData() {
              return !!this.processedXData.length;
            }
            pointAttribs(a3, b2) {
              var c2;
              const { mapView: d2, styledMode: e2 } = a3.series.chart, g2 = e2 ? this.colorAttribs(a3) : f.prototype.pointAttribs.call(this, a3, b2);
              let h2 = this.getStrokeWidth(a3.options);
              if (b2) {
                b2 = u(this.options.states[b2], a3.options.states && a3.options.states[b2] || {});
                const d3 = this.getStrokeWidth(b2);
                l(d3) && (h2 = d3);
                g2.stroke = null !== (c2 = b2.borderColor) && void 0 !== c2 ? c2 : a3.color;
              }
              h2 && d2 && (h2 /= d2.getScale());
              c2 = this.getStrokeWidth(this.options);
              g2.dashstyle && d2 && v(c2) && (h2 = c2 / d2.getScale());
              a3.visible || (g2.fill = this.options.nullColor);
              l(h2) ? g2["stroke-width"] = h2 : delete g2["stroke-width"];
              g2["stroke-linecap"] = g2["stroke-linejoin"] = this.options.linecap;
              return g2;
            }
            updateData() {
              return this.processedData ? false : super.updateData.apply(this, arguments);
            }
            setData(a3, b2 = true, c2, d2) {
              delete this.bounds;
              super.setData.call(
                this,
                a3,
                false,
                void 0,
                d2
              );
              this.processData();
              this.generatePoints();
              b2 && this.chart.redraw(c2);
            }
            processData() {
              const a3 = this.options, c2 = a3.data;
              var d2 = this.chart.options.chart;
              const f2 = this.joinBy, g2 = a3.keys || this.pointArrayMap, h2 = [], k2 = {};
              var l2 = this.chart.mapView;
              l2 = l2 && (z(a3.mapData, true) ? l2.getGeoMap(a3.mapData) : l2.geoMap);
              var m2 = this.chart.mapTransforms;
              (this.chart.mapTransforms = m2 = d2.mapTransforms || l2 && l2["hc-transform"] || m2) && b(m2, function(a4) {
                a4.rotation && (a4.cosAngle = Math.cos(a4.rotation), a4.sinAngle = Math.sin(a4.rotation));
              });
              let n2;
              e(a3.mapData) ? n2 = a3.mapData : l2 && "FeatureCollection" === l2.type && (this.mapTitle = l2.title, n2 = I.geojson(l2, this.type, this));
              const p2 = this.processedData = [];
              c2 && c2.forEach(function(b2, d3) {
                let h3 = 0;
                if (v(b2))
                  p2[d3] = { value: b2 };
                else if (e(b2)) {
                  p2[d3] = {};
                  !a3.keys && b2.length > g2.length && "string" === typeof b2[0] && (p2[d3]["hc-key"] = b2[0], ++h3);
                  for (let a4 = 0; a4 < g2.length; ++a4, ++h3)
                    g2[a4] && "undefined" !== typeof b2[h3] && (0 < g2[a4].indexOf(".") ? A.prototype.setNestedProperty(p2[d3], b2[h3], g2[a4]) : p2[d3][g2[a4]] = b2[h3]);
                } else
                  p2[d3] = c2[d3];
                f2 && "_i" === f2[0] && (p2[d3]._i = d3);
              });
              if (n2) {
                this.mapData = n2;
                this.mapMap = {};
                for (m2 = 0; m2 < n2.length; m2++)
                  d2 = n2[m2], l2 = d2.properties, d2._i = m2, f2[0] && l2 && l2[f2[0]] && (d2[f2[0]] = l2[f2[0]]), k2[d2[f2[0]]] = d2;
                this.mapMap = k2;
                if (f2[1]) {
                  const a4 = f2[1];
                  p2.forEach(function(b2) {
                    b2 = E(a4, b2);
                    k2[b2] && h2.push(k2[b2]);
                  });
                }
                if (a3.allAreas) {
                  if (f2[1]) {
                    const a5 = f2[1];
                    p2.forEach(function(b2) {
                      h2.push(E(a5, b2));
                    });
                  }
                  const a4 = "|" + h2.map(function(a5) {
                    return a5 && a5[f2[0]];
                  }).join("|") + "|";
                  n2.forEach(function(b2) {
                    f2[0] && -1 !== a4.indexOf("|" + b2[f2[0]] + "|") || p2.push(u(b2, { value: null }));
                  });
                }
              }
              this.processedXData = Array(p2.length);
            }
            setOptions(a3) {
              a3 = D.prototype.setOptions.call(
                this,
                a3
              );
              let b2 = a3.joinBy;
              null === b2 && (b2 = "_i");
              b2 = this.joinBy = m(b2);
              b2[1] || (b2[1] = b2[0]);
              return a3;
            }
            translate() {
              const a3 = this.doFullTranslate(), b2 = this.chart.mapView, c2 = b2 && b2.projection;
              !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, !b2 || b2.userOptions.center || v(b2.userOptions.zoom) || b2.zoom !== b2.minZoom ? this.getProjectedBounds() : b2.fitToBounds(void 0, void 0, false));
              if (b2) {
                const d2 = b2.getSVGTransform();
                this.points.forEach(function(e2) {
                  const f2 = v(e2.insetIndex) && b2.insets[e2.insetIndex].getSVGTransform() || d2;
                  f2 && e2.bounds && v(e2.bounds.midX) && v(e2.bounds.midY) && (e2.plotX = e2.bounds.midX * f2.scaleX + f2.translateX, e2.plotY = e2.bounds.midY * f2.scaleY + f2.translateY);
                  a3 && (e2.shapeType = "path", e2.shapeArgs = { d: A.getProjectedPath(e2, c2) });
                  e2.projectedPath && !e2.projectedPath.length ? e2.setVisible(false) : e2.setVisible(true);
                });
              }
              C(this, "afterTranslate");
            }
          }
          w.defaultOptions = u(c.defaultOptions, { affectsMapView: true, animation: false, dataLabels: { crop: false, formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { value: b2 } = this.point;
            return v(b2) ? a3(b2, -1) : "";
          }, inside: true, overflow: false, padding: 0, verticalAlign: "middle" }, linecap: "round", marker: null, nullColor: "#f7f7f7", stickyTracking: false, tooltip: { followPointer: true, pointFormat: "{point.name}: {point.value}<br/>" }, turboThreshold: 0, allAreas: true, borderColor: "#e6e6e6", borderWidth: 1, joinBy: "hc-key", states: { hover: { halo: void 0, borderColor: "#666666", borderWidth: 2 }, normal: { animation: true }, select: { color: "#cccccc" } }, legendSymbol: "rectangle" });
          g(w.prototype, {
            type: "map",
            axisTypes: x.seriesMembers.axisTypes,
            colorAttribs: x.seriesMembers.colorAttribs,
            colorKey: x.seriesMembers.colorKey,
            directTouch: true,
            drawDataLabels: a2,
            drawGraph: a2,
            forceDL: true,
            getCenter: G.getCenter,
            getExtremesFromAll: true,
            getSymbol: a2,
            isCartesian: false,
            parallelArrays: x.seriesMembers.parallelArrays,
            pointArrayMap: x.seriesMembers.pointArrayMap,
            pointClass: A,
            preserveAspectRatio: true,
            searchPoint: a2,
            trackerGroups: x.seriesMembers.trackerGroups,
            useMapGeometry: true
          });
          x.compose(w);
          t.registerSeriesType("map", w);
          "";
          return w;
        }
      );
      K(
        a,
        "Series/MapLine/MapLineSeries.js",
        [a["Series/Map/MapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, x, G) {
          const { extend: r, merge: y } = G;
          class A extends a2 {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = void 0;
            }
            pointAttribs(r2, x2) {
              r2 = a2.prototype.pointAttribs.call(this, r2, x2);
              r2.fill = this.options.fillColor;
              return r2;
            }
          }
          A.defaultOptions = y(a2.defaultOptions, { lineWidth: 1, fillColor: "none", legendSymbol: "lineMarker" });
          r(A.prototype, { type: "mapline", colorProp: "stroke", pointAttrToOptions: {
            stroke: "color",
            "stroke-width": "lineWidth"
          } });
          x.registerSeriesType("mapline", A);
          "";
          return A;
        }
      );
      K(a, "Series/MapPoint/MapPointPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x) {
        ({ seriesTypes: { scatter: a2 } } = a2);
        const { isNumber: r } = x;
        class I extends a2.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
          }
          isValid() {
            return !!(this.options.geometry || r(this.x) && r(this.y) || r(this.options.lon) && r(this.options.lat));
          }
        }
        return I;
      });
      K(
        a,
        "Series/MapPoint/MapPointSeries.js",
        [a["Core/Globals.js"], a["Series/MapPoint/MapPointPoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]],
        function(a2, x, G, I, y) {
          ({ noop: a2 } = a2);
          const { seriesTypes: { map: r, scatter: F } } = G, { extend: D, fireEvent: t, isNumber: q, merge: k } = y;
          class p extends F {
            constructor() {
              super(...arguments);
              this.points = this.options = this.data = this.chart = void 0;
              this.clearBounds = r.prototype.clearBounds;
            }
            drawDataLabels() {
              super.drawDataLabels();
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            }
            projectPoint(a3) {
              const h = this.chart.mapView;
              if (h) {
                const { geometry: f, lon: c, lat: g } = a3;
                a3 = f && "Point" === f.type && f.coordinates;
                q(c) && q(g) && (a3 = [c, g]);
                if (a3)
                  return h.lonLatToProjectedUnits({ lon: a3[0], lat: a3[1] });
              }
            }
            translate() {
              const a3 = this.chart.mapView;
              this.processedXData || this.processData();
              this.generatePoints();
              this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds());
              if (a3) {
                const h = a3.getSVGTransform(), { hasCoordinates: f } = a3.projection;
                this.points.forEach((c) => {
                  let { x: g, y: k2 } = c;
                  var n = q(c.insetIndex) && a3.insets[c.insetIndex].getSVGTransform() || h;
                  const p2 = this.projectPoint(c.options) || c.properties && this.projectPoint(c.properties);
                  let e;
                  p2 ? (g = p2.x, k2 = p2.y) : c.bounds && (g = c.bounds.midX, k2 = c.bounds.midY, n && q(g) && q(k2) && (c.plotX = g * n.scaleX + n.translateX, c.plotY = k2 * n.scaleY + n.translateY, e = true));
                  q(g) && q(k2) ? e || (n = a3.projectedUnitsToPixels({ x: g, y: k2 }), c.plotX = n.x, c.plotY = f ? n.y : this.chart.plotHeight - n.y) : c.y = c.plotX = c.plotY = void 0;
                  c.isInside = this.isPointInside(c);
                  c.zone = this.zones.length ? c.getZone() : void 0;
                });
              }
              t(this, "afterTranslate");
            }
          }
          p.defaultOptions = k(
            F.defaultOptions,
            { dataLabels: { crop: false, defer: false, enabled: true, formatter: function() {
              return this.point.name;
            }, overflow: false, style: { color: "#000000" } }, legendSymbol: "lineMarker" }
          );
          I.prototype.symbols.mapmarker = (a3, h, f, c, g) => {
            const k2 = g && "legend" === g.context;
            k2 ? (a3 += f / 2, g = h + c) : g && "number" === typeof g.anchorX && "number" === typeof g.anchorY ? (a3 = g.anchorX, g = g.anchorY) : (a3 += f / 2, g = h + c / 2, h -= c);
            c = k2 ? c / 3 : c / 2;
            return [["M", a3, g], ["C", a3, g, a3 - c, h + 1.5 * c, a3 - c, h + c], ["A", c, c, 1, 1, 1, a3 + c, h + c], ["C", a3 + c, h + 1.5 * c, a3, g, a3, g], ["Z"]];
          };
          D(p.prototype, {
            type: "mappoint",
            axisTypes: ["colorAxis"],
            forceDL: true,
            isCartesian: false,
            pointClass: x,
            searchPoint: a2,
            useMapGeometry: true
          });
          G.registerSeriesType("mappoint", p);
          "";
          return p;
        }
      );
      K(a, "Series/Bubble/BubbleLegendDefaults.js", [], function() {
        return {
          borderColor: void 0,
          borderWidth: 2,
          className: void 0,
          color: void 0,
          connectorClassName: void 0,
          connectorColor: void 0,
          connectorDistance: 60,
          connectorWidth: 1,
          enabled: false,
          labels: { className: void 0, allowOverlap: false, format: "", formatter: void 0, align: "right", style: { fontSize: "0.9em", color: "#000000" }, x: 0, y: 0 },
          maxSize: 60,
          minSize: 10,
          legendIndex: 0,
          ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 },
          sizeBy: "area",
          sizeByAbsoluteValue: false,
          zIndex: 1,
          zThreshold: 0
        };
      });
      K(a, "Series/Bubble/BubbleLegendItem.js", [a["Core/Color/Color.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, x, G, I) {
        const { parse: r } = a2, { noop: A } = G, { arrayMax: F, arrayMin: D, isNumber: t, merge: q, pick: k, stableSort: p } = I;
        class n {
          constructor(a3, f) {
            this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.chart = void 0;
            this.setState = A;
            this.init(a3, f);
          }
          init(a3, f) {
            this.options = a3;
            this.visible = true;
            this.chart = f.chart;
            this.legend = f;
          }
          addToLegend(a3) {
            a3.splice(this.options.legendIndex, 0, this);
          }
          drawLegendSymbol(a3) {
            const f = k(a3.options.itemDistance, 20), c = this.legendItem || {}, g = this.options;
            var h = g.ranges, n2 = g.connectorDistance;
            if (h && h.length && t(h[0].value)) {
              p(h, function(a4, c2) {
                return c2.value - a4.value;
              });
              this.ranges = h;
              this.setOptions();
              this.render();
              a3 = this.getMaxLabelSize();
              var q2 = this.ranges[0].radius;
              h = 2 * q2;
              n2 = n2 - q2 + a3.width;
              n2 = 0 < n2 ? n2 : 0;
              this.maxLabel = a3;
              this.movementX = "left" === g.labels.align ? n2 : 0;
              c.labelWidth = h + n2 + f;
              c.labelHeight = h + a3.height / 2;
            } else
              a3.options.bubbleLegend.autoRanges = true;
          }
          setOptions() {
            const a3 = this.ranges, f = this.options, c = this.chart.series[f.seriesIndex], g = this.legend.baseline, n2 = { zIndex: f.zIndex, "stroke-width": f.borderWidth }, p2 = { zIndex: f.zIndex, "stroke-width": f.connectorWidth }, t2 = { align: this.legend.options.rtl || "left" === f.labels.align ? "right" : "left", zIndex: f.zIndex }, e = c.options.marker.fillOpacity, l = this.chart.styledMode;
            a3.forEach(function(h, x2) {
              l || (n2.stroke = k(h.borderColor, f.borderColor, c.color), n2.fill = k(h.color, f.color, 1 !== e ? r(c.color).setOpacity(e).get("rgba") : c.color), p2.stroke = k(h.connectorColor, f.connectorColor, c.color));
              a3[x2].radius = this.getRangeRadius(h.value);
              a3[x2] = q(a3[x2], { center: a3[0].radius - a3[x2].radius + g });
              l || q(true, a3[x2], { bubbleAttribs: q(n2), connectorAttribs: q(p2), labelAttribs: t2 });
            }, this);
          }
          getRangeRadius(a3) {
            const f = this.options;
            return this.chart.series[this.options.seriesIndex].getRadius.call(
              this,
              f.ranges[f.ranges.length - 1].value,
              f.ranges[0].value,
              f.minSize,
              f.maxSize,
              a3
            );
          }
          render() {
            const a3 = this.legendItem || {}, f = this.chart.renderer, c = this.options.zThreshold;
            this.symbols || (this.symbols = { connectors: [], bubbleItems: [], labels: [] });
            a3.symbol = f.g("bubble-legend");
            a3.label = f.g("bubble-legend-item").css(this.legend.itemStyle || {});
            a3.symbol.translateX = 0;
            a3.symbol.translateY = 0;
            a3.symbol.add(a3.label);
            a3.label.add(a3.group);
            for (const a4 of this.ranges)
              a4.value >= c && this.renderRange(a4);
            this.hideOverlappingLabels();
          }
          renderRange(a3) {
            var f = this.options;
            const c = f.labels;
            var g = this.chart;
            const h = g.series[f.seriesIndex], k2 = g.renderer, n2 = this.symbols;
            g = n2.labels;
            const e = a3.center, l = Math.abs(a3.radius);
            var p2 = f.connectorDistance || 0;
            const q2 = c.align, r2 = f.connectorWidth, b = this.ranges[0].radius || 0, d = e - l - f.borderWidth / 2 + r2 / 2, m = k2.styledMode;
            p2 = this.legend.options.rtl || "left" === q2 ? -p2 : p2;
            "center" === q2 && (p2 = 0, f.connectorDistance = 0, a3.labelAttribs.align = "center");
            n2.bubbleItems.push(k2.circle(b, e + ((d % 1 ? 1 : 0.5) - (r2 % 2 ? 0 : 0.5)), l).attr(m ? {} : a3.bubbleAttribs).addClass((m ? "highcharts-color-" + h.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (f.className || "")).add(this.legendItem.symbol));
            n2.connectors.push(k2.path(k2.crispLine([["M", b, d], ["L", b + p2, d]], f.connectorWidth)).attr(m ? {} : a3.connectorAttribs).addClass((m ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (f.connectorClassName || "")).add(this.legendItem.symbol));
            a3 = k2.text(this.formatLabel(a3)).attr(m ? {} : a3.labelAttribs).css(m ? {} : c.style).addClass("highcharts-bubble-legend-labels " + (f.labels.className || "")).add(this.legendItem.symbol);
            f = { x: b + p2 + f.labels.x, y: d + f.labels.y + 0.4 * a3.getBBox().height };
            a3.attr(f);
            g.push(a3);
            a3.placed = true;
            a3.alignAttr = f;
          }
          getMaxLabelSize() {
            let a3, f;
            this.symbols.labels.forEach(function(c) {
              f = c.getBBox(true);
              a3 = a3 ? f.width > a3.width ? f : a3 : f;
            });
            return a3 || {};
          }
          formatLabel(a3) {
            var f = this.options;
            const c = f.labels.formatter;
            f = f.labels.format;
            const { numberFormatter: g } = this.chart;
            return f ? x.format(f, a3) : c ? c.call(a3) : g(a3.value, 1);
          }
          hideOverlappingLabels() {
            const a3 = this.chart, f = this.symbols;
            !this.options.labels.allowOverlap && f && (a3.hideOverlappingLabels(f.labels), f.labels.forEach(function(a4, g) {
              a4.newOpacity ? a4.newOpacity !== a4.oldOpacity && f.connectors[g].show() : f.connectors[g].hide();
            }));
          }
          getRanges() {
            const a3 = this.legend.bubbleLegend, f = a3.options.ranges;
            let c, g, n2 = Number.MAX_VALUE, p2 = -Number.MAX_VALUE;
            a3.chart.series.forEach(function(a4) {
              a4.isBubble && !a4.ignoreSeries && (g = a4.zData.filter(t), g.length && (n2 = k(a4.options.zMin, Math.min(n2, Math.max(D(g), false === a4.options.displayNegative ? a4.options.zThreshold : -Number.MAX_VALUE))), p2 = k(a4.options.zMax, Math.max(p2, F(g)))));
            });
            c = n2 === p2 ? [{ value: p2 }] : [{ value: n2 }, { value: (n2 + p2) / 2 }, { value: p2, autoRanges: true }];
            f.length && f[0].radius && c.reverse();
            c.forEach(function(a4, e) {
              f && f[e] && (c[e] = q(f[e], a4));
            });
            return c;
          }
          predictBubbleSizes() {
            var a3 = this.chart, f = a3.legend.options, c = f.floating;
            const g = (f = "horizontal" === f.layout) ? a3.legend.lastLineHeight : 0, k2 = a3.plotSizeX, n2 = a3.plotSizeY;
            var p2 = a3.series[this.options.seriesIndex], e = p2.getPxExtremes();
            a3 = Math.ceil(e.minPxSize);
            e = Math.ceil(e.maxPxSize);
            const l = Math.min(n2, k2);
            p2 = p2.options.maxSize;
            if (c || !/%$/.test(p2))
              c = e;
            else if (p2 = parseFloat(p2), c = (l + g) * p2 / 100 / (p2 / 100 + 1), f && n2 - c >= k2 || !f && k2 - c >= n2)
              c = e;
            return [a3, Math.ceil(c)];
          }
          updateRanges(a3, f) {
            const c = this.legend.options.bubbleLegend;
            c.minSize = a3;
            c.maxSize = f;
            c.ranges = this.getRanges();
          }
          correctSizes() {
            const a3 = this.legend, f = this.chart.series[this.options.seriesIndex].getPxExtremes();
            1 < Math.abs(Math.ceil(f.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, f.maxPxSize), a3.render());
          }
        }
        "";
        return n;
      });
      K(
        a,
        "Series/Bubble/BubbleLegendComposition.js",
        [a["Series/Bubble/BubbleLegendDefaults.js"], a["Series/Bubble/BubbleLegendItem.js"], a["Core/Defaults.js"], a["Core/Utilities.js"]],
        function(a2, x, G, I) {
          function r(a3, f2, h2) {
            const c = this.legend;
            var g = 0 <= A(this);
            let e, k2;
            c && c.options.enabled && c.bubbleLegend && c.options.bubbleLegend.autoRanges && g ? (e = c.bubbleLegend.options, g = c.bubbleLegend.predictBubbleSizes(), c.bubbleLegend.updateRanges(g[0], g[1]), e.placed || (c.group.placed = false, c.allItems.forEach((a4) => {
              k2 = a4.legendItem || {};
              k2.group && (k2.group.translateY = null);
            })), c.render(), this.getMargins(), this.axes.forEach(function(a4) {
              a4.visible && a4.render();
              e.placed || (a4.setScale(), a4.updateNames(), n(a4.ticks, function(a5) {
                a5.isNew = true;
                a5.isNewLabel = true;
              }));
            }), e.placed = true, this.getMargins(), a3.call(this, f2, h2), c.bubbleLegend.correctSizes(), q(c, F(c))) : (a3.call(this, f2, h2), c && c.options.enabled && c.bubbleLegend && (c.render(), q(c, F(c))));
          }
          function A(a3) {
            a3 = a3.series;
            let c = 0;
            for (; c < a3.length; ) {
              if (a3[c] && a3[c].isBubble && a3[c].visible && a3[c].zData.length)
                return c;
              c++;
            }
            return -1;
          }
          function F(a3) {
            a3 = a3.allItems;
            const c = [], f2 = a3.length;
            let h2, k2, e = 0;
            for (k2 = 0; k2 < f2; k2++) {
              var l = a3[k2].legendItem || {};
              h2 = (a3[k2 + 1] || {}).legendItem || {};
              l.labelHeight && (a3[k2].itemHeight = l.labelHeight);
              if (a3[k2] === a3[f2 - 1] || l.y !== h2.y) {
                c.push({ height: 0 });
                l = c[c.length - 1];
                for (e; e <= k2; e++)
                  a3[e].itemHeight > l.height && (l.height = a3[e].itemHeight);
                l.step = k2;
              }
            }
            return c;
          }
          function D(a3) {
            const c = this.bubbleLegend, f2 = this.options, h2 = f2.bubbleLegend, k2 = A(this.chart);
            c && c.ranges && c.ranges.length && (h2.ranges.length && (h2.autoRanges = !!h2.ranges[0].autoRanges), this.destroyItem(c));
            0 <= k2 && f2.enabled && h2.enabled && (h2.seriesIndex = k2, this.bubbleLegend = new x(h2, this), this.bubbleLegend.addToLegend(a3.allItems));
          }
          function t(a3) {
            if (a3.defaultPrevented)
              return false;
            var c = this.chart;
            a3 = this.visible;
            const f2 = this.chart.legend;
            f2 && f2.bubbleLegend && (this.visible = !a3, this.ignoreSeries = a3, c = 0 <= A(c), f2.bubbleLegend.visible !== c && (f2.update({ bubbleLegend: { enabled: c } }), f2.bubbleLegend.visible = c), this.visible = a3);
          }
          function q(a3, f2) {
            const c = a3.options.rtl;
            let g, h2, e, k2, n2 = 0;
            a3.allItems.forEach((a4, l) => {
              k2 = a4.legendItem || {};
              if (k2.group) {
                g = k2.group.translateX || 0;
                h2 = k2.y || 0;
                if ((e = a4.movementX) || c && a4.ranges)
                  e = c ? g - a4.options.maxSize / 2 : g + e, k2.group.attr({ translateX: e });
                l > f2[n2].step && n2++;
                k2.group.attr({ translateY: Math.round(h2 + f2[n2].height / 2) });
                k2.y = h2 + f2[n2].height / 2;
              }
            });
          }
          const { setOptions: k } = G, { addEvent: p, objectEach: n, wrap: h } = I, f = [];
          return { compose: function(c, g, n2) {
            I.pushUnique(f, c) && (k({ legend: { bubbleLegend: a2 } }), h(c.prototype, "drawChartBox", r));
            I.pushUnique(f, g) && p(g, "afterGetAllItems", D);
            I.pushUnique(f, n2) && p(n2, "legendItemClick", t);
          } };
        }
      );
      K(
        a,
        "Series/Bubble/BubblePoint.js",
        [a["Core/Series/Point.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, x, G) {
          ({ seriesTypes: { scatter: { prototype: { pointClass: x } } } } = x);
          ({ extend: G } = G);
          class r extends x {
            constructor() {
              super(...arguments);
              this.series = this.options = void 0;
            }
            haloPath(r2) {
              return a2.prototype.haloPath.call(this, 0 === r2 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + r2);
            }
          }
          G(r.prototype, { ttBelow: false });
          return r;
        }
      );
      K(a, "Series/Bubble/BubbleSeries.js", [
        a["Series/Bubble/BubbleLegendComposition.js"],
        a["Series/Bubble/BubblePoint.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G, I, y, A) {
        function r() {
          const a3 = this.len, c2 = this.chart, e2 = this.isXAxis, f2 = e2 ? "xData" : "yData", b = this.min, d = this.max - b;
          let h2 = 0, k2 = a3, n2 = a3 / d, p2;
          this.series.forEach((a4) => {
            if (a4.bubblePadding && (a4.visible || !c2.options.chart.ignoreHiddenSeries)) {
              p2 = this.allowZoomOutside = true;
              const c3 = a4[f2];
              e2 && ((a4.onPoint || a4).getRadii(0, 0, a4), a4.onPoint && (a4.radii = a4.onPoint.radii));
              if (0 < d) {
                let d2 = c3.length;
                for (; d2--; )
                  if (g(c3[d2]) && this.dataMin <= c3[d2] && c3[d2] <= this.max) {
                    const e3 = a4.radii && a4.radii[d2] || 0;
                    h2 = Math.min((c3[d2] - b) * n2 - e3, h2);
                    k2 = Math.max((c3[d2] - b) * n2 + e3, k2);
                  }
              }
            }
          });
          p2 && 0 < d && !this.logarithmic && (k2 -= a3, n2 *= (a3 + Math.max(0, h2) - Math.min(k2, a3)) / a3, [["min", "userMin", h2], ["max", "userMax", k2]].forEach((a4) => {
            "undefined" === typeof C(this.options[a4[0]], this[a4[1]]) && (this[a4[0]] += a4[2] / n2);
          }));
        }
        const { parse: D } = G;
        ({ noop: G } = I);
        const { series: t, seriesTypes: { column: { prototype: q }, scatter: k } } = y, { addEvent: p, arrayMax: n, arrayMin: h, clamp: f, extend: c, isNumber: g, merge: B, pick: C } = A, E = [];
        class e extends k {
          constructor() {
            super(...arguments);
            this.zData = this.yData = this.radii = this.points = this.options = this.minPxSize = this.maxPxSize = this.data = void 0;
          }
          static compose(c2, e2, f2, g2) {
            a2.compose(e2, f2, g2);
            A.pushUnique(E, c2) && (c2.prototype.beforePadding = r);
          }
          animate(a3) {
            !a3 && this.points.length < this.options.animationLimit && this.points.forEach(
              function(a4) {
                const { graphic: c2 } = a4;
                c2 && c2.width && (this.hasRendered || c2.attr({ x: a4.plotX, y: a4.plotY, width: 1, height: 1 }), c2.animate(this.markerAttribs(a4), this.options.animation));
              },
              this
            );
          }
          getRadii() {
            const a3 = this.zData, c2 = this.yData, e2 = [];
            let f2, b, d, g2 = this.chart.bubbleZExtremes;
            const { minPxSize: h2, maxPxSize: k2 } = this.getPxExtremes();
            if (!g2) {
              let a4 = Number.MAX_VALUE, b2 = -Number.MAX_VALUE, c3;
              this.chart.series.forEach((d2) => {
                d2.bubblePadding && (d2.visible || !this.chart.options.chart.ignoreHiddenSeries) && (d2 = (d2.onPoint || d2).getZExtremes()) && (a4 = Math.min(C(a4, d2.zMin), d2.zMin), b2 = Math.max(C(b2, d2.zMax), d2.zMax), c3 = true);
              });
              c3 ? (g2 = { zMin: a4, zMax: b2 }, this.chart.bubbleZExtremes = g2) : g2 = { zMin: 0, zMax: 0 };
            }
            b = 0;
            for (f2 = a3.length; b < f2; b++)
              d = a3[b], e2.push(this.getRadius(g2.zMin, g2.zMax, h2, k2, d, c2 && c2[b]));
            this.radii = e2;
          }
          getRadius(a3, c2, e2, f2, b, d) {
            const h2 = this.options, k2 = "width" !== h2.sizeBy, l = h2.zThreshold;
            let n2 = c2 - a3, p2 = 0.5;
            if (null === d || null === b)
              return null;
            if (g(b)) {
              h2.sizeByAbsoluteValue && (b = Math.abs(b - l), n2 = Math.max(c2 - l, Math.abs(a3 - l)), a3 = 0);
              if (b < a3)
                return e2 / 2 - 1;
              0 < n2 && (p2 = (b - a3) / n2);
            }
            k2 && 0 <= p2 && (p2 = Math.sqrt(p2));
            return Math.ceil(e2 + p2 * (f2 - e2)) / 2;
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(a3, c2) {
            const e2 = this.options.marker.fillOpacity;
            a3 = t.prototype.pointAttribs.call(
              this,
              a3,
              c2
            );
            1 !== e2 && (a3.fill = D(a3.fill).setOpacity(e2).get("rgba"));
            return a3;
          }
          translate() {
            super.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          translateBubble() {
            const { data: a3, options: e2, radii: f2 } = this, { minPxSize: h2 } = this.getPxExtremes();
            let b = a3.length;
            for (; b--; ) {
              const d = a3[b], k2 = f2 ? f2[b] : 0;
              "z" === this.zoneAxis && (d.negative = (d.z || 0) < (e2.zThreshold || 0));
              g(k2) && k2 >= h2 / 2 ? (d.marker = c(d.marker, { radius: k2, width: 2 * k2, height: 2 * k2 }), d.dlBox = { x: d.plotX - k2, y: d.plotY - k2, width: 2 * k2, height: 2 * k2 }) : (d.shapeArgs = d.plotY = d.dlBox = void 0, d.isInside = false);
            }
          }
          getPxExtremes() {
            const a3 = Math.min(this.chart.plotWidth, this.chart.plotHeight);
            var c2 = (c3) => {
              let b;
              "string" === typeof c3 && (b = /%$/.test(c3), c3 = parseInt(c3, 10));
              return b ? a3 * c3 / 100 : c3;
            };
            const e2 = c2(C(this.options.minSize, 8));
            c2 = Math.max(c2(C(this.options.maxSize, "20%")), e2);
            return { minPxSize: e2, maxPxSize: c2 };
          }
          getZExtremes() {
            var a3 = this.options;
            const c2 = (this.zData || []).filter(g);
            if (c2.length) {
              const e2 = C(a3.zMin, f(h(c2), false === a3.displayNegative ? a3.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
              a3 = C(a3.zMax, n(c2));
              if (g(e2) && g(a3))
                return { zMin: e2, zMax: a3 };
            }
          }
        }
        e.defaultOptions = B(k.defaultOptions, {
          dataLabels: { formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { z: c2 } = this.point;
            return g(c2) ? a3(c2, -1) : "";
          }, inside: true, verticalAlign: "middle" },
          animationLimit: 250,
          marker: { lineColor: null, lineWidth: 1, fillOpacity: 0.5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" },
          minSize: 8,
          maxSize: "20%",
          softThreshold: false,
          states: { hover: { halo: { size: 5 } } },
          tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" },
          turboThreshold: 0,
          zThreshold: 0,
          zoneAxis: "z"
        });
        c(e.prototype, { alignDataLabel: q.alignDataLabel, applyZones: G, bubblePadding: true, buildKDTree: G, directTouch: true, isBubble: true, pointArrayMap: ["y", "z"], pointClass: x, parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], specialGroup: "group", zoneAxis: "z" });
        p(e, "updatedData", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        p(e, "remove", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        y.registerSeriesType("bubble", e);
        "";
        "";
        return e;
      });
      K(a, "Series/MapBubble/MapBubblePoint.js", [
        a["Series/Bubble/BubblePoint.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, x, G) {
        ({ seriesTypes: { map: { prototype: { pointClass: { prototype: x } } } } } = x);
        ({ extend: G } = G);
        class r extends a2 {
          isValid() {
            return "number" === typeof this.z;
          }
        }
        G(r.prototype, { applyOptions: x.applyOptions, getProjectedBounds: x.getProjectedBounds });
        return r;
      });
      K(a, "Series/MapBubble/MapBubbleSeries.js", [a["Series/Bubble/BubbleSeries.js"], a["Series/MapBubble/MapBubblePoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x, G, I) {
        const { seriesTypes: { map: { prototype: r }, mappoint: { prototype: A } } } = G, { extend: F, merge: D } = I;
        class t extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
            this.clearBounds = r.clearBounds;
          }
          searchPoint(a3, k) {
            return this.searchKDTree({ clientX: a3.chartX - this.chart.plotLeft, plotY: a3.chartY - this.chart.plotTop }, k, a3);
          }
          translate() {
            A.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          updateParallelArrays(a3, k, p) {
            super.updateParallelArrays.call(this, a3, k, p);
            a3 = this.processedXData;
            k = this.xData;
            a3 && k && (a3.length = k.length);
          }
        }
        t.defaultOptions = D(a2.defaultOptions, { lineWidth: 0, animationLimit: 500, joinBy: "hc-key", tooltip: { pointFormat: "{point.name}: {point.z}" } });
        F(t.prototype, { type: "mapbubble", axisTypes: ["colorAxis"], getProjectedBounds: r.getProjectedBounds, isCartesian: false, pointArrayMap: ["z"], pointClass: x, processData: r.processData, projectPoint: A.projectPoint, setData: r.setData, setOptions: r.setOptions, updateData: r.updateData, useMapGeometry: true, xyFromShape: true });
        G.registerSeriesType(
          "mapbubble",
          t
        );
        "";
        return t;
      });
      K(a, "Series/Heatmap/HeatmapPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, x) {
        ({ seriesTypes: { scatter: { prototype: { pointClass: a2 } } } } = a2);
        const { clamp: r, defined: I, extend: y, pick: A } = x;
        class F extends a2 {
          constructor() {
            super(...arguments);
            this.y = this.x = this.value = this.series = this.options = void 0;
          }
          applyOptions(a3, r2) {
            (this.isNull || null === this.value) && delete this.color;
            super.applyOptions(a3, r2);
            this.formatPrefix = this.isNull || null === this.value ? "null" : "point";
            return this;
          }
          getCellAttributes() {
            var a3 = this.series;
            const t = a3.options, q = (t.colsize || 1) / 2, k = (t.rowsize || 1) / 2, p = a3.xAxis, n = a3.yAxis, h = this.options.marker || a3.options.marker;
            a3 = a3.pointPlacementToXValue();
            const f = A(this.pointPadding, t.pointPadding, 0), c = { x1: r(Math.round(p.len - p.translate(this.x - q, false, true, false, true, -a3)), -p.len, 2 * p.len), x2: r(Math.round(p.len - p.translate(this.x + q, false, true, false, true, -a3)), -p.len, 2 * p.len), y1: r(Math.round(n.translate(this.y - k, false, true, false, true)), -n.len, 2 * n.len), y2: r(Math.round(n.translate(this.y + k, false, true, false, true)), -n.len, 2 * n.len) };
            [[
              "width",
              "x"
            ], ["height", "y"]].forEach(function(a4) {
              var g = a4[0];
              a4 = a4[1];
              let k2 = a4 + "1", q2 = a4 + "2";
              const e = Math.abs(c[k2] - c[q2]), l = h && h.lineWidth || 0, r2 = Math.abs(c[k2] + c[q2]) / 2;
              g = h && h[g];
              I(g) && g < e && (g = g / 2 + l / 2, c[k2] = r2 - g, c[q2] = r2 + g);
              if (f) {
                if ("x" === a4 && p.reversed || "y" === a4 && !n.reversed)
                  k2 = q2, q2 = a4 + "1";
                c[k2] += f;
                c[q2] -= f;
              }
            });
            return c;
          }
          haloPath(a3) {
            if (!a3)
              return [];
            const { x: r2 = 0, y: q = 0, width: k = 0, height: p = 0 } = this.shapeArgs || {};
            return [["M", r2 - a3, q - a3], ["L", r2 - a3, q + p + a3], ["L", r2 + k + a3, q + p + a3], ["L", r2 + k + a3, q - a3], ["Z"]];
          }
          isValid() {
            return Infinity !== this.value && -Infinity !== this.value;
          }
        }
        y(F.prototype, { dataLabelOnNull: true, moveToTopOnHover: true, ttBelow: false });
        return F;
      });
      K(a, "Series/Heatmap/HeatmapSeries.js", [a["Core/Color/Color.js"], a["Series/ColorMapComposition.js"], a["Core/Globals.js"], a["Series/Heatmap/HeatmapPoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, x, G, I, y, A, F) {
        const { doc: r } = G, { series: t, seriesTypes: { column: q, scatter: k } } = y, { prototype: { symbols: p } } = A, {
          clamp: n,
          extend: h,
          fireEvent: f,
          isNumber: c,
          merge: g,
          pick: B,
          defined: C
        } = F;
        class E extends k {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = this.context = this.colorAxis = this.canvas = void 0;
            this.valueMin = this.valueMax = NaN;
          }
          drawPoints() {
            const a3 = this;
            var c2 = a3.options, f2 = c2.marker || {};
            if (c2.interpolation) {
              const { image: d, chart: e, xAxis: k2, yAxis: l, points: p2 } = a3;
              f2 = p2.length - 1;
              const { len: q2, reversed: r2 } = k2, { len: t2, reversed: v } = l, { min: u, max: x2 } = k2.getExtremes(), { min: y2, max: z } = l.getExtremes(), [A2, D] = [B(c2.colsize, 1), B(c2.rowsize, 1)];
              var g2 = e.inverted, h2 = A2 / 2;
              c2 = k2.userOptions.minPadding;
              var b = C(c2) && !(0 < c2);
              c2 = g2 || b;
              h2 = b && h2 || 0;
              const [E2, F2, G2] = [u - h2, x2 + 2 * h2, u + A2].map((b2) => n(Math.round(k2.len - k2.translate(b2, false, true, false, true, -a3.pointPlacementToXValue())), -k2.len, 2 * k2.len)), [I2, K2] = r2 ? [F2, E2] : [E2, F2];
              h2 = q2 / G2 / 2 / 2 / 2;
              g2 = g2 ? { width: q2, height: t2, x: 0, y: 0 } : { x: I2 - h2, width: K2 - h2, height: t2, y: 0 };
              if (!d || a3.isDirtyData) {
                const k3 = e.colorAxis && e.colorAxis[0];
                h2 = a3.getContext();
                if ((b = a3.canvas) && h2 && k3) {
                  const l2 = b.width = ~~((x2 - u) / A2) + 1, m = b.height = ~~((z - y2) / D) + 1, n2 = l2 * m, q3 = new Uint8ClampedArray(4 * n2), t3 = l2 - (c2 && 1 || 0), w = m - 1;
                  c2 = (a4) => {
                    a4 = k3.toColor(a4.value || 0, B(a4)).split(")")[0].split("(")[1].split(",").map((a5) => B(parseFloat(a5), parseInt(a5, 10)));
                    a4[3] = 255 * B(a4[3], 1);
                    return a4;
                  };
                  const C2 = r2 ? (a4) => t3 - a4 : (a4) => a4, E3 = v ? (a4) => w - a4 : (a4) => a4, F3 = (a4, b2) => Math.ceil(l2 * E3(~~((w - 0) / (z - y2) * (z - b2 - y2))) + C2(~~((t3 - 0) / (x2 - u) * (a4 - u))));
                  a3.buildKDTree();
                  a3.directTouch = false;
                  for (let a4 = 0; a4 < n2; a4++) {
                    const b2 = p2[~~((f2 - 0) / (q3.length - 4) * a4 * 4)], d2 = new Uint8ClampedArray(c2(b2));
                    q3.set(d2, 4 * F3(b2.x, b2.y));
                  }
                  h2.putImageData(new ImageData(q3, l2, m), 0, 0);
                  d ? d.attr(Object.assign(Object.assign({}, g2), { href: b.toDataURL() })) : a3.image = e.renderer.image(b.toDataURL()).attr(g2).add(a3.group);
                }
              } else
                d.width === g2.width && d.height === g2.height || d.attr(g2);
            } else if (f2.enabled || a3._hasPointMarkers)
              t.prototype.drawPoints.call(a3), a3.points.forEach((b2) => {
                b2.graphic && (b2.graphic[a3.chart.styledMode ? "css" : "animate"](a3.colorAttribs(b2)), null === b2.value && b2.graphic.addClass("highcharts-null-point"));
              });
          }
          getContext() {
            const { canvas: a3, context: c2 } = this;
            if (a3 && c2)
              c2.clearRect(0, 0, a3.width, a3.height);
            else
              return this.canvas = r.createElement("canvas"), this.context = this.canvas.getContext("2d") || void 0;
            return c2;
          }
          getExtremes() {
            const { dataMin: a3, dataMax: f2 } = t.prototype.getExtremes.call(this, this.valueData);
            c(a3) && (this.valueMin = a3);
            c(f2) && (this.valueMax = f2);
            return t.prototype.getExtremes.call(this);
          }
          getValidPoints(a3, c2) {
            return t.prototype.getValidPoints.call(this, a3, c2, true);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          init() {
            super.init.apply(this, arguments);
            const a3 = this.options;
            a3.pointRange = B(a3.pointRange, a3.colsize || 1);
            this.yAxis.axisPointRange = a3.rowsize || 1;
            p.ellipse = p.circle;
            a3.marker && c(a3.borderRadius) && (a3.marker.r = a3.borderRadius);
          }
          markerAttribs(a3, c2) {
            const e = a3.shapeArgs || {};
            if (a3.hasImage)
              return { x: a3.plotX, y: a3.plotY };
            if (c2 && "normal" !== c2) {
              var f2 = a3.options.marker || {};
              a3 = this.options.marker || {};
              a3 = a3.states && a3.states[c2] || {};
              f2 = f2.states && f2.states[c2] || {};
              c2 = (f2.width || a3.width || e.width || 0) + (f2.widthPlus || a3.widthPlus || 0);
              a3 = (f2.height || a3.height || e.height || 0) + (f2.heightPlus || a3.heightPlus || 0);
              return { x: (e.x || 0) + ((e.width || 0) - c2) / 2, y: (e.y || 0) + ((e.height || 0) - a3) / 2, width: c2, height: a3 };
            }
            return e;
          }
          pointAttribs(c2, f2) {
            const e = t.prototype.pointAttribs.call(this, c2, f2), h2 = this.options || {};
            var k2 = this.chart.options.plotOptions || {}, b = k2.series || {};
            const d = k2.heatmap || {};
            k2 = c2 && c2.options.borderColor || h2.borderColor || d.borderColor || b.borderColor;
            b = c2 && c2.options.borderWidth || h2.borderWidth || d.borderWidth || b.borderWidth || e["stroke-width"];
            e.stroke = c2 && c2.marker && c2.marker.lineColor || h2.marker && h2.marker.lineColor || k2 || this.color;
            e["stroke-width"] = b;
            f2 && "normal" !== f2 && (c2 = g(h2.states && h2.states[f2], h2.marker && h2.marker.states && h2.marker.states[f2], c2 && c2.options.states && c2.options.states[f2] || {}), e.fill = c2.color || a2.parse(e.fill).brighten(c2.brightness || 0).get(), e.stroke = c2.lineColor || e.stroke);
            return e;
          }
          translate() {
            const { borderRadius: a3, marker: h2 } = this.options, k2 = h2 && h2.symbol || "rect", n2 = p[k2] ? k2 : "rect", q2 = -1 !== ["circle", "square"].indexOf(n2);
            this.generatePoints();
            this.points.forEach(function(b) {
              const d = b.getCellAttributes();
              let e = Math.min(d.x1, d.x2);
              var f2 = Math.min(d.y1, d.y2);
              let h3 = Math.max(Math.abs(d.x2 - d.x1), 0), l = Math.max(Math.abs(d.y2 - d.y1), 0);
              b.hasImage = 0 === (b.marker && b.marker.symbol || k2 || "").indexOf("url");
              q2 && (f2 = Math.abs(h3 - l), e = Math.min(d.x1, d.x2) + (h3 < l ? 0 : f2 / 2), f2 = Math.min(d.y1, d.y2) + (h3 < l ? f2 / 2 : 0), h3 = l = Math.min(h3, l));
              b.hasImage && (b.marker = { width: h3, height: l });
              b.plotX = b.clientX = (d.x1 + d.x2) / 2;
              b.plotY = (d.y1 + d.y2) / 2;
              b.shapeType = "path";
              b.shapeArgs = g(true, { x: e, y: f2, width: h3, height: l }, { d: p[n2](e, f2, h3, l, { r: c(a3) ? a3 : 0 }) });
            });
            f(this, "afterTranslate");
          }
        }
        E.defaultOptions = g(k.defaultOptions, { animation: false, borderRadius: 0, borderWidth: 0, interpolation: false, nullColor: "#f7f7f7", dataLabels: { formatter: function() {
          const { numberFormatter: a3 } = this.series.chart, { value: f2 } = this.point;
          return c(f2) ? a3(f2, -1) : "";
        }, inside: true, verticalAlign: "middle", crop: false, overflow: "allow", padding: 0 }, marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } }, clip: true, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { hover: { halo: false, brightness: 0.2 } }, legendSymbol: "rectangle" });
        h(E.prototype, { axisTypes: x.seriesMembers.axisTypes, colorKey: x.seriesMembers.colorKey, directTouch: true, getExtremesFromAll: true, parallelArrays: x.seriesMembers.parallelArrays, pointArrayMap: [
          "y",
          "value"
        ], pointClass: I, specialGroup: "group", trackerGroups: x.seriesMembers.trackerGroups, alignDataLabel: q.prototype.alignDataLabel, colorAttribs: x.seriesMembers.colorAttribs, getSymbol: t.prototype.getSymbol });
        x.compose(E);
        y.registerSeriesType("heatmap", E);
        "";
        "";
        return E;
      });
      K(a, "masters/modules/map.src.js", [a["Core/Globals.js"], a["Core/Axis/Color/ColorAxis.js"], a["Series/MapBubble/MapBubbleSeries.js"], a["Core/Chart/MapChart.js"], a["Maps/MapView.js"], a["Maps/Projection.js"]], function(a2, x, G, I, y, A) {
        a2.ColorAxis = x;
        a2.MapChart = I;
        a2.mapChart = a2.Map = I.mapChart;
        a2.MapView = y;
        a2.maps = I.maps;
        a2.Projection = A;
        x.compose(a2.Chart, a2.Fx, a2.Legend, a2.Series);
        G.compose(a2.Axis, a2.Chart, a2.Legend, a2.Series);
      });
      K(a, "masters/highmaps.src.js", [a["masters/highcharts.src.js"]], function(a2) {
        a2.product = "Highmaps";
        return a2;
      });
      a["masters/highmaps.src.js"]._modules = a;
      return a["masters/highmaps.src.js"];
    });
  }
});
export default require_highmaps();
//# sourceMappingURL=highcharts_highmaps.js.map
