import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/modules/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/highcharts/modules/accessibility.js"(exports, module) {
    (function(b) {
      "object" === typeof module && module.exports ? (b["default"] = b, module.exports = b) : "function" === typeof define && define.amd ? define("highcharts/modules/accessibility", ["highcharts"], function(x) {
        b(x);
        b.Highcharts = x;
        return b;
      }) : b("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(b) {
      function x(b2, r, q, l) {
        b2.hasOwnProperty(r) || (b2[r] = l.apply(null, q), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: r, module: b2[r] } })));
      }
      b = b ? b._modules : {};
      x(b, "Accessibility/Utils/HTMLUtilities.js", [b["Core/Globals.js"], b["Core/Utilities.js"]], function(b2, r) {
        function q(b3) {
          if ("function" === typeof u.MouseEvent)
            return new u.MouseEvent(b3.type, b3);
          if (m.createEvent) {
            const n = m.createEvent("MouseEvent");
            if (n.initMouseEvent)
              return n.initMouseEvent(b3.type, b3.bubbles, b3.cancelable, b3.view || u, b3.detail, b3.screenX, b3.screenY, b3.clientX, b3.clientY, b3.ctrlKey, b3.altKey, b3.shiftKey, b3.metaKey, b3.button, b3.relatedTarget), n;
          }
          return l(b3.type);
        }
        function l(b3, k, g) {
          k = k || {
            x: 0,
            y: 0
          };
          return "function" === typeof u.MouseEvent ? new u.MouseEvent(b3, { bubbles: true, cancelable: true, composed: true, button: 0, buttons: 1, relatedTarget: g || z, view: u, detail: "click" === b3 ? 1 : 0, screenX: k.x, screenY: k.y, clientX: k.x, clientY: k.y }) : m.createEvent && (g = m.createEvent("MouseEvent"), g.initMouseEvent) ? (g.initMouseEvent(b3, true, true, u, "click" === b3 ? 1 : 0, k.x, k.y, k.x, k.y, false, false, false, false, 0, null), g) : { type: b3 };
        }
        const { doc: m, win: u } = b2, { css: v } = r, z = u.EventTarget && new u.EventTarget() || "none";
        return { addClass: function(b3, k) {
          b3.classList ? b3.classList.add(k) : 0 > b3.className.indexOf(k) && (b3.className += " " + k);
        }, cloneMouseEvent: q, cloneTouchEvent: function(b3) {
          var n = (b4) => {
            const a = [];
            for (let c = 0; c < b4.length; ++c) {
              const d = b4.item(c);
              d && a.push(d);
            }
            return a;
          };
          if ("function" === typeof u.TouchEvent)
            return n = new u.TouchEvent(b3.type, { touches: n(b3.touches), targetTouches: n(b3.targetTouches), changedTouches: n(b3.changedTouches), ctrlKey: b3.ctrlKey, shiftKey: b3.shiftKey, altKey: b3.altKey, metaKey: b3.metaKey, bubbles: b3.bubbles, cancelable: b3.cancelable, composed: b3.composed, detail: b3.detail, view: b3.view }), b3.defaultPrevented && n.preventDefault(), n;
          n = q(b3);
          n.touches = b3.touches;
          n.changedTouches = b3.changedTouches;
          n.targetTouches = b3.targetTouches;
          return n;
        }, escapeStringForHTML: function(b3) {
          return b3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
        }, getElement: function(b3) {
          return m.getElementById(b3);
        }, getFakeMouseEvent: l, getHeadingTagNameForElement: function(b3) {
          const n = (a) => {
            a = parseInt(a.slice(1), 10);
            return "h" + Math.min(6, a + 1);
          }, g = (a) => {
            var c;
            a: {
              for (c = a; c = c.previousSibling; ) {
                const a2 = c.tagName || "";
                if (/H[1-6]/.test(a2)) {
                  c = a2;
                  break a;
                }
              }
              c = "";
            }
            if (c)
              return n(c);
            a = a.parentElement;
            if (!a)
              return "p";
            c = a.tagName;
            return /H[1-6]/.test(c) ? n(c) : g(a);
          };
          return g(b3);
        }, removeChildNodes: function(b3) {
          for (; b3.lastChild; )
            b3.removeChild(b3.lastChild);
        }, removeClass: function(b3, k) {
          b3.classList ? b3.classList.remove(k) : b3.className = b3.className.replace(new RegExp(k, "g"), "");
        }, removeElement: function(b3) {
          b3 && b3.parentNode && b3.parentNode.removeChild(b3);
        }, reverseChildNodes: function(b3) {
          let n = b3.childNodes.length;
          for (; n--; )
            b3.appendChild(b3.childNodes[n]);
        }, simulatedEventTarget: z, stripHTMLTagsFromString: function(b3) {
          return "string" === typeof b3 ? b3.replace(/<\/?[^>]+(>|$)/g, "") : b3;
        }, visuallyHideElement: function(b3) {
          v(b3, { position: "absolute", width: "1px", height: "1px", overflow: "hidden", whiteSpace: "nowrap", clip: "rect(1px, 1px, 1px, 1px)", marginTop: "-3px", "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)", filter: "alpha(opacity=1)", opacity: 0.01 });
        } };
      });
      x(b, "Accessibility/A11yI18n.js", [
        b["Core/Templating.js"],
        b["Core/Utilities.js"]
      ], function(b2, r) {
        const { format: q } = b2, { getNestedProperty: l, pick: m } = r;
        var u;
        (function(b3) {
          function z(a, c) {
            var d = a.indexOf("#each("), e = a.indexOf("#plural("), f = a.indexOf("[");
            const b4 = a.indexOf("]");
            if (-1 < d) {
              f = a.slice(d).indexOf(")") + d;
              var B = a.substring(0, d);
              e = a.substring(f + 1);
              f = a.substring(d + 6, f).split(",");
              d = Number(f[1]);
              a = "";
              if (c = l(f[0], c))
                for (d = isNaN(d) ? c.length : d, d = 0 > d ? c.length + d : Math.min(d, c.length), f = 0; f < d; ++f)
                  a += B + c[f] + e;
              return a.length ? a : "";
            }
            if (-1 < e) {
              B = a.slice(e).indexOf(")") + e;
              a = a.substring(e + 8, B).split(",");
              switch (Number(l(a[0], c))) {
                case 0:
                  a = m(a[4], a[1]);
                  break;
                case 1:
                  a = m(a[2], a[1]);
                  break;
                case 2:
                  a = m(a[3], a[1]);
                  break;
                default:
                  a = a[1];
              }
              a ? (c = a, c = c.trim && c.trim() || c.replace(/^\s+|\s+$/g, "")) : c = "";
              return c;
            }
            return -1 < f ? (e = a.substring(0, f), a = Number(a.substring(f + 1, b4)), c = l(e, c), !isNaN(a) && c && (0 > a ? (B = c[c.length + a], "undefined" === typeof B && (B = c[0])) : (B = c[a], "undefined" === typeof B && (B = c[c.length - 1]))), "undefined" !== typeof B ? B : "") : "{" + a + "}";
          }
          function n(a, c, d) {
            const e = (a2, f2) => {
              a2 = a2.slice(f2 || 0);
              const c2 = a2.indexOf("{"), e2 = a2.indexOf("}");
              if (-1 < c2 && e2 > c2)
                return { statement: a2.substring(c2 + 1, e2), begin: f2 + c2 + 1, end: f2 + e2 };
            }, f = [];
            let b4, B, g2 = 0;
            do
              b4 = e(a, g2), B = a.substring(g2, b4 && b4.begin - 1), B.length && f.push({ value: B, type: "constant" }), b4 && f.push({ value: b4.statement, type: "statement" }), g2 = b4 ? b4.end + 1 : g2 + 1;
            while (b4);
            f.forEach((a2) => {
              "statement" === a2.type && (a2.value = z(a2.value, c));
            });
            return q(f.reduce((a2, f2) => a2 + f2.value, ""), c, d);
          }
          function k(a, c) {
            a = a.split(".");
            let d = this.options.lang, e = 0;
            for (; e < a.length; ++e)
              d = d && d[a[e]];
            return "string" === typeof d ? n(d, c, this) : "";
          }
          const g = [];
          b3.compose = function(a) {
            r.pushUnique(g, a) && (a.prototype.langFormat = k);
            return a;
          };
          b3.i18nFormat = n;
        })(u || (u = {}));
        return u;
      });
      x(b, "Accessibility/Utils/ChartUtilities.js", [b["Core/Globals.js"], b["Accessibility/Utils/HTMLUtilities.js"], b["Core/Utilities.js"]], function(b2, r, q) {
        function l(a2, f) {
          const c2 = f.type, e = a2.hcEvents;
          k.createEvent && (a2.dispatchEvent || a2.fireEvent) ? a2.dispatchEvent ? a2.dispatchEvent(f) : a2.fireEvent(c2, f) : e && e[c2] ? d(a2, c2, f) : a2.element && l(a2.element, f);
        }
        function m(a2) {
          const f = a2.chart, c2 = {};
          let e = "Seconds";
          c2.Seconds = ((a2.dataMax || a2.max || 0) - (a2.dataMin || a2.min || 0)) / 1e3;
          c2.Minutes = c2.Seconds / 60;
          c2.Hours = c2.Minutes / 60;
          c2.Days = c2.Hours / 24;
          ["Minutes", "Hours", "Days"].forEach(function(a3) {
            2 < c2[a3] && (e = a3);
          });
          const d2 = c2[e].toFixed("Seconds" !== e && "Minutes" !== e ? 1 : 0);
          return f.langFormat("accessibility.axis.timeRange" + e, { chart: f, axis: a2, range: d2.replace(".0", "") });
        }
        function u(a2) {
          const f = a2.chart;
          var c2 = f.options;
          const e = c2 && c2.accessibility && c2.accessibility.screenReaderSection.axisRangeDateFormat || "", d2 = { min: a2.dataMin || a2.min || 0, max: a2.dataMax || a2.max || 0 };
          c2 = function(c3) {
            return a2.dateTime ? f.time.dateFormat(e, d2[c3]) : d2[c3].toString();
          };
          return f.langFormat("accessibility.axis.rangeFromTo", { chart: f, axis: a2, rangeFrom: c2("min"), rangeTo: c2("max") });
        }
        function v(a2) {
          if (a2.points && a2.points.length)
            return (a2 = c(a2.points, (a3) => !!a3.graphic)) && a2.graphic && a2.graphic.element;
        }
        function z(a2) {
          const c2 = v(a2);
          return c2 && c2.parentNode || a2.graph && a2.graph.element || a2.group && a2.group.element;
        }
        function n(a2, c2) {
          c2.setAttribute("aria-hidden", false);
          c2 !== a2.renderTo && c2.parentNode && c2.parentNode !== k.body && (Array.prototype.forEach.call(c2.parentNode.childNodes, function(a3) {
            a3.hasAttribute("aria-hidden") || a3.setAttribute("aria-hidden", true);
          }), n(a2, c2.parentNode));
        }
        const { doc: k } = b2, { stripHTMLTagsFromString: g } = r, { defined: a, find: c, fireEvent: d } = q;
        return { fireEventOnWrappedOrUnwrappedElement: l, getChartTitle: function(a2) {
          return g(a2.options.title.text || a2.langFormat("accessibility.defaultChartTitle", { chart: a2 }));
        }, getAxisDescription: function(a2) {
          var c2, d2;
          return a2 && ((null === (c2 = a2.options.accessibility) || void 0 === c2 ? void 0 : c2.description) || (null === (d2 = a2.axisTitle) || void 0 === d2 ? void 0 : d2.textStr) || a2.options.id || a2.categories && "categories" || a2.dateTime && "Time" || "values");
        }, getAxisRangeDescription: function(a2) {
          var c2 = a2.options || {};
          return c2.accessibility && "undefined" !== typeof c2.accessibility.rangeDescription ? c2.accessibility.rangeDescription : a2.categories ? (c2 = a2.chart, a2 = a2.dataMax && a2.dataMin ? c2.langFormat("accessibility.axis.rangeCategories", { chart: c2, axis: a2, numCategories: a2.dataMax - a2.dataMin + 1 }) : "", a2) : !a2.dateTime || 0 !== a2.min && 0 !== a2.dataMin ? u(a2) : m(a2);
        }, getPointFromXY: function(a2, f, d2) {
          let b3 = a2.length, e;
          for (; b3--; )
            if (e = c(a2[b3].points || [], function(a3) {
              return a3.x === f && a3.y === d2;
            }))
              return e;
        }, getSeriesFirstPointElement: v, getSeriesFromName: function(a2, c2) {
          return c2 ? (a2.series || []).filter(function(a3) {
            return a3.name === c2;
          }) : a2.series;
        }, getSeriesA11yElement: z, unhideChartElementFromAT: n, hideSeriesFromAT: function(a2) {
          (a2 = z(a2)) && a2.setAttribute("aria-hidden", true);
        }, scrollToPoint: function(c2) {
          var f = c2.series.xAxis, b3 = c2.series.yAxis;
          const e = f && f.scrollbar ? f : b3;
          if ((f = e && e.scrollbar) && a(f.to) && a(f.from)) {
            b3 = f.to - f.from;
            if (a(e.dataMin) && a(e.dataMax)) {
              var g2 = e.toPixels(e.dataMin), n2 = e.toPixels(e.dataMax);
              c2 = (e.toPixels(c2["xAxis" === e.coll ? "x" : "y"] || 0) - g2) / (n2 - g2);
            } else
              c2 = 0;
            f.updatePosition(c2 - b3 / 2, c2 + b3 / 2);
            d(f, "changed", { from: f.from, to: f.to, trigger: "scrollbar", DOMEvent: null });
          }
        } };
      });
      x(b, "Accessibility/Utils/DOMElementProvider.js", [b["Core/Globals.js"], b["Accessibility/Utils/HTMLUtilities.js"]], function(b2, r) {
        const { doc: q } = b2, { removeElement: l } = r;
        class m {
          constructor() {
            this.elements = [];
          }
          createElement() {
            const b3 = q.createElement.apply(q, arguments);
            this.elements.push(b3);
            return b3;
          }
          destroyCreatedElements() {
            this.elements.forEach(function(b3) {
              l(b3);
            });
            this.elements = [];
          }
        }
        return m;
      });
      x(b, "Accessibility/Utils/EventProvider.js", [b["Core/Globals.js"], b["Core/Utilities.js"]], function(b2, r) {
        const { addEvent: q } = r;
        class l {
          constructor() {
            this.eventRemovers = [];
          }
          addEvent() {
            const m = q.apply(b2, arguments);
            this.eventRemovers.push(m);
            return m;
          }
          removeAddedEvents() {
            this.eventRemovers.forEach((b3) => b3());
            this.eventRemovers = [];
          }
        }
        return l;
      });
      x(b, "Accessibility/AccessibilityComponent.js", [b["Accessibility/Utils/ChartUtilities.js"], b["Accessibility/Utils/DOMElementProvider.js"], b["Accessibility/Utils/EventProvider.js"], b["Accessibility/Utils/HTMLUtilities.js"], b["Core/Utilities.js"]], function(b2, r, q, l, m) {
        const { fireEventOnWrappedOrUnwrappedElement: u } = b2, { getFakeMouseEvent: v } = l;
        ({ extend: b2 } = m);
        class z {
          constructor() {
            this.proxyProvider = this.keyCodes = this.eventProvider = this.domElementProvider = this.chart = void 0;
          }
          initBase(b3, k) {
            this.chart = b3;
            this.eventProvider = new q();
            this.domElementProvider = new r();
            this.proxyProvider = k;
            this.keyCodes = { left: 37, right: 39, up: 38, down: 40, enter: 13, space: 32, esc: 27, tab: 9, pageUp: 33, pageDown: 34, end: 35, home: 36 };
          }
          addEvent(b3, k, g, a) {
            return this.eventProvider.addEvent(b3, k, g, a);
          }
          createElement(b3, k) {
            return this.domElementProvider.createElement(b3, k);
          }
          fakeClickEvent(b3) {
            const n = v("click");
            u(b3, n);
          }
          destroyBase() {
            this.domElementProvider.destroyCreatedElements();
            this.eventProvider.removeAddedEvents();
          }
        }
        b2(z.prototype, {
          init() {
          },
          getKeyboardNavigation: function() {
          },
          onChartUpdate() {
          },
          onChartRender() {
          },
          destroy() {
          }
        });
        return z;
      });
      x(b, "Accessibility/KeyboardNavigationHandler.js", [b["Core/Utilities.js"]], function(b2) {
        const { find: r } = b2;
        class q {
          constructor(b3, m) {
            this.chart = b3;
            this.keyCodeMap = m.keyCodeMap || [];
            this.validate = m.validate;
            this.init = m.init;
            this.terminate = m.terminate;
            this.response = { success: 1, prev: 2, next: 3, noHandler: 4, fail: 5 };
          }
          run(b3) {
            const m = b3.which || b3.keyCode;
            let q2 = this.response.noHandler;
            const l = r(this.keyCodeMap, function(b4) {
              return -1 < b4[0].indexOf(m);
            });
            l ? q2 = l[1].call(
              this,
              m,
              b3
            ) : 9 === m && (q2 = this.response[b3.shiftKey ? "prev" : "next"]);
            return q2;
          }
        }
        "";
        return q;
      });
      x(b, "Accessibility/Components/ContainerComponent.js", [b["Accessibility/AccessibilityComponent.js"], b["Accessibility/KeyboardNavigationHandler.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Core/Globals.js"], b["Accessibility/Utils/HTMLUtilities.js"]], function(b2, r, q, l, m) {
        const { unhideChartElementFromAT: u, getChartTitle: v } = q, { doc: z } = l, { stripHTMLTagsFromString: n } = m;
        class k extends b2 {
          onChartUpdate() {
            this.handleSVGTitleElement();
            this.setSVGContainerLabel();
            this.setGraphicContainerAttrs();
            this.setRenderToAttrs();
            this.makeCreditsAccessible();
          }
          handleSVGTitleElement() {
            const b3 = this.chart, a = "highcharts-title-" + b3.index, c = n(b3.langFormat("accessibility.svgContainerTitle", { chartTitle: v(b3) }));
            if (c.length) {
              const d = this.svgTitleElement = this.svgTitleElement || z.createElementNS("http://www.w3.org/2000/svg", "title");
              d.textContent = c;
              d.id = a;
              b3.renderTo.insertBefore(d, b3.renderTo.firstChild);
            }
          }
          setSVGContainerLabel() {
            const b3 = this.chart, a = b3.langFormat(
              "accessibility.svgContainerLabel",
              { chartTitle: v(b3) }
            );
            b3.renderer.box && a.length && b3.renderer.box.setAttribute("aria-label", a);
          }
          setGraphicContainerAttrs() {
            const b3 = this.chart, a = b3.langFormat("accessibility.graphicContainerLabel", { chartTitle: v(b3) });
            a.length && b3.container.setAttribute("aria-label", a);
          }
          setRenderToAttrs() {
            const b3 = this.chart, a = "disabled" !== b3.options.accessibility.landmarkVerbosity, c = b3.langFormat("accessibility.chartContainerLabel", { title: v(b3), chart: b3 });
            c && (b3.renderTo.setAttribute("role", a ? "region" : "group"), b3.renderTo.setAttribute(
              "aria-label",
              c
            ));
          }
          makeCreditsAccessible() {
            const b3 = this.chart, a = b3.credits;
            a && (a.textStr && a.element.setAttribute("aria-label", b3.langFormat("accessibility.credits", { creditsStr: n(a.textStr) })), u(b3, a.element));
          }
          getKeyboardNavigation() {
            const b3 = this.chart;
            return new r(b3, { keyCodeMap: [], validate: function() {
              return true;
            }, init: function() {
              const a = b3.accessibility;
              a && a.keyboardNavigation.tabindexContainer.focus();
            } });
          }
          destroy() {
            this.chart.renderTo.setAttribute("aria-hidden", true);
          }
        }
        return k;
      });
      x(b, "Accessibility/FocusBorder.js", [
        b["Core/Renderer/SVG/SVGLabel.js"],
        b["Core/Utilities.js"]
      ], function(b2, r) {
        const { addEvent: q, pick: l } = r;
        var m;
        (function(m2) {
          function u() {
            const a2 = this.focusElement, c2 = this.options.accessibility.keyboardNavigation.focusBorder;
            a2 && (a2.removeFocusBorder(), c2.enabled && a2.addFocusBorder(c2.margin, { stroke: c2.style.color, strokeWidth: c2.style.lineWidth, r: c2.style.borderRadius }));
          }
          function z(a2, c2) {
            const b3 = this.options.accessibility.keyboardNavigation.focusBorder;
            (c2 = c2 || a2.element) && c2.focus && (c2.hcEvents && c2.hcEvents.focusin || q(c2, "focusin", function() {
            }), c2.focus(), b3.hideBrowserFocusOutline && (c2.style.outline = "none"));
            this.focusElement && this.focusElement.removeFocusBorder();
            this.focusElement = a2;
            this.renderFocusBorder();
          }
          function n(a2) {
            if (!a2.focusBorderDestroyHook) {
              var c2 = a2.destroy;
              a2.destroy = function() {
                a2.focusBorder && a2.focusBorder.destroy && a2.focusBorder.destroy();
                return c2.apply(a2, arguments);
              };
              a2.focusBorderDestroyHook = c2;
            }
          }
          function k(a2, c2) {
            this.focusBorder && this.removeFocusBorder();
            const d2 = this.getBBox(), f = l(a2, 3), e2 = this.parentGroup;
            var E = this.scaleX || e2 && e2.scaleX, k2 = this.scaleY || e2 && e2.scaleY;
            E = (E ? !k2 : k2) ? Math.abs(E || k2 || 1) : (Math.abs(E || 1) + Math.abs(k2 || 1)) / 2;
            d2.x += this.translateX ? this.translateX : 0;
            d2.y += this.translateY ? this.translateY : 0;
            k2 = d2.x - f;
            let A = d2.y - f, y = d2.width + 2 * f, h = d2.height + 2 * f;
            var t = this instanceof b2;
            if ("text" === this.element.nodeName || t) {
              const a3 = !!this.rotation;
              if (t)
                var p = { x: a3 ? 1 : 0, y: 0 };
              else {
                var C = p = 0;
                "middle" === this.attr("text-anchor") ? p = C = 0.5 : this.rotation ? p = 0.25 : C = 0.75;
                p = { x: p, y: C };
              }
              C = +this.attr("x");
              const c3 = +this.attr("y");
              isNaN(C) || (k2 = C - d2.width * p.x - f);
              isNaN(c3) || (A = c3 - d2.height * p.y - f);
              t && a3 && (t = y, y = h, h = t, isNaN(C) || (k2 = C - d2.height * p.x - f), isNaN(c3) || (A = c3 - d2.width * p.y - f));
            }
            this.focusBorder = this.renderer.rect(k2, A, y, h, parseInt((c2 && c2.r || 0).toString(), 10) / E).addClass("highcharts-focus-border").attr({ zIndex: 99 }).add(e2);
            this.renderer.styledMode || this.focusBorder.attr({ stroke: c2 && c2.stroke, "stroke-width": (c2 && c2.strokeWidth || 0) / E });
            g(this, a2, c2);
            n(this);
          }
          function g(a2, ...c2) {
            a2.focusBorderUpdateHooks || (a2.focusBorderUpdateHooks = {}, e.forEach((b3) => {
              b3 += "Setter";
              const d2 = a2[b3] || a2._defaultSetter;
              a2.focusBorderUpdateHooks[b3] = d2;
              a2[b3] = function() {
                const b4 = d2.apply(a2, arguments);
                a2.addFocusBorder.apply(a2, c2);
                return b4;
              };
            }));
          }
          function a() {
            c(this);
            this.focusBorderDestroyHook && (this.destroy = this.focusBorderDestroyHook, delete this.focusBorderDestroyHook);
            this.focusBorder && (this.focusBorder.destroy(), delete this.focusBorder);
          }
          function c(a2) {
            a2.focusBorderUpdateHooks && (Object.keys(a2.focusBorderUpdateHooks).forEach((c2) => {
              const b3 = a2.focusBorderUpdateHooks[c2];
              b3 === a2._defaultSetter ? delete a2[c2] : a2[c2] = b3;
            }), delete a2.focusBorderUpdateHooks);
          }
          const d = [], e = "x y transform width height r d stroke-width".split(" ");
          m2.compose = function(c2, b3) {
            r.pushUnique(d, c2) && (c2 = c2.prototype, c2.renderFocusBorder = u, c2.setFocusToElement = z);
            r.pushUnique(d, b3) && (b3 = b3.prototype, b3.addFocusBorder = k, b3.removeFocusBorder = a);
          };
        })(m || (m = {}));
        return m;
      });
      x(b, "Accessibility/Utils/Announcer.js", [b["Core/Renderer/HTML/AST.js"], b["Accessibility/Utils/DOMElementProvider.js"], b["Core/Globals.js"], b["Accessibility/Utils/HTMLUtilities.js"], b["Core/Utilities.js"]], function(b2, r, q, l, m) {
        const { doc: u } = q, { addClass: v, visuallyHideElement: z } = l, { attr: n } = m;
        class k {
          constructor(b3, a) {
            this.chart = b3;
            this.domElementProvider = new r();
            this.announceRegion = this.addAnnounceRegion(a);
          }
          destroy() {
            this.domElementProvider.destroyCreatedElements();
          }
          announce(g) {
            b2.setElementHTML(this.announceRegion, g);
            this.clearAnnouncementRegionTimer && clearTimeout(this.clearAnnouncementRegionTimer);
            this.clearAnnouncementRegionTimer = setTimeout(() => {
              this.announceRegion.innerHTML = b2.emptyHTML;
              delete this.clearAnnouncementRegionTimer;
            }, 1e3);
          }
          addAnnounceRegion(b3) {
            const a = this.chart.announcerContainer || this.createAnnouncerContainer(), c = this.domElementProvider.createElement("div");
            n(c, { "aria-hidden": false, "aria-live": b3 });
            this.chart.styledMode ? v(c, "highcharts-visually-hidden") : z(c);
            a.appendChild(c);
            return c;
          }
          createAnnouncerContainer() {
            const b3 = this.chart, a = u.createElement("div");
            n(a, { "aria-hidden": false, "class": "highcharts-announcer-container" });
            a.style.position = "relative";
            b3.renderTo.insertBefore(a, b3.renderTo.firstChild);
            return b3.announcerContainer = a;
          }
        }
        return k;
      });
      x(
        b,
        "Accessibility/Components/AnnotationsA11y.js",
        [b["Accessibility/Utils/HTMLUtilities.js"]],
        function(b2) {
          function r(b3) {
            return (b3.annotations || []).reduce((b4, k) => {
              k.options && false !== k.options.visible && (b4 = b4.concat(k.labels));
              return b4;
            }, []);
          }
          function q(b3) {
            return b3.options && b3.options.accessibility && b3.options.accessibility.description || b3.graphic && b3.graphic.text && b3.graphic.text.textStr || "";
          }
          function l(b3) {
            var n = b3.options && b3.options.accessibility && b3.options.accessibility.description;
            if (n)
              return n;
            n = b3.chart;
            const k = q(b3), g = b3.points.filter((a2) => !!a2.graphic).map((a2) => {
              const b4 = a2.accessibility && a2.accessibility.valueDescription || a2.graphic && a2.graphic.element && a2.graphic.element.getAttribute("aria-label") || "";
              a2 = a2 && a2.series.name || "";
              return (a2 ? a2 + ", " : "") + "data point " + b4;
            }).filter((a2) => !!a2), a = g.length, c = "accessibility.screenReaderSection.annotations.description" + (1 < a ? "MultiplePoints" : a ? "SinglePoint" : "NoPoints");
            b3 = { annotationText: k, annotation: b3, numPoints: a, annotationPoint: g[0], additionalAnnotationPoints: g.slice(1) };
            return n.langFormat(c, b3);
          }
          function m(b3) {
            return r(b3).map((b4) => (b4 = u(v(l(b4)))) ? `<li>${b4}</li>` : "");
          }
          const { escapeStringForHTML: u, stripHTMLTagsFromString: v } = b2;
          return { getAnnotationsInfoHTML: function(b3) {
            const n = b3.annotations;
            return n && n.length ? `<ul style="list-style-type: none">${m(b3).join(" ")}</ul>` : "";
          }, getAnnotationLabelDescription: l, getAnnotationListItems: m, getPointAnnotationTexts: function(b3) {
            const n = r(b3.series.chart).filter((k) => -1 < k.points.indexOf(b3));
            return n.length ? n.map((b4) => `${q(b4)}`) : [];
          } };
        }
      );
      x(b, "Accessibility/Components/InfoRegionsComponent.js", [
        b["Accessibility/A11yI18n.js"],
        b["Accessibility/AccessibilityComponent.js"],
        b["Accessibility/Utils/Announcer.js"],
        b["Accessibility/Components/AnnotationsA11y.js"],
        b["Core/Renderer/HTML/AST.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Core/Templating.js"],
        b["Core/Globals.js"],
        b["Accessibility/Utils/HTMLUtilities.js"],
        b["Core/Utilities.js"]
      ], function(b2, r, q, l, m, u, L, z, n, k) {
        function g(a2, b3) {
          var c2 = b3[0], p = a2.series && a2.series[0] || {};
          p = { numSeries: a2.series.length, numPoints: p.points && p.points.length, chart: a2, mapTitle: a2.mapView && a2.mapView.geoMap && a2.mapView.geoMap.title };
          if (!c2)
            return a2.langFormat("accessibility.chartTypes.emptyChart", p);
          if ("map" === c2 || "tiledwebmap" === c2)
            return p.mapTitle ? a2.langFormat("accessibility.chartTypes.mapTypeDescription", p) : a2.langFormat("accessibility.chartTypes.unknownMap", p);
          if (1 < a2.types.length)
            return a2.langFormat("accessibility.chartTypes.combinationChart", p);
          {
            b3 = b3[0];
            c2 = a2.langFormat("accessibility.seriesTypeDescriptions." + b3, p);
            const d2 = a2.series && 2 > a2.series.length ? "Single" : "Multiple";
            a2 = (a2.langFormat("accessibility.chartTypes." + b3 + d2, p) || a2.langFormat("accessibility.chartTypes.default" + d2, p)) + (c2 ? " " + c2 : "");
          }
          return a2;
        }
        const { getAnnotationsInfoHTML: a } = l, { getAxisDescription: c, getAxisRangeDescription: d, getChartTitle: e, unhideChartElementFromAT: f } = u, { format: E } = L, { doc: B } = z, { addClass: J, getElement: v, getHeadingTagNameForElement: F, stripHTMLTagsFromString: x2, visuallyHideElement: A } = n, { attr: y, pick: h } = k;
        class t extends r {
          constructor() {
            super(...arguments);
            this.announcer = void 0;
            this.screenReaderSections = {};
          }
          init() {
            const a2 = this.chart, b3 = this;
            this.initRegionsDefinitions();
            this.addEvent(a2, "aftergetTableAST", function(a3) {
              b3.onDataTableCreated(a3);
            });
            this.addEvent(a2, "afterViewData", function(a3) {
              a3.wasHidden && (b3.dataTableDiv = a3.element, setTimeout(function() {
                b3.focusDataTable();
              }, 300));
            });
            this.announcer = new q(a2, "assertive");
          }
          initRegionsDefinitions() {
            const a2 = this;
            this.screenReaderSections = { before: { element: null, buildContent: function(b3) {
              const c2 = b3.options.accessibility.screenReaderSection.beforeChartFormatter;
              return c2 ? c2(b3) : a2.defaultBeforeChartFormatter(b3);
            }, insertIntoDOM: function(a3, b3) {
              b3.renderTo.insertBefore(
                a3,
                b3.renderTo.firstChild
              );
            }, afterInserted: function() {
              "undefined" !== typeof a2.sonifyButtonId && a2.initSonifyButton(a2.sonifyButtonId);
              "undefined" !== typeof a2.dataTableButtonId && a2.initDataTableButton(a2.dataTableButtonId);
            } }, after: { element: null, buildContent: function(b3) {
              const c2 = b3.options.accessibility.screenReaderSection.afterChartFormatter;
              return c2 ? c2(b3) : a2.defaultAfterChartFormatter();
            }, insertIntoDOM: function(a3, b3) {
              b3.renderTo.insertBefore(a3, b3.container.nextSibling);
            }, afterInserted: function() {
              a2.chart.accessibility && a2.chart.accessibility.keyboardNavigation.updateExitAnchor();
            } } };
          }
          onChartRender() {
            const a2 = this;
            this.linkedDescriptionElement = this.getLinkedDescriptionElement();
            this.setLinkedDescriptionAttrs();
            Object.keys(this.screenReaderSections).forEach(function(b3) {
              a2.updateScreenReaderSection(b3);
            });
          }
          getLinkedDescriptionElement() {
            var a2 = this.chart.options.accessibility.linkedDescription;
            if (a2) {
              if ("string" !== typeof a2)
                return a2;
              a2 = E(a2, this.chart);
              a2 = B.querySelectorAll(a2);
              if (1 === a2.length)
                return a2[0];
            }
          }
          setLinkedDescriptionAttrs() {
            const a2 = this.linkedDescriptionElement;
            a2 && (a2.setAttribute("aria-hidden", "true"), J(a2, "highcharts-linked-description"));
          }
          updateScreenReaderSection(a2) {
            const b3 = this.chart, c2 = this.screenReaderSections[a2], d2 = c2.buildContent(b3), h2 = c2.element = c2.element || this.createElement("div"), p = h2.firstChild || this.createElement("div");
            d2 ? (this.setScreenReaderSectionAttribs(h2, a2), m.setElementHTML(p, d2), h2.appendChild(p), c2.insertIntoDOM(h2, b3), b3.styledMode ? J(p, "highcharts-visually-hidden") : A(p), f(b3, p), c2.afterInserted && c2.afterInserted()) : (h2.parentNode && h2.parentNode.removeChild(h2), c2.element = null);
          }
          setScreenReaderSectionAttribs(a2, b3) {
            const c2 = this.chart, d2 = c2.langFormat("accessibility.screenReaderSection." + b3 + "RegionLabel", { chart: c2, chartTitle: e(c2) });
            y(a2, { id: `highcharts-screen-reader-region-${b3}-${c2.index}`, "aria-label": d2 || void 0 });
            a2.style.position = "relative";
            d2 && a2.setAttribute("role", "all" === c2.options.accessibility.landmarkVerbosity ? "region" : "group");
          }
          defaultBeforeChartFormatter() {
            var c2 = this.chart;
            const d2 = c2.options.accessibility.screenReaderSection.beforeChartFormat;
            if (!d2)
              return "";
            var h2 = this.getAxesDescription();
            const f2 = c2.sonify && c2.options.sonification && c2.options.sonification.enabled, w = "highcharts-a11y-sonify-data-btn-" + c2.index, t2 = "hc-linkto-highcharts-data-table-" + c2.index, y2 = a(c2), A2 = c2.langFormat("accessibility.screenReaderSection.annotations.heading", { chart: c2 });
            h2 = {
              headingTagName: F(c2.renderTo),
              chartTitle: e(c2),
              typeDescription: this.getTypeDescriptionText(),
              chartSubtitle: this.getSubtitleText(),
              chartLongdesc: this.getLongdescText(),
              xAxisDescription: h2.xAxis,
              yAxisDescription: h2.yAxis,
              playAsSoundButton: f2 ? this.getSonifyButtonText(w) : "",
              viewTableButton: c2.getCSV ? this.getDataTableButtonText(t2) : "",
              annotationsTitle: y2 ? A2 : "",
              annotationsList: y2
            };
            c2 = b2.i18nFormat(d2, h2, c2);
            this.dataTableButtonId = t2;
            this.sonifyButtonId = w;
            return c2.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
          }
          defaultAfterChartFormatter() {
            const a2 = this.chart, c2 = a2.options.accessibility.screenReaderSection.afterChartFormat;
            if (!c2)
              return "";
            const d2 = { endOfChartMarker: this.getEndOfChartMarkerText() };
            return b2.i18nFormat(c2, d2, a2).replace(
              /<(\w+)[^>]*?>\s*<\/\1>/g,
              ""
            );
          }
          getLinkedDescription() {
            const a2 = this.linkedDescriptionElement;
            return x2(a2 && a2.innerHTML || "");
          }
          getLongdescText() {
            const a2 = this.chart.options;
            var b3 = a2.caption;
            b3 = b3 && b3.text;
            const c2 = this.getLinkedDescription();
            return a2.accessibility.description || c2 || b3 || "";
          }
          getTypeDescriptionText() {
            const a2 = this.chart;
            return a2.types ? a2.options.accessibility.typeDescription || g(a2, a2.types) : "";
          }
          getDataTableButtonText(a2) {
            var b3 = this.chart;
            b3 = b3.langFormat("accessibility.table.viewAsDataTableButtonText", { chart: b3, chartTitle: e(b3) });
            return '<button id="' + a2 + '">' + b3 + "</button>";
          }
          getSonifyButtonText(a2) {
            var b3 = this.chart;
            if (b3.options.sonification && false === b3.options.sonification.enabled)
              return "";
            b3 = b3.langFormat("accessibility.sonification.playAsSoundButtonText", { chart: b3, chartTitle: e(b3) });
            return '<button id="' + a2 + '">' + b3 + "</button>";
          }
          getSubtitleText() {
            const a2 = this.chart.options.subtitle;
            return x2(a2 && a2.text || "");
          }
          getEndOfChartMarkerText() {
            const a2 = this.chart, b3 = a2.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart: a2 });
            return '<div id="highcharts-end-of-chart-marker-' + a2.index + '">' + b3 + "</div>";
          }
          onDataTableCreated(a2) {
            const b3 = this.chart;
            if (b3.options.accessibility.enabled) {
              this.viewDataTableButton && this.viewDataTableButton.setAttribute("aria-expanded", "true");
              const c2 = a2.tree.attributes || {};
              c2.tabindex = -1;
              c2.summary = b3.langFormat("accessibility.table.tableSummary", { chart: b3 });
              a2.tree.attributes = c2;
            }
          }
          focusDataTable() {
            var a2 = this.dataTableDiv;
            (a2 = a2 && a2.getElementsByTagName("table")[0]) && a2.focus && a2.focus();
          }
          initSonifyButton(a2) {
            const b3 = this.sonifyButton = v(a2), c2 = this.chart, d2 = (a3) => {
              b3 && (b3.setAttribute(
                "aria-hidden",
                "true"
              ), b3.setAttribute("aria-label", ""));
              a3.preventDefault();
              a3.stopPropagation();
              a3 = c2.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart: c2 });
              this.announcer.announce(a3);
              setTimeout(() => {
                b3 && (b3.removeAttribute("aria-hidden"), b3.removeAttribute("aria-label"));
                c2.sonify && c2.sonify();
              }, 1e3);
            };
            b3 && c2 && (b3.setAttribute("tabindex", -1), b3.onclick = function(a3) {
              (c2.options.accessibility && c2.options.accessibility.screenReaderSection.onPlayAsSoundClick || d2).call(this, a3, c2);
            });
          }
          initDataTableButton(a2) {
            const b3 = this.viewDataTableButton = v(a2), c2 = this.chart;
            a2 = a2.replace("hc-linkto-", "");
            b3 && (y(b3, { tabindex: -1, "aria-expanded": !!v(a2) }), b3.onclick = c2.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
              c2.viewData();
            });
          }
          getAxesDescription() {
            const a2 = this.chart;
            var b3 = function(b4, c3) {
              b4 = a2[b4];
              return 1 < b4.length || b4[0] && h(b4[0].options.accessibility && b4[0].options.accessibility.enabled, c3);
            }, c2 = !!a2.types && 0 > a2.types.indexOf("map") && 0 > a2.types.indexOf("treemap") && 0 > a2.types.indexOf("tilemap");
            const d2 = !!a2.hasCartesianSeries, f2 = b3("xAxis", !a2.angular && d2 && c2);
            b3 = b3("yAxis", d2 && c2);
            c2 = {};
            f2 && (c2.xAxis = this.getAxisDescriptionText("xAxis"));
            b3 && (c2.yAxis = this.getAxisDescriptionText("yAxis"));
            return c2;
          }
          getAxisDescriptionText(a2) {
            const b3 = this.chart, h2 = b3[a2];
            return b3.langFormat("accessibility.axis." + a2 + "Description" + (1 < h2.length ? "Plural" : "Singular"), { chart: b3, names: h2.map(function(a3) {
              return c(a3);
            }), ranges: h2.map(function(a3) {
              return d(a3);
            }), numAxes: h2.length });
          }
          destroy() {
            this.announcer && this.announcer.destroy();
          }
        }
        return t;
      });
      x(
        b,
        "Accessibility/Components/MenuComponent.js",
        [b["Core/Chart/Chart.js"], b["Core/Utilities.js"], b["Accessibility/AccessibilityComponent.js"], b["Accessibility/KeyboardNavigationHandler.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Accessibility/Utils/HTMLUtilities.js"]],
        function(b2, r, q, l, m, u) {
          const { attr: v } = r, { getChartTitle: z, unhideChartElementFromAT: n } = m, { getFakeMouseEvent: k } = u;
          class g extends q {
            init() {
              const a = this.chart, b3 = this;
              this.addEvent(a, "exportMenuShown", function() {
                b3.onMenuShown();
              });
              this.addEvent(a, "exportMenuHidden", function() {
                b3.onMenuHidden();
              });
              this.createProxyGroup();
            }
            onMenuHidden() {
              const a = this.chart.exportContextMenu;
              a && a.setAttribute("aria-hidden", "true");
              this.setExportButtonExpandedState("false");
            }
            onMenuShown() {
              const a = this.chart, b3 = a.exportContextMenu;
              b3 && (this.addAccessibleContextMenuAttribs(), n(a, b3));
              this.setExportButtonExpandedState("true");
            }
            setExportButtonExpandedState(a) {
              this.exportButtonProxy && this.exportButtonProxy.buttonElement.setAttribute("aria-expanded", a);
            }
            onChartRender() {
              const a = this.chart, b3 = a.focusElement, d = a.accessibility;
              this.proxyProvider.clearGroup("chartMenu");
              this.proxyMenuButton();
              this.exportButtonProxy && b3 && b3 === a.exportingGroup && (b3.focusBorder ? a.setFocusToElement(b3, this.exportButtonProxy.buttonElement) : d && d.keyboardNavigation.tabindexContainer.focus());
            }
            proxyMenuButton() {
              const a = this.chart, b3 = this.proxyProvider, d = a.exportSVGElements && a.exportSVGElements[0];
              {
                var e = a.options.exporting;
                const b4 = a.exportSVGElements && a.exportSVGElements[0];
                e = !!(e && false !== e.enabled && e.accessibility && e.accessibility.enabled && b4 && b4.element);
              }
              e && d && (this.exportButtonProxy = b3.addProxyElement("chartMenu", { click: d }, { "aria-label": a.langFormat("accessibility.exporting.menuButtonLabel", { chart: a, chartTitle: z(a) }), "aria-expanded": false, title: a.options.lang.contextButtonTitle || null }));
            }
            createProxyGroup() {
              this.chart && this.proxyProvider && this.proxyProvider.addGroup("chartMenu", "div");
            }
            addAccessibleContextMenuAttribs() {
              const a = this.chart;
              var b3 = a.exportDivElements;
              b3 && b3.length && (b3.forEach((a2) => {
                a2 && ("LI" !== a2.tagName || a2.children && a2.children.length ? a2.setAttribute(
                  "aria-hidden",
                  "true"
                ) : a2.setAttribute("tabindex", -1));
              }), (b3 = b3[0] && b3[0].parentNode) && v(b3, { "aria-hidden": void 0, "aria-label": a.langFormat("accessibility.exporting.chartMenuLabel", { chart: a }), role: "list" }));
            }
            getKeyboardNavigation() {
              const a = this.keyCodes, b3 = this.chart, d = this;
              return new l(b3, { keyCodeMap: [[[a.left, a.up], function() {
                return d.onKbdPrevious(this);
              }], [[a.right, a.down], function() {
                return d.onKbdNext(this);
              }], [[a.enter, a.space], function() {
                return d.onKbdClick(this);
              }]], validate: function() {
                return !!b3.exporting && false !== b3.options.exporting.enabled && false !== b3.options.exporting.accessibility.enabled;
              }, init: function() {
                const a2 = d.exportButtonProxy, c = d.chart.exportingGroup;
                a2 && c && b3.setFocusToElement(c, a2.buttonElement);
              }, terminate: function() {
                b3.hideExportMenu();
              } });
            }
            onKbdPrevious(a) {
              const b3 = this.chart, d = b3.options.accessibility;
              a = a.response;
              let e = b3.highlightedExportItemIx || 0;
              for (; e--; )
                if (b3.highlightExportItem(e))
                  return a.success;
              return d.keyboardNavigation.wrapAround ? (b3.highlightLastExportItem(), a.success) : a.prev;
            }
            onKbdNext(a) {
              const b3 = this.chart, d = b3.options.accessibility;
              a = a.response;
              for (let c = (b3.highlightedExportItemIx || 0) + 1; c < b3.exportDivElements.length; ++c)
                if (b3.highlightExportItem(c))
                  return a.success;
              return d.keyboardNavigation.wrapAround ? (b3.highlightExportItem(0), a.success) : a.next;
            }
            onKbdClick(a) {
              const b3 = this.chart, d = b3.exportDivElements[b3.highlightedExportItemIx], e = (b3.exportSVGElements && b3.exportSVGElements[0]).element;
              b3.openMenu ? this.fakeClickEvent(d) : (this.fakeClickEvent(e), b3.highlightExportItem(0));
              return a.response.success;
            }
          }
          (function(a) {
            function c() {
              var a2 = this.exportSVGElements && this.exportSVGElements[0];
              if (a2 && (a2 = a2.element, a2.onclick))
                a2.onclick(k("click"));
            }
            function d() {
              const a2 = this.exportDivElements;
              a2 && this.exportContextMenu && this.openMenu && (a2.forEach((a3) => {
                if (a3 && "highcharts-menu-item" === a3.className && a3.onmouseout)
                  a3.onmouseout(k("mouseout"));
              }), this.highlightedExportItemIx = 0, this.exportContextMenu.hideMenu(), this.container.focus());
            }
            function e(a2) {
              const b3 = this.exportDivElements && this.exportDivElements[a2], c2 = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx];
              if (b3 && "LI" === b3.tagName && (!b3.children || !b3.children.length)) {
                const d2 = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
                b3.focus && d2 && b3.focus();
                if (c2 && c2.onmouseout)
                  c2.onmouseout(k("mouseout"));
                if (b3.onmouseover)
                  b3.onmouseover(k("mouseover"));
                this.highlightedExportItemIx = a2;
                return true;
              }
              return false;
            }
            function f() {
              if (this.exportDivElements) {
                let a2 = this.exportDivElements.length;
                for (; a2--; )
                  if (this.highlightExportItem(a2))
                    return true;
              }
              return false;
            }
            const E = [];
            a.compose = function(a2) {
              r.pushUnique(E, a2) && (a2 = b2.prototype, a2.hideExportMenu = d, a2.highlightExportItem = e, a2.highlightLastExportItem = f, a2.showExportMenu = c);
            };
          })(g || (g = {}));
          return g;
        }
      );
      x(b, "Accessibility/KeyboardNavigation.js", [b["Core/Globals.js"], b["Accessibility/Components/MenuComponent.js"], b["Core/Utilities.js"], b["Accessibility/Utils/EventProvider.js"], b["Accessibility/Utils/HTMLUtilities.js"]], function(b2, r, q, l, m) {
        const { doc: u, win: v } = b2, { addEvent: z, fireEvent: n } = q, { getElement: k, simulatedEventTarget: g } = m;
        class a {
          constructor(a2, b3) {
            this.components = this.chart = void 0;
            this.currentModuleIx = NaN;
            this.exitAnchor = this.eventProvider = void 0;
            this.modules = [];
            this.tabindexContainer = void 0;
            this.init(a2, b3);
          }
          init(a2, b3) {
            const c = this.eventProvider = new l();
            this.chart = a2;
            this.components = b3;
            this.modules = [];
            this.currentModuleIx = 0;
            this.update();
            c.addEvent(this.tabindexContainer, "keydown", (a3) => this.onKeydown(a3));
            c.addEvent(this.tabindexContainer, "focus", (a3) => this.onFocus(a3));
            ["mouseup", "touchend"].forEach((a3) => c.addEvent(u, a3, (a4) => this.onMouseUp(a4)));
            ["mousedown", "touchstart"].forEach((b4) => c.addEvent(a2.renderTo, b4, () => {
              this.isClickingChart = true;
            }));
          }
          update(a2) {
            var b3 = this.chart.options.accessibility;
            b3 = b3 && b3.keyboardNavigation;
            const c = this.components;
            this.updateContainerTabindex();
            b3 && b3.enabled && a2 && a2.length ? (this.modules = a2.reduce(function(a3, b4) {
              b4 = c[b4].getKeyboardNavigation();
              return a3.concat(b4);
            }, []), this.updateExitAnchor()) : (this.modules = [], this.currentModuleIx = 0, this.removeExitAnchor());
          }
          updateExitAnchor() {
            const a2 = k(`highcharts-end-of-chart-marker-${this.chart.index}`);
            this.removeExitAnchor();
            a2 ? (this.makeElementAnExitAnchor(a2), this.exitAnchor = a2) : this.createExitAnchor();
          }
          move(a2) {
            var b3 = this.modules && this.modules[this.currentModuleIx];
            b3 && b3.terminate && b3.terminate(a2);
            this.chart.focusElement && this.chart.focusElement.removeFocusBorder();
            this.currentModuleIx += a2;
            if (b3 = this.modules && this.modules[this.currentModuleIx]) {
              if (b3.validate && !b3.validate())
                return this.move(a2);
              if (b3.init)
                return b3.init(a2), true;
            }
            this.currentModuleIx = 0;
            this.exiting = true;
            0 < a2 ? this.exitAnchor && this.exitAnchor.focus() : this.tabindexContainer.focus();
            return false;
          }
          onFocus(a2) {
            var b3 = this.chart;
            a2 = a2.relatedTarget && b3.container.contains(a2.relatedTarget);
            !(b3 = (b3 = b3.options.accessibility) && b3.keyboardNavigation) || !b3.enabled || this.exiting || this.tabbingInBackwards || this.isClickingChart || a2 || (a2 = this.getFirstValidModuleIx(), null !== a2 && (this.currentModuleIx = a2, this.modules[a2].init(1)));
            this.exiting = false;
          }
          onMouseUp(a2) {
            delete this.isClickingChart;
            if (!this.keyboardReset && a2.relatedTarget !== g) {
              const b3 = this.chart;
              a2.target && b3.container.contains(a2.target) || ((a2 = this.modules && this.modules[this.currentModuleIx || 0]) && a2.terminate && a2.terminate(), this.currentModuleIx = 0);
              b3.focusElement && (b3.focusElement.removeFocusBorder(), delete b3.focusElement);
              this.keyboardReset = true;
            }
          }
          onKeydown(a2) {
            a2 = a2 || v.event;
            const b3 = this.modules && this.modules.length && this.modules[this.currentModuleIx];
            let c;
            this.exiting = this.keyboardReset = false;
            if (b3) {
              const d = b3.run(a2);
              d === b3.response.success ? c = true : d === b3.response.prev ? c = this.move(-1) : d === b3.response.next && (c = this.move(1));
              c && (a2.preventDefault(), a2.stopPropagation());
            }
          }
          updateContainerTabindex() {
            var a2 = this.chart.options.accessibility;
            a2 = a2 && a2.keyboardNavigation;
            a2 = !(a2 && false === a2.enabled);
            const b3 = this.chart;
            var e = b3.container;
            b3.renderTo.hasAttribute("tabindex") && (e.removeAttribute("tabindex"), e = b3.renderTo);
            this.tabindexContainer = e;
            const f = e.getAttribute("tabindex");
            a2 && !f ? e.setAttribute("tabindex", "0") : a2 || b3.container.removeAttribute("tabindex");
          }
          createExitAnchor() {
            const a2 = this.chart, b3 = this.exitAnchor = u.createElement("div");
            a2.renderTo.appendChild(b3);
            this.makeElementAnExitAnchor(b3);
          }
          makeElementAnExitAnchor(a2) {
            const b3 = this.tabindexContainer.getAttribute("tabindex") || 0;
            a2.setAttribute("class", "highcharts-exit-anchor");
            a2.setAttribute("tabindex", b3);
            a2.setAttribute("aria-hidden", false);
            this.addExitAnchorEventsToEl(a2);
          }
          removeExitAnchor() {
            this.exitAnchor && this.exitAnchor.parentNode && (this.exitAnchor.parentNode.removeChild(this.exitAnchor), delete this.exitAnchor);
          }
          addExitAnchorEventsToEl(a2) {
            const b3 = this.chart, c = this;
            this.eventProvider.addEvent(a2, "focus", function(a3) {
              a3 = a3 || v.event;
              const d = !(a3.relatedTarget && b3.container.contains(a3.relatedTarget) || c.exiting);
              b3.focusElement && delete b3.focusElement;
              d ? (c.tabbingInBackwards = true, c.tabindexContainer.focus(), delete c.tabbingInBackwards, a3.preventDefault(), c.modules && c.modules.length && (c.currentModuleIx = c.modules.length - 1, (a3 = c.modules[c.currentModuleIx]) && a3.validate && !a3.validate() ? c.move(-1) : a3 && a3.init(-1))) : c.exiting = false;
            });
          }
          getFirstValidModuleIx() {
            const a2 = this.modules.length;
            for (let b3 = 0; b3 < a2; ++b3) {
              const a3 = this.modules[b3];
              if (!a3.validate || a3.validate())
                return b3;
            }
            return null;
          }
          destroy() {
            this.removeExitAnchor();
            this.eventProvider.removeAddedEvents();
            this.chart.container.removeAttribute("tabindex");
          }
        }
        (function(a2) {
          function c() {
            const a3 = this;
            n(this, "dismissPopupContent", {}, function() {
              a3.tooltip && a3.tooltip.hide(0);
              a3.hideExportMenu();
            });
          }
          function e(a3) {
            27 === (a3.which || a3.keyCode) && b2.charts && b2.charts.forEach((a4) => {
              a4 && a4.dismissPopupContent && a4.dismissPopupContent();
            });
          }
          const f = [];
          a2.compose = function(a3) {
            r.compose(a3);
            q.pushUnique(f, a3) && (a3.prototype.dismissPopupContent = c);
            q.pushUnique(f, u) && z(u, "keydown", e);
            return a3;
          };
        })(a || (a = {}));
        return a;
      });
      x(b, "Accessibility/Components/LegendComponent.js", [
        b["Core/Animation/AnimationUtilities.js"],
        b["Core/Globals.js"],
        b["Core/Legend/Legend.js"],
        b["Core/Utilities.js"],
        b["Accessibility/AccessibilityComponent.js"],
        b["Accessibility/KeyboardNavigationHandler.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Accessibility/Utils/HTMLUtilities.js"]
      ], function(b2, r, q, l, m, u, L, z) {
        function n(a2) {
          const b3 = a2.legend && a2.legend.allItems, c2 = a2.options.legend.accessibility || {};
          a2 = a2.colorAxis && a2.colorAxis.some((a3) => !a3.dataClasses || !a3.dataClasses.length);
          return !(!b3 || !b3.length || a2 || false === c2.enabled);
        }
        function k(a2, b3) {
          const c2 = b3.legendItem || {};
          b3.setState(a2 ? "hover" : "", true);
          for (const h of ["group", "label", "symbol"])
            (b3 = (b3 = c2[h]) && b3.element || b3) && d(b3, a2 ? "mouseover" : "mouseout");
        }
        const { animObject: g } = b2, { doc: a } = r, { addEvent: c, fireEvent: d, isNumber: e, pick: f, syncTimeout: E } = l, { getChartTitle: B } = L, { stripHTMLTagsFromString: v, addClass: I, removeClass: x2 } = z;
        class G extends m {
          constructor() {
            super(...arguments);
            this.highlightedLegendItemIx = NaN;
            this.proxyGroup = null;
          }
          init() {
            const a2 = this;
            this.recreateProxies();
            this.addEvent(q, "afterScroll", function() {
              this.chart === a2.chart && (a2.proxyProvider.updateGroupProxyElementPositions("legend"), a2.updateLegendItemProxyVisibility(), -1 < a2.highlightedLegendItemIx && this.chart.highlightLegendItem(a2.highlightedLegendItemIx));
            });
            this.addEvent(q, "afterPositionItem", function(b3) {
              this.chart === a2.chart && this.chart.renderer && a2.updateProxyPositionForItem(b3.item);
            });
            this.addEvent(q, "afterRender", function() {
              this.chart === a2.chart && this.chart.renderer && a2.recreateProxies() && E(() => a2.proxyProvider.updateGroupProxyElementPositions("legend"), g(f(
                this.chart.renderer.globalAnimation,
                true
              )).duration);
            });
          }
          updateLegendItemProxyVisibility() {
            const a2 = this.chart, b3 = a2.legend, c2 = b3.currentPage || 1, d2 = b3.clipHeight || 0;
            let f2;
            (b3.allItems || []).forEach((h) => {
              if (h.a11yProxyElement) {
                var e2 = b3.pages && b3.pages.length;
                const w = h.a11yProxyElement.element;
                var p = false;
                f2 = h.legendItem || {};
                e2 && (h = f2.pageIx || 0, e2 = f2.y || 0, p = f2.label ? Math.round(f2.label.getBBox().height) : 0, p = e2 + p - b3.pages[h] > d2 || h !== c2 - 1);
                p ? a2.styledMode ? I(w, "highcharts-a11y-invisible") : w.style.visibility = "hidden" : (x2(w, "highcharts-a11y-invisible"), w.style.visibility = "");
              }
            });
          }
          onChartRender() {
            n(this.chart) || this.removeProxies();
          }
          highlightAdjacentLegendPage(a2) {
            const b3 = this.chart;
            var c2 = b3.legend;
            a2 = (c2.currentPage || 1) + a2;
            var d2 = c2.pages || [];
            if (0 < a2 && a2 <= d2.length) {
              d2 = 0;
              for (const h of c2.allItems)
                ((h.legendItem || {}).pageIx || 0) + 1 === a2 && (c2 = b3.highlightLegendItem(d2)) && (this.highlightedLegendItemIx = d2), ++d2;
            }
          }
          updateProxyPositionForItem(a2) {
            a2.a11yProxyElement && a2.a11yProxyElement.refreshPosition();
          }
          recreateProxies() {
            var b3 = a.activeElement;
            const c2 = this.proxyGroup;
            b3 = b3 && c2 && c2.contains(b3);
            this.removeProxies();
            return n(this.chart) ? (this.addLegendProxyGroup(), this.proxyLegendItems(), this.updateLegendItemProxyVisibility(), this.updateLegendTitle(), b3 && this.chart.highlightLegendItem(this.highlightedLegendItemIx), true) : false;
          }
          removeProxies() {
            this.proxyProvider.removeGroup("legend");
          }
          updateLegendTitle() {
            var a2 = this.chart;
            const b3 = v((a2.legend && a2.legend.options.title && a2.legend.options.title.text || "").replace(/<br ?\/?>/g, " "));
            a2 = a2.langFormat("accessibility.legend.legendLabel" + (b3 ? "" : "NoTitle"), { chart: a2, legendTitle: b3, chartTitle: B(a2) });
            this.proxyProvider.updateGroupAttrs("legend", { "aria-label": a2 });
          }
          addLegendProxyGroup() {
            this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", { "aria-label": "_placeholder_", role: "all" === this.chart.options.accessibility.landmarkVerbosity ? "region" : null });
          }
          proxyLegendItems() {
            const a2 = this;
            let b3;
            ((this.chart.legend || {}).allItems || []).forEach((c2) => {
              b3 = c2.legendItem || {};
              b3.label && b3.label.element && a2.proxyLegendItem(c2);
            });
          }
          proxyLegendItem(a2) {
            const b3 = a2.legendItem || {};
            if (b3.label && b3.group) {
              var c2 = this.chart.langFormat(
                "accessibility.legend.legendItem",
                { chart: this.chart, itemName: v(a2.name), item: a2 }
              );
              a2.a11yProxyElement = this.proxyProvider.addProxyElement("legend", { click: b3.label, visual: (b3.group.div ? b3.label : b3.group).element }, { tabindex: -1, "aria-pressed": a2.visible, "aria-label": c2 });
            }
          }
          getKeyboardNavigation() {
            const a2 = this.keyCodes, b3 = this, c2 = this.chart;
            return new u(c2, { keyCodeMap: [[[a2.left, a2.right, a2.up, a2.down], function(a3) {
              return b3.onKbdArrowKey(this, a3);
            }], [[a2.enter, a2.space], function() {
              return b3.onKbdClick(this);
            }], [[a2.pageDown, a2.pageUp], function(c3) {
              b3.highlightAdjacentLegendPage(c3 === a2.pageDown ? 1 : -1);
              return this.response.success;
            }]], validate: function() {
              return b3.shouldHaveLegendNavigation();
            }, init: function() {
              c2.highlightLegendItem(0);
              b3.highlightedLegendItemIx = 0;
            }, terminate: function() {
              b3.highlightedLegendItemIx = -1;
              c2.legend.allItems.forEach((a3) => k(false, a3));
            } });
          }
          onKbdArrowKey(a2, b3) {
            const c2 = this.keyCodes, d2 = a2.response, f2 = this.chart, e2 = f2.options.accessibility, H = f2.legend.allItems.length;
            b3 = b3 === c2.left || b3 === c2.up ? -1 : 1;
            if (f2.highlightLegendItem(this.highlightedLegendItemIx + b3))
              return this.highlightedLegendItemIx += b3, d2.success;
            1 < H && e2.keyboardNavigation.wrapAround && a2.init(b3);
            return d2.success;
          }
          onKbdClick(a2) {
            const b3 = this.chart.legend.allItems[this.highlightedLegendItemIx];
            b3 && b3.a11yProxyElement && b3.a11yProxyElement.click();
            return a2.response.success;
          }
          shouldHaveLegendNavigation() {
            if (!n(this.chart))
              return false;
            const a2 = this.chart, b3 = (a2.options.legend || {}).accessibility || {};
            return !!(a2.legend.display && b3.keyboardNavigation && b3.keyboardNavigation.enabled);
          }
        }
        (function(a2) {
          function b3(a3) {
            var b4 = this.legend.allItems, c2 = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
            const h2 = b4[a3];
            var d3 = h2.legendItem || {};
            return h2 ? (e(c2) && b4[c2] && k(false, b4[c2]), b4 = this.legend, a3 = (b4.allItems[a3].legendItem || {}).pageIx, c2 = b4.currentPage, "undefined" !== typeof a3 && a3 + 1 !== c2 && b4.scroll(1 + a3 - c2), d3 = d3.label, a3 = h2.a11yProxyElement && h2.a11yProxyElement.buttonElement, d3 && d3.element && a3 && this.setFocusToElement(d3, a3), k(true, h2), true) : false;
          }
          function h(a3) {
            const b4 = a3.item;
            this.chart.options.accessibility.enabled && b4 && b4.a11yProxyElement && b4.a11yProxyElement.buttonElement.setAttribute(
              "aria-pressed",
              a3.visible ? "true" : "false"
            );
          }
          const d2 = [];
          a2.compose = function(a3, f2) {
            l.pushUnique(d2, a3) && (a3.prototype.highlightLegendItem = b3);
            l.pushUnique(d2, f2) && c(f2, "afterColorizeItem", h);
          };
        })(G || (G = {}));
        return G;
      });
      x(b, "Accessibility/Components/SeriesComponent/SeriesDescriber.js", [b["Accessibility/Components/AnnotationsA11y.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Core/Templating.js"], b["Accessibility/Utils/HTMLUtilities.js"], b["Core/Utilities.js"]], function(b2, r, q, l, m) {
        function u(a2) {
          const b3 = a2.index;
          return a2.series && a2.series.data && K(b3) ? t(a2.series.data, function(a3) {
            return !!(a3 && "undefined" !== typeof a3.index && a3.index > b3 && a3.graphic && a3.graphic.element);
          }) || null : null;
        }
        function v(a2) {
          const b3 = a2.chart.options.accessibility.series.pointDescriptionEnabledThreshold;
          return !!(false !== b3 && a2.points && a2.points.length >= b3);
        }
        function z(a2) {
          const b3 = a2.options.accessibility || {};
          return !v(a2) && !b3.exposeAsGroupOnly;
        }
        function n(a2) {
          const b3 = a2.chart.options.accessibility.keyboardNavigation.seriesNavigation;
          return !(!a2.points || !(a2.points.length < b3.pointNavigationEnabledThreshold || false === b3.pointNavigationEnabledThreshold));
        }
        function k(a2, b3) {
          var c2 = a2.series, h2 = c2.chart;
          a2 = h2.options.accessibility.point || {};
          const d2 = c2.options.accessibility && c2.options.accessibility.point || {};
          c2 = c2.tooltipOptions || {};
          h2 = h2.options.lang;
          return p(b3) ? A(b3, d2.valueDecimals || a2.valueDecimals || c2.valueDecimals || -1, h2.decimalPoint, h2.accessibility.thousandsSep || h2.thousandsSep) : b3;
        }
        function g(a2) {
          const b3 = (a2.options.accessibility || {}).description;
          return b3 && a2.chart.langFormat("accessibility.series.description", {
            description: b3,
            series: a2
          }) || "";
        }
        function a(a2, b3) {
          return a2.chart.langFormat("accessibility.series." + b3 + "Description", { name: B(a2[b3]), series: a2 });
        }
        function c(a2, b3, c2) {
          const h2 = b3 || "", d2 = c2 || "";
          return a2.series.pointArrayMap.reduce(function(b4, c3) {
            {
              const b5 = k(a2, H(a2[c3], a2.options[c3]));
              c3 = void 0 !== b5 ? c3 + ": " + h2 + b5 + d2 : b5;
            }
            return c3 ? b4 + (b4.length ? ", " : "") + c3 : b4;
          }, "");
        }
        function d(a2) {
          var b3 = a2.series, h2 = 1 < b3.chart.series.length || b3.options.name, d2 = a2.series;
          var f2 = d2.chart;
          var e2 = d2.options.accessibility;
          e2 = e2 && e2.point && e2.point.valueDescriptionFormat || f2.options.accessibility.point.valueDescriptionFormat;
          d2 = H(d2.xAxis && d2.xAxis.options.accessibility && d2.xAxis.options.accessibility.enabled, !f2.angular && "flowmap" !== d2.type);
          if (d2) {
            var p2 = a2.series;
            var t2 = p2.chart;
            var C2 = p2.options.accessibility && p2.options.accessibility.point || {}, w = t2.options.accessibility.point || {};
            (p2 = p2.xAxis && p2.xAxis.dateTime) ? (p2 = p2.getXDateFormat(a2.x || 0, t2.options.tooltip.dateTimeLabelFormats), C2 = C2.dateFormatter && C2.dateFormatter(a2) || w.dateFormatter && w.dateFormatter(a2) || C2.dateFormat || w.dateFormat || p2, t2 = t2.time.dateFormat(C2, a2.x || 0, void 0)) : t2 = void 0;
            C2 = (a2.series.xAxis || {}).categories && K(a2.category) && ("" + a2.category).replace("<br/>", " ");
            w = K(a2.id) && 0 > ("" + a2.id).indexOf("highcharts-");
            p2 = "x, " + a2.x;
            t2 = a2.name || t2 || C2 || (w ? a2.id : p2);
          } else
            t2 = "";
          C2 = t2;
          t2 = K(a2.index) ? a2.index + 1 : "";
          {
            w = a2.series;
            var y2 = w.chart.options.accessibility.point || {}, g2 = w.chart.options.accessibility && w.chart.options.accessibility.point || {};
            const b4 = w.tooltipOptions || {};
            p2 = g2.valuePrefix || y2.valuePrefix || b4.valuePrefix || "";
            y2 = g2.valueSuffix || y2.valueSuffix || b4.valueSuffix || "";
            g2 = k(a2, a2["undefined" !== typeof a2.value ? "value" : "y"]);
            w = a2.isNull ? w.chart.langFormat("accessibility.series.nullPointValue", { point: a2 }) : w.pointArrayMap ? c(a2, p2, y2) : p2 + g2 + y2;
          }
          f2 = G(e2, { point: a2, index: t2, xDescription: C2, value: w, separator: d2 ? ", " : "" }, f2);
          e2 = (e2 = a2.options && a2.options.accessibility && a2.options.accessibility.description) ? " " + e2 : "";
          b3 = h2 ? " " + b3.name + "." : "";
          h2 = a2.series.chart;
          d2 = E(a2);
          t2 = { point: a2, annotations: d2 };
          h2 = d2.length ? h2.langFormat("accessibility.series.pointAnnotationsDescription", t2) : "";
          a2.accessibility = a2.accessibility || {};
          a2.accessibility.valueDescription = f2;
          return f2 + e2 + b3 + (h2 ? " " + h2 : "");
        }
        function e(a2) {
          const b3 = z(a2), c2 = n(a2), f2 = a2.chart.options.accessibility.point.describeNull;
          (b3 || c2) && a2.points.forEach((c3) => {
            var e2;
            if (!(e2 = c3.graphic && c3.graphic.element)) {
              var p2 = c3.series;
              e2 = p2 && p2.chart;
              p2 = p2 && p2.is("sunburst");
              e2 = e2 && e2.options.accessibility.point.describeNull;
              if (e2 = c3.isNull && !p2 && e2) {
                p2 = c3.series;
                var t2 = u(c3);
                p2 = (e2 = t2 && t2.graphic) ? e2.parentGroup : p2.graph || p2.group;
                t2 = t2 ? { x: H(c3.plotX, t2.plotX, 0), y: H(c3.plotY, t2.plotY, 0) } : { x: H(c3.plotX, 0), y: H(c3.plotY, 0) };
                t2 = c3.series.chart.renderer.rect(
                  t2.x,
                  t2.y,
                  1,
                  1
                );
                t2.attr({ "class": "highcharts-a11y-mock-point", fill: "none", opacity: 0, "fill-opacity": 0, "stroke-opacity": 0 });
                p2 && p2.element ? (c3.graphic = t2, c3.hasMockGraphic = true, t2.add(p2), p2.element.insertBefore(t2.element, e2 ? e2.element : null), e2 = t2.element) : e2 = void 0;
              }
            }
            p2 = c3.options && c3.options.accessibility && false === c3.options.accessibility.enabled;
            if (e2)
              if (c3.isNull && !f2)
                e2.setAttribute("aria-hidden", true);
              else if (e2.setAttribute("tabindex", "-1"), a2.chart.styledMode || (e2.style.outline = "none"), b3 && !p2) {
                var w, y2, g2;
                p2 = c3.series;
                t2 = (null === (w = p2.options.accessibility) || void 0 === w ? void 0 : w.point) || {};
                w = p2.chart.options.accessibility.point || {};
                c3 = h(C(t2.descriptionFormat) && G(t2.descriptionFormat, c3, p2.chart) || (null === (y2 = t2.descriptionFormatter) || void 0 === y2 ? void 0 : y2.call(t2, c3)) || C(w.descriptionFormat) && G(w.descriptionFormat, c3, p2.chart) || (null === (g2 = w.descriptionFormatter) || void 0 === g2 ? void 0 : g2.call(w, c3)) || d(c3));
                e2.setAttribute("role", "img");
                e2.setAttribute("aria-label", c3);
              } else
                e2.setAttribute("aria-hidden", true);
          });
        }
        function f(b3) {
          const c2 = b3.chart;
          var h2 = c2.types || [];
          const d2 = g(b3);
          var f2 = function(a2) {
            return c2[a2] && 1 < c2[a2].length && b3[a2];
          };
          const e2 = b3.index + 1;
          var p2 = a(b3, "xAxis");
          const t2 = a(b3, "yAxis");
          var C2 = { seriesNumber: e2, series: b3, chart: c2 };
          h2 = 1 < h2.length ? "Combination" : "";
          C2 = c2.langFormat("accessibility.series.summary." + b3.type + h2, C2) || c2.langFormat("accessibility.series.summary.default" + h2, C2);
          f2 = (f2("yAxis") ? " " + t2 + "." : "") + (f2("xAxis") ? " " + p2 + "." : "");
          p2 = H(b3.options.accessibility && b3.options.accessibility.descriptionFormat, c2.options.accessibility.series.descriptionFormat, "");
          return G(p2, {
            seriesDescription: C2,
            authorDescription: d2 ? " " + d2 : "",
            axisDescription: f2,
            series: b3,
            chart: c2,
            seriesNumber: e2
          }, void 0);
        }
        const { getPointAnnotationTexts: E } = b2, { getAxisDescription: B, getSeriesFirstPointElement: J, getSeriesA11yElement: I, unhideChartElementFromAT: x2 } = r, { format: G, numberFormat: A } = q, { reverseChildNodes: y, stripHTMLTagsFromString: h } = l, { find: t, isNumber: p, isString: C, pick: H, defined: K } = m;
        return { defaultPointDescriptionFormatter: d, defaultSeriesDescriptionFormatter: f, describeSeries: function(a2) {
          var b3 = a2.chart, c2 = J(a2);
          const d2 = I(a2);
          var p2 = b3.is3d && b3.is3d();
          if (d2) {
            d2.lastChild !== c2 || p2 || y(d2);
            e(a2);
            x2(b3, d2);
            {
              p2 = a2.chart;
              b3 = p2.options.chart;
              c2 = 1 < p2.series.length;
              p2 = p2.options.accessibility.series.describeSingleSeries;
              const h2 = (a2.options.accessibility || {}).exposeAsGroupOnly;
              b3 = !(b3.options3d && b3.options3d.enabled && c2) && (c2 || p2 || h2 || v(a2));
            }
            b3 ? (b3 = a2.chart.options.accessibility, c2 = b3.landmarkVerbosity, (a2.options.accessibility || {}).exposeAsGroupOnly ? d2.setAttribute("role", "img") : "all" === c2 ? d2.setAttribute("role", "region") : d2.setAttribute("role", "group"), d2.setAttribute(
              "tabindex",
              "-1"
            ), a2.chart.styledMode || (d2.style.outline = "none"), d2.setAttribute("aria-label", h(b3.series.descriptionFormatter && b3.series.descriptionFormatter(a2) || f(a2)))) : d2.removeAttribute("aria-label");
          }
        } };
      });
      x(b, "Accessibility/Components/SeriesComponent/NewDataAnnouncer.js", [b["Core/Globals.js"], b["Core/Utilities.js"], b["Accessibility/Utils/Announcer.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Accessibility/Utils/EventProvider.js"], b["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]], function(b2, r, q, l, m, u) {
        function v(a2) {
          const b3 = a2.series.data.filter((b4) => a2.x === b4.x && a2.y === b4.y);
          return 1 === b3.length ? b3[0] : a2;
        }
        function z(a2, b3) {
          const c2 = (a2 || []).concat(b3 || []).reduce((a3, b4) => {
            a3[b4.name + b4.index] = b4;
            return a3;
          }, {});
          return Object.keys(c2).map((a3) => c2[a3]);
        }
        const { addEvent: n, defined: k } = r, { getChartTitle: g } = l, { defaultPointDescriptionFormatter: a, defaultSeriesDescriptionFormatter: c } = u;
        class d {
          constructor(a2) {
            this.announcer = void 0;
            this.dirty = { allSeries: {} };
            this.eventProvider = void 0;
            this.lastAnnouncementTime = 0;
            this.chart = a2;
          }
          init() {
            const a2 = this.chart, b3 = a2.options.accessibility.announceNewData.interruptUser ? "assertive" : "polite";
            this.lastAnnouncementTime = 0;
            this.dirty = { allSeries: {} };
            this.eventProvider = new m();
            this.announcer = new q(a2, b3);
            this.addEventListeners();
          }
          destroy() {
            this.eventProvider.removeAddedEvents();
            this.announcer.destroy();
          }
          addEventListeners() {
            const a2 = this, b3 = this.chart, c2 = this.eventProvider;
            c2.addEvent(b3, "afterApplyDrilldown", function() {
              a2.lastAnnouncementTime = 0;
            });
            c2.addEvent(b3, "afterAddSeries", function(b4) {
              a2.onSeriesAdded(b4.series);
            });
            c2.addEvent(b3, "redraw", function() {
              a2.announceDirtyData();
            });
          }
          onSeriesAdded(a2) {
            this.chart.options.accessibility.announceNewData.enabled && (this.dirty.hasDirty = true, this.dirty.allSeries[a2.name + a2.index] = a2, this.dirty.newSeries = k(this.dirty.newSeries) ? void 0 : a2);
          }
          announceDirtyData() {
            const a2 = this;
            if (this.chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
              let b3 = this.dirty.newPoint;
              b3 && (b3 = v(b3));
              this.queueAnnouncement(
                Object.keys(this.dirty.allSeries).map((b4) => a2.dirty.allSeries[b4]),
                this.dirty.newSeries,
                b3
              );
              this.dirty = { allSeries: {} };
            }
          }
          queueAnnouncement(a2, b3, c2) {
            var d2 = this.chart.options.accessibility.announceNewData;
            if (d2.enabled) {
              const f = +/* @__PURE__ */ new Date();
              d2 = Math.max(0, d2.minAnnounceInterval - (f - this.lastAnnouncementTime));
              a2 = z(this.queuedAnnouncement && this.queuedAnnouncement.series, a2);
              if (b3 = this.buildAnnouncementMessage(a2, b3, c2))
                this.queuedAnnouncement && clearTimeout(this.queuedAnnouncementTimer), this.queuedAnnouncement = { time: f, message: b3, series: a2 }, this.queuedAnnouncementTimer = setTimeout(() => {
                  this && this.announcer && (this.lastAnnouncementTime = +/* @__PURE__ */ new Date(), this.announcer.announce(this.queuedAnnouncement.message), delete this.queuedAnnouncement, delete this.queuedAnnouncementTimer);
                }, d2);
            }
          }
          buildAnnouncementMessage(d2, f, k2) {
            const e = this.chart;
            var n2 = e.options.accessibility.announceNewData;
            if (n2.announcementFormatter && (d2 = n2.announcementFormatter(d2, f, k2), false !== d2))
              return d2.length ? d2 : null;
            d2 = b2.charts && 1 < b2.charts.length ? "Multiple" : "Single";
            d2 = f ? "newSeriesAnnounce" + d2 : k2 ? "newPointAnnounce" + d2 : "newDataAnnounce";
            n2 = g(e);
            return e.langFormat("accessibility.announceNewData." + d2, { chartTitle: n2, seriesDesc: f ? c(f) : null, pointDesc: k2 ? a(k2) : null, point: k2, series: f });
          }
        }
        (function(a2) {
          function b3(a3) {
            const b4 = this.chart, c3 = this.newDataAnnouncer;
            c3 && c3.chart === b4 && b4.options.accessibility.announceNewData.enabled && (c3.dirty.newPoint = k(c3.dirty.newPoint) ? void 0 : a3.point);
          }
          function c2() {
            const a3 = this.chart, b4 = this.newDataAnnouncer;
            b4 && b4.chart === a3 && a3.options.accessibility.announceNewData.enabled && (b4.dirty.hasDirty = true, b4.dirty.allSeries[this.name + this.index] = this);
          }
          a2.composedMembers = [];
          a2.compose = function(d2) {
            r.pushUnique(
              a2.composedMembers,
              d2
            ) && (n(d2, "addPoint", b3), n(d2, "updatedData", c2));
          };
        })(d || (d = {}));
        return d;
      });
      x(b, "Accessibility/ProxyElement.js", [b["Core/Globals.js"], b["Core/Utilities.js"], b["Accessibility/Utils/EventProvider.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Accessibility/Utils/HTMLUtilities.js"]], function(b2, r, q, l, m) {
        const { doc: u } = b2, { attr: v, css: z, merge: n } = r, { fireEventOnWrappedOrUnwrappedElement: k } = l, { cloneMouseEvent: g, cloneTouchEvent: a, getFakeMouseEvent: c, removeElement: d } = m;
        class e {
          constructor(a2, b3, c2, d2) {
            this.chart = a2;
            this.target = b3;
            this.groupType = c2;
            c2 = "ul" === c2;
            this.eventProvider = new q();
            const f = c2 ? u.createElement("li") : null, e2 = this.buttonElement = u.createElement("button");
            a2.styledMode || this.hideButtonVisually(e2);
            f ? (c2 && !a2.styledMode && (f.style.listStyle = "none"), f.appendChild(e2), this.element = f) : this.element = e2;
            this.updateTarget(b3, d2);
          }
          click() {
            var a2 = this.getTargetPosition();
            a2.x += a2.width / 2;
            a2.y += a2.height / 2;
            a2 = c("click", a2);
            k(this.target.click, a2);
          }
          updateTarget(a2, b3) {
            this.target = a2;
            this.updateCSSClassName();
            const c2 = b3 || {};
            Object.keys(c2).forEach((a3) => {
              null === c2[a3] && delete c2[a3];
            });
            v(this.buttonElement, n({ "aria-label": this.getTargetAttr(a2.click, "aria-label") }, c2));
            this.eventProvider.removeAddedEvents();
            this.addProxyEventsToButton(this.buttonElement, a2.click);
            this.refreshPosition();
          }
          refreshPosition() {
            const a2 = this.getTargetPosition();
            z(this.buttonElement, { width: (a2.width || 1) + "px", height: (a2.height || 1) + "px", left: (Math.round(a2.x) || 0) + "px", top: (Math.round(a2.y) || 0) + "px" });
          }
          remove() {
            this.eventProvider.removeAddedEvents();
            d(this.element);
          }
          updateCSSClassName() {
            var a2 = this.chart.legend;
            a2 = a2.group && a2.group.div;
            a2 = -1 < (a2 && a2.className || "").indexOf("highcharts-no-tooltip");
            const b3 = -1 < (this.getTargetAttr(this.target.click, "class") || "").indexOf("highcharts-no-tooltip");
            this.buttonElement.className = a2 || b3 ? "highcharts-a11y-proxy-button highcharts-no-tooltip" : "highcharts-a11y-proxy-button";
          }
          addProxyEventsToButton(b3, c2) {
            "click touchstart touchend touchcancel touchmove mouseover mouseenter mouseleave mouseout".split(" ").forEach((d2) => {
              const f = 0 === d2.indexOf("touch");
              this.eventProvider.addEvent(
                b3,
                d2,
                (b4) => {
                  const d3 = f ? a(b4) : g(b4);
                  c2 && k(c2, d3);
                  b4.stopPropagation();
                  f || b4.preventDefault();
                },
                { passive: false }
              );
            });
          }
          hideButtonVisually(a2) {
            z(a2, { borderWidth: 0, backgroundColor: "transparent", cursor: "pointer", outline: "none", opacity: 1e-3, filter: "alpha(opacity=1)", zIndex: 999, overflow: "hidden", padding: 0, margin: 0, display: "block", position: "absolute", "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)" });
          }
          getTargetPosition() {
            var a2 = this.target.click;
            a2 = a2.element ? a2.element : a2;
            a2 = this.target.visual || a2;
            if (this.chart.renderTo && a2 && a2.getBoundingClientRect) {
              a2 = a2.getBoundingClientRect();
              const b3 = this.chart.pointer.getChartPosition();
              return { x: (a2.left - b3.left) / b3.scaleX, y: (a2.top - b3.top) / b3.scaleY, width: a2.right / b3.scaleX - a2.left / b3.scaleX, height: a2.bottom / b3.scaleY - a2.top / b3.scaleY };
            }
            return { x: 0, y: 0, width: 1, height: 1 };
          }
          getTargetAttr(a2, b3) {
            return a2.element ? a2.element.getAttribute(b3) : a2.getAttribute(b3);
          }
        }
        return e;
      });
      x(b, "Accessibility/ProxyProvider.js", [
        b["Core/Globals.js"],
        b["Core/Utilities.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Accessibility/Utils/DOMElementProvider.js"],
        b["Accessibility/Utils/HTMLUtilities.js"],
        b["Accessibility/ProxyElement.js"]
      ], function(b2, r, q, l, m, u) {
        const { doc: v } = b2, { attr: z, css: n } = r, { unhideChartElementFromAT: k } = q, { removeElement: g, removeChildNodes: a } = m;
        class c {
          constructor(a2) {
            this.chart = a2;
            this.domElementProvider = new l();
            this.groups = {};
            this.groupOrder = [];
            this.beforeChartProxyPosContainer = this.createProxyPosContainer("before");
            this.afterChartProxyPosContainer = this.createProxyPosContainer("after");
            this.update();
          }
          addProxyElement(a2, b3, c2) {
            const d = this.groups[a2];
            if (!d)
              throw Error("ProxyProvider.addProxyElement: Invalid group key " + a2);
            a2 = new u(this.chart, b3, d.type, c2);
            d.proxyContainerElement.appendChild(a2.element);
            d.proxyElements.push(a2);
            return a2;
          }
          addGroup(a2, b3, c2) {
            var d = this.groups[a2];
            if (d)
              return d.groupElement;
            d = this.domElementProvider.createElement(b3);
            let e;
            c2 && c2.role && "div" !== b3 ? (e = this.domElementProvider.createElement("div"), e.appendChild(d)) : e = d;
            e.className = "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" + a2.replace(/\W/g, "-");
            this.groups[a2] = {
              proxyContainerElement: d,
              groupElement: e,
              type: b3,
              proxyElements: []
            };
            z(e, c2 || {});
            "ul" === b3 && d.setAttribute("role", "list");
            this.afterChartProxyPosContainer.appendChild(e);
            this.updateGroupOrder(this.groupOrder);
            return e;
          }
          updateGroupAttrs(a2, b3) {
            const c2 = this.groups[a2];
            if (!c2)
              throw Error("ProxyProvider.updateGroupAttrs: Invalid group key " + a2);
            z(c2.groupElement, b3);
          }
          updateGroupOrder(b3) {
            this.groupOrder = b3.slice();
            if (!this.isDOMOrderGroupOrder()) {
              var c2 = b3.indexOf("series"), d = -1 < c2 ? b3.slice(0, c2) : b3, g2 = -1 < c2 ? b3.slice(c2 + 1) : [];
              b3 = v.activeElement;
              [
                "before",
                "after"
              ].forEach((b4) => {
                const c3 = this["before" === b4 ? "beforeChartProxyPosContainer" : "afterChartProxyPosContainer"];
                b4 = "before" === b4 ? d : g2;
                a(c3);
                b4.forEach((a2) => {
                  (a2 = this.groups[a2]) && c3.appendChild(a2.groupElement);
                });
              });
              (this.beforeChartProxyPosContainer.contains(b3) || this.afterChartProxyPosContainer.contains(b3)) && b3 && b3.focus && b3.focus();
            }
          }
          clearGroup(b3) {
            const c2 = this.groups[b3];
            if (!c2)
              throw Error("ProxyProvider.clearGroup: Invalid group key " + b3);
            a(c2.proxyContainerElement);
          }
          removeGroup(a2) {
            const b3 = this.groups[a2];
            b3 && (g(b3.groupElement), delete this.groups[a2]);
          }
          update() {
            this.updatePosContainerPositions();
            this.updateGroupOrder(this.groupOrder);
            this.updateProxyElementPositions();
          }
          updateProxyElementPositions() {
            Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));
          }
          updateGroupProxyElementPositions(a2) {
            (a2 = this.groups[a2]) && a2.proxyElements.forEach((a3) => a3.refreshPosition());
          }
          destroy() {
            this.domElementProvider.destroyCreatedElements();
          }
          createProxyPosContainer(a2) {
            const b3 = this.domElementProvider.createElement("div");
            b3.setAttribute(
              "aria-hidden",
              "false"
            );
            b3.className = "highcharts-a11y-proxy-container" + (a2 ? "-" + a2 : "");
            n(b3, { top: "0", left: "0" });
            this.chart.styledMode || (b3.style.whiteSpace = "nowrap", b3.style.position = "absolute");
            return b3;
          }
          getCurrentGroupOrderInDOM() {
            const a2 = (a3) => {
              const b4 = Object.keys(this.groups);
              let c3 = b4.length;
              for (; c3--; ) {
                const d = b4[c3], e = this.groups[d];
                if (e && a3 === e.groupElement)
                  return d;
              }
            };
            var b3 = (b4) => {
              const c3 = [];
              b4 = b4.children;
              for (let d = 0; d < b4.length; ++d) {
                const e = a2(b4[d]);
                e && c3.push(e);
              }
              return c3;
            };
            const c2 = b3(this.beforeChartProxyPosContainer);
            b3 = b3(this.afterChartProxyPosContainer);
            c2.push("series");
            return c2.concat(b3);
          }
          isDOMOrderGroupOrder() {
            const a2 = this.getCurrentGroupOrderInDOM(), b3 = this.groupOrder.filter((a3) => "series" === a3 || !!this.groups[a3]);
            let c2 = a2.length;
            if (c2 !== b3.length)
              return false;
            for (; c2--; )
              if (a2[c2] !== b3[c2])
                return false;
            return true;
          }
          updatePosContainerPositions() {
            const a2 = this.chart;
            if (!a2.renderer.forExport) {
              var b3 = a2.renderer.box;
              a2.container.insertBefore(this.afterChartProxyPosContainer, b3.nextSibling);
              a2.container.insertBefore(this.beforeChartProxyPosContainer, b3);
              k(this.chart, this.afterChartProxyPosContainer);
              k(this.chart, this.beforeChartProxyPosContainer);
            }
          }
        }
        return c;
      });
      x(b, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function() {
        return { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "→" }, rangeSelector: {
          allButtonsEnabled: false,
          buttons: void 0,
          buttonSpacing: 5,
          dropdown: "responsive",
          enabled: void 0,
          verticalAlign: "top",
          buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 },
          floating: false,
          x: 0,
          y: 0,
          height: void 0,
          inputBoxBorderColor: "none",
          inputBoxHeight: 17,
          inputBoxWidth: void 0,
          inputDateFormat: "%e %b %Y",
          inputDateParser: void 0,
          inputEditDateFormat: "%Y-%m-%d",
          inputEnabled: true,
          inputPosition: { align: "right", x: 0, y: 0 },
          inputSpacing: 5,
          selected: void 0,
          buttonPosition: { align: "left", x: 0, y: 0 },
          inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" },
          labelStyle: { color: "#666666", fontSize: "0.8em" }
        } };
      });
      x(b, "Stock/RangeSelector/RangeSelectorComposition.js", [b["Core/Defaults.js"], b["Stock/RangeSelector/RangeSelectorDefaults.js"], b["Core/Utilities.js"]], function(b2, r, q) {
        function l() {
          const a2 = this.range, b3 = a2.type, c2 = this.max, d2 = this.chart.time, e2 = function(a3, c3) {
            const h = "year" === b3 ? "FullYear" : "Month", p = new d2.Date(a3), t = d2.get(h, p);
            d2.set(h, p, t + c3);
            t === d2.get(h, p) && d2.set("Date", p, 0);
            return p.getTime() - a3;
          };
          let f2, g2;
          B(a2) ? (f2 = c2 - a2, g2 = a2) : a2 && (f2 = c2 + e2(c2, -(a2.count || 1)), this.chart && (this.chart.fixedRange = c2 - f2));
          const w = I(this.dataMin, Number.MIN_VALUE);
          B(f2) || (f2 = w);
          f2 <= w && (f2 = w, "undefined" === typeof g2 && (g2 = e2(f2, a2.count)), this.newMax = Math.min(f2 + g2, I(this.dataMax, Number.MAX_VALUE)));
          B(c2) ? !B(a2) && a2 && a2._offsetMin && (f2 += a2._offsetMin) : f2 = void 0;
          return f2;
        }
        function m() {
          this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new A(this));
        }
        function u() {
          var a2 = this.axes;
          const b3 = this.rangeSelector;
          b3 && (B(b3.deferredYTDClick) && (b3.clickButton(b3.deferredYTDClick), delete b3.deferredYTDClick), a2.forEach((a3) => {
            a3.updateNames();
            a3.setScale();
          }), this.getAxisMargins(), b3.render(), a2 = b3.options.verticalAlign, b3.options.floating || ("bottom" === a2 ? this.extraBottomMargin = true : "middle" !== a2 && (this.extraTopMargin = true)));
        }
        function v(a2) {
          let b3, c2, p, f2;
          const e2 = a2.rangeSelector, g2 = () => {
            e2 && (b3 = a2.xAxis[0].getExtremes(), c2 = a2.legend, f2 = e2 && e2.options.verticalAlign, B(b3.min) && e2.render(b3.min, b3.max), c2.display && "top" === f2 && f2 === c2.options.verticalAlign && (p = x2(a2.spacingBox), p.y = "vertical" === c2.options.layout ? a2.plotTop : p.y + e2.getHeight(), c2.group.placed = false, c2.align(p)));
          };
          e2 && (E(F, (b4) => b4[0] === a2) || F.push([a2, [d(a2.xAxis[0], "afterSetExtremes", function(a3) {
            e2 && e2.render(a3.min, a3.max);
          }), d(a2, "redraw", g2)]]), g2());
        }
        function z() {
          for (let a2 = 0, b3 = F.length; a2 < b3; ++a2) {
            const b4 = F[a2];
            if (b4[0] === this) {
              b4[1].forEach((a3) => a3());
              F.splice(a2, 1);
              break;
            }
          }
        }
        function n() {
          var a2 = this.rangeSelector;
          a2 && (a2 = a2.getHeight(), this.extraTopMargin && (this.plotTop += a2), this.extraBottomMargin && (this.marginBottom += a2));
        }
        function k() {
          var a2 = this.rangeSelector;
          a2 && !a2.options.floating && (a2.render(), a2 = a2.options.verticalAlign, "bottom" === a2 ? this.extraBottomMargin = true : "middle" !== a2 && (this.extraTopMargin = true));
        }
        function g(a2) {
          var b3 = a2.options.rangeSelector;
          a2 = this.extraBottomMargin;
          const c2 = this.extraTopMargin;
          let d2 = this.rangeSelector;
          b3 && b3.enabled && !e(d2) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = d2 = new A(this));
          this.extraTopMargin = this.extraBottomMargin = false;
          d2 && (v(this), b3 = b3 && b3.verticalAlign || d2.options && d2.options.verticalAlign, d2.options.floating || ("bottom" === b3 ? this.extraBottomMargin = true : "middle" !== b3 && (this.extraTopMargin = true)), this.extraBottomMargin !== a2 || this.extraTopMargin !== c2) && (this.isDirtyBox = true);
        }
        const { defaultOptions: a, setOptions: c } = b2, { addEvent: d, defined: e, extend: f, find: E, isNumber: B, merge: x2, pick: I } = q, F = [], G = [];
        let A;
        return { compose: function(b3, h, e2) {
          A = e2;
          q.pushUnique(G, b3) && (b3.prototype.minFromRange = l);
          q.pushUnique(G, h) && (d(h, "afterGetContainer", m), d(h, "beforeRender", u), d(h, "destroy", z), d(h, "getMargins", n), d(h, "render", k), d(h, "update", g), h.prototype.callbacks.push(v));
          q.pushUnique(G, c) && (f(a, { rangeSelector: r.rangeSelector }), f(a.lang, r.lang));
        } };
      });
      x(b, "Stock/RangeSelector/RangeSelector.js", [b["Core/Axis/Axis.js"], b["Core/Defaults.js"], b["Core/Globals.js"], b["Stock/RangeSelector/RangeSelectorComposition.js"], b["Core/Renderer/SVG/SVGElement.js"], b["Core/Utilities.js"]], function(b2, r, q, l, m, u) {
        function v(a2) {
          if (-1 !== a2.indexOf("%L"))
            return "text";
          const b3 = "aAdewbBmoyY".split("").some((b4) => -1 !== a2.indexOf("%" + b4)), c2 = "HkIlMS".split("").some((b4) => -1 !== a2.indexOf("%" + b4));
          return b3 && c2 ? "datetime-local" : b3 ? "date" : c2 ? "time" : "text";
        }
        const { defaultOptions: z } = r, { addEvent: n, createElement: k, css: g, defined: a, destroyObjectProperties: c, discardElement: d, extend: e, fireEvent: f, isNumber: E, merge: B, objectEach: x2, pad: I, pick: F, pInt: G, splat: A } = u;
        class y {
          static compose(a2, b3) {
            l.compose(a2, b3, y);
          }
          constructor(a2) {
            this.buttons = void 0;
            this.buttonOptions = y.prototype.defaultButtons;
            this.initialButtonGroupWidth = 0;
            this.options = void 0;
            this.chart = a2;
            this.init(a2);
          }
          clickButton(c2, d2) {
            const h = this.chart, e2 = this.buttonOptions[c2], t = h.xAxis[0];
            var g2 = h.scroller && h.scroller.getUnionExtremes() || t || {}, w = e2.type;
            const k2 = e2.dataGrouping;
            let y2 = g2.dataMin, m2 = g2.dataMax, q2, D = t && Math.round(Math.min(t.max, F(m2, t.max))), l2;
            g2 = e2._range;
            let r2, u2, v2, z2 = true;
            if (null !== y2 && null !== m2) {
              h.fixedRange = g2;
              this.setSelected(c2);
              k2 && (this.forcedDataGrouping = true, b2.prototype.setDataGrouping.call(t || { chart: this.chart }, k2, false), this.frozenStates = e2.preserveDataGrouping);
              if ("month" === w || "year" === w)
                t ? (w = { range: e2, max: D, chart: h, dataMin: y2, dataMax: m2 }, q2 = t.minFromRange.call(w), E(w.newMax) && (D = w.newMax), z2 = false) : g2 = e2;
              else if (g2)
                q2 = Math.max(D - g2, y2), D = Math.min(q2 + g2, m2), z2 = false;
              else if ("ytd" === w)
                if (t) {
                  if ("undefined" === typeof m2 || "undefined" === typeof y2)
                    y2 = Number.MAX_VALUE, m2 = Number.MIN_VALUE, h.series.forEach((a2) => {
                      if (a2 = a2.xData)
                        y2 = Math.min(a2[0], y2), m2 = Math.max(a2[a2.length - 1], m2);
                    }), d2 = false;
                  w = this.getYTDExtremes(m2, y2, h.time.useUTC);
                  q2 = r2 = w.min;
                  D = w.max;
                } else {
                  this.deferredYTDClick = c2;
                  return;
                }
              else
                "all" === w && t && (h.navigator && h.navigator.baseSeries[0] && (h.navigator.baseSeries[0].xAxis.options.range = void 0), q2 = y2, D = m2);
              z2 && e2._offsetMin && a(q2) && (q2 += e2._offsetMin);
              e2._offsetMax && a(D) && (D += e2._offsetMax);
              this.dropdown && (this.dropdown.selectedIndex = c2 + 1);
              t ? t.setExtremes(q2, D, F(d2, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: e2 }) : (l2 = A(h.options.xAxis)[0], v2 = l2.range, l2.range = g2, u2 = l2.min, l2.min = r2, n(h, "load", function() {
                l2.range = v2;
                l2.min = u2;
              }));
              f(this, "afterBtnClick");
            }
          }
          setSelected(a2) {
            this.selected = this.options.selected = a2;
          }
          init(a2) {
            const b3 = this, c2 = a2.options.rangeSelector, d2 = c2.buttons || b3.defaultButtons.slice(), h = c2.selected, e2 = function() {
              const a3 = b3.minInput, c3 = b3.maxInput;
              a3 && a3.blur && f(a3, "blur");
              c3 && c3.blur && f(c3, "blur");
            };
            b3.chart = a2;
            b3.options = c2;
            b3.buttons = [];
            b3.buttonOptions = d2;
            this.eventsToUnbind = [];
            this.eventsToUnbind.push(n(a2.container, "mousedown", e2));
            this.eventsToUnbind.push(n(a2, "resize", e2));
            d2.forEach(b3.computeButtonRange);
            "undefined" !== typeof h && d2[h] && this.clickButton(h, false);
            this.eventsToUnbind.push(n(a2, "load", function() {
              a2.xAxis && a2.xAxis[0] && n(a2.xAxis[0], "setExtremes", function(c3) {
                this.max - this.min !== a2.fixedRange && "rangeSelectorButton" !== c3.trigger && "updatedData" !== c3.trigger && b3.forcedDataGrouping && !b3.frozenStates && this.setDataGrouping(false, false);
              });
            }));
          }
          updateButtonStates() {
            const a2 = this;
            var b3 = this.chart;
            const c2 = this.dropdown, d2 = b3.xAxis[0], e2 = Math.round(d2.max - d2.min), f2 = !d2.hasVisibleSeries, g2 = b3.scroller && b3.scroller.getUnionExtremes() || d2, k2 = g2.dataMin, n2 = g2.dataMax;
            b3 = a2.getYTDExtremes(n2, k2, b3.time.useUTC);
            const y2 = b3.min, m2 = b3.max, D = a2.selected, A2 = a2.options.allButtonsEnabled, q2 = a2.buttons;
            let l2 = E(D);
            a2.buttonOptions.forEach((b4, h) => {
              var p = b4._range, t = b4.type, g3 = b4.count || 1;
              const C = q2[h], w = b4._offsetMax - b4._offsetMin, H = h === D, K = p > n2 - k2, M = p < d2.minRange;
              b4 = 0;
              let r2 = false, u2 = false;
              p = p === e2;
              ("month" === t || "year" === t) && e2 + 36e5 >= 864e5 * { month: 28, year: 365 }[t] * g3 - w && e2 - 36e5 <= 864e5 * { month: 31, year: 366 }[t] * g3 + w ? p = true : "ytd" === t ? (p = m2 - y2 + w === e2, r2 = !H) : "all" === t && (p = d2.max - d2.min >= n2 - k2, u2 = !H && l2 && p);
              t = !A2 && (K || M || u2 || f2);
              g3 = H && p || p && !l2 && !r2 || H && a2.frozenStates;
              t ? b4 = 3 : g3 && (l2 = true, b4 = 2);
              C.state !== b4 && (C.setState(b4), c2 && (c2.options[h + 1].disabled = t, 2 === b4 && (c2.selectedIndex = h + 1)), 0 === b4 && D === h && a2.setSelected());
            });
          }
          computeButtonRange(a2) {
            const b3 = a2.type, c2 = a2.count || 1, d2 = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
            if (d2[b3])
              a2._range = d2[b3] * c2;
            else if ("month" === b3 || "year" === b3)
              a2._range = 864e5 * { month: 30, year: 365 }[b3] * c2;
            a2._offsetMin = F(a2.offsetMin, 0);
            a2._offsetMax = F(a2.offsetMax, 0);
            a2._range += a2._offsetMax - a2._offsetMin;
          }
          getInputValue(a2) {
            a2 = "min" === a2 ? this.minInput : this.maxInput;
            const b3 = this.chart.options.rangeSelector, c2 = this.chart.time;
            return a2 ? ("text" === a2.type && b3.inputDateParser || this.defaultInputDateParser)(a2.value, c2.useUTC, c2) : 0;
          }
          setInputValue(b3, c2) {
            const d2 = this.options, h = this.chart.time, e2 = "min" === b3 ? this.minInput : this.maxInput;
            b3 = "min" === b3 ? this.minDateBox : this.maxDateBox;
            if (e2) {
              var f2 = e2.getAttribute("data-hc-time");
              f2 = a(f2) ? Number(f2) : void 0;
              a(c2) && (a(f2) && e2.setAttribute("data-hc-time-previous", f2), e2.setAttribute("data-hc-time", c2), f2 = c2);
              e2.value = h.dateFormat(this.inputTypeFormats[e2.type] || d2.inputEditDateFormat, f2);
              b3 && b3.attr({ text: h.dateFormat(
                d2.inputDateFormat,
                f2
              ) });
            }
          }
          setInputExtremes(a2, b3, c2) {
            if (a2 = "min" === a2 ? this.minInput : this.maxInput) {
              const d2 = this.inputTypeFormats[a2.type], h = this.chart.time;
              d2 && (b3 = h.dateFormat(d2, b3), a2.min !== b3 && (a2.min = b3), c2 = h.dateFormat(d2, c2), a2.max !== c2 && (a2.max = c2));
            }
          }
          showInput(a2) {
            const b3 = "min" === a2 ? this.minDateBox : this.maxDateBox;
            if ((a2 = "min" === a2 ? this.minInput : this.maxInput) && b3 && this.inputGroup) {
              const c2 = "text" === a2.type, { translateX: d2, translateY: h } = this.inputGroup, { inputBoxWidth: e2 } = this.options;
              g(a2, { width: c2 ? b3.width + (e2 ? -2 : 20) + "px" : "auto", height: b3.height - 2 + "px", border: "2px solid silver" });
              c2 && e2 ? g(a2, { left: d2 + b3.x + "px", top: h + "px" }) : g(a2, { left: Math.min(Math.round(b3.x + d2 - (a2.offsetWidth - b3.width) / 2), this.chart.chartWidth - a2.offsetWidth) + "px", top: h - (a2.offsetHeight - b3.height) / 2 + "px" });
            }
          }
          hideInput(a2) {
            (a2 = "min" === a2 ? this.minInput : this.maxInput) && g(a2, { top: "-9999em", border: 0, width: "1px", height: "1px" });
          }
          defaultInputDateParser(a2, b3, c2) {
            var d2 = a2.split("/").join("-").split(" ").join("T");
            -1 === d2.indexOf("T") && (d2 += "T00:00");
            if (b3)
              d2 += "Z";
            else {
              var h;
              if (h = q.isSafari)
                h = d2, h = !(6 < h.length && (h.lastIndexOf("-") === h.length - 6 || h.lastIndexOf("+") === h.length - 6));
              h && (h = new Date(d2).getTimezoneOffset() / 60, d2 += 0 >= h ? `+${I(-h)}:00` : `-${I(h)}:00`);
            }
            d2 = Date.parse(d2);
            E(d2) || (a2 = a2.split("-"), d2 = Date.UTC(G(a2[0]), G(a2[1]) - 1, G(a2[2])));
            c2 && b3 && E(d2) && (d2 += c2.getTimezoneOffset(d2));
            return d2;
          }
          drawInput(a2) {
            function b3() {
              const { maxInput: b4, minInput: d3 } = f2, h2 = c2.xAxis[0];
              var e2 = c2.scroller && c2.scroller.xAxis ? c2.scroller.xAxis : h2;
              const p = e2.dataMin;
              e2 = e2.dataMax;
              let g2 = f2.getInputValue(a2);
              g2 !== Number(D.getAttribute("data-hc-time-previous")) && E(g2) && (D.setAttribute("data-hc-time-previous", g2), m2 && b4 && E(p) ? g2 > Number(b4.getAttribute("data-hc-time")) ? g2 = void 0 : g2 < p && (g2 = p) : d3 && E(e2) && (g2 < Number(d3.getAttribute("data-hc-time")) ? g2 = void 0 : g2 > e2 && (g2 = e2)), "undefined" !== typeof g2 && h2.setExtremes(m2 ? g2 : h2.min, m2 ? h2.max : g2, void 0, void 0, { trigger: "rangeSelectorInput" }));
            }
            const { chart: c2, div: d2, inputGroup: h } = this, f2 = this, w = c2.renderer.style || {};
            var n2 = c2.renderer;
            const y2 = c2.options.rangeSelector, m2 = "min" === a2;
            var A2 = z.lang[m2 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
            A2 = n2.label(A2, 0).addClass("highcharts-range-label").attr({ padding: A2 ? 2 : 0, height: A2 ? y2.inputBoxHeight : 0 }).add(h);
            n2 = n2.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: y2.inputBoxWidth, height: y2.inputBoxHeight, "text-align": "center" }).on("click", function() {
              f2.showInput(a2);
              f2[a2 + "Input"].focus();
            });
            c2.styledMode || n2.attr({ stroke: y2.inputBoxBorderColor, "stroke-width": 1 });
            n2.add(h);
            const D = k("input", { name: a2, className: "highcharts-range-selector" }, void 0, d2);
            D.setAttribute("type", v(y2.inputDateFormat || "%e %b %Y"));
            c2.styledMode || (A2.css(B(w, y2.labelStyle)), n2.css(B(
              { color: "#333333" },
              w,
              y2.inputStyle
            )), g(D, e({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: w.fontSize, fontFamily: w.fontFamily, top: "-9999em" }, y2.inputStyle)));
            D.onfocus = () => {
              f2.showInput(a2);
            };
            D.onblur = () => {
              D === q.doc.activeElement && b3();
              f2.hideInput(a2);
              f2.setInputValue(a2);
              D.blur();
            };
            let l2 = false;
            D.onchange = () => {
              l2 || (b3(), f2.hideInput(a2), D.blur());
            };
            D.onkeypress = (a3) => {
              13 === a3.keyCode && b3();
            };
            D.onkeydown = (a3) => {
              l2 = true;
              38 !== a3.keyCode && 40 !== a3.keyCode || b3();
            };
            D.onkeyup = () => {
              l2 = false;
            };
            return { dateBox: n2, input: D, label: A2 };
          }
          getPosition() {
            var a2 = this.chart;
            const b3 = a2.options.rangeSelector;
            a2 = "top" === b3.verticalAlign ? a2.plotTop - a2.axisOffset[0] : 0;
            return { buttonTop: a2 + b3.buttonPosition.y, inputTop: a2 + b3.inputPosition.y - 10 };
          }
          getYTDExtremes(a2, b3, c2) {
            const d2 = this.chart.time;
            var e2 = new d2.Date(a2);
            const h = d2.get("FullYear", e2);
            c2 = c2 ? d2.Date.UTC(h, 0, 1) : +new d2.Date(h, 0, 1);
            b3 = Math.max(b3, c2);
            e2 = e2.getTime();
            return { max: Math.min(a2 || e2, e2), min: b3 };
          }
          render(b3, c2) {
            var d2 = this.chart, e2 = d2.renderer;
            const h = d2.container;
            var f2 = d2.options;
            const g2 = f2.rangeSelector, t = F(f2.chart.style && f2.chart.style.zIndex, 0) + 1;
            f2 = g2.inputEnabled;
            if (false !== g2.enabled) {
              this.rendered || (this.group = e2.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = k("div", void 0, { position: "relative", height: 0, zIndex: t }), this.buttonOptions.length && this.renderButtons(), h.parentNode && h.parentNode.insertBefore(this.div, h), f2 && (this.inputGroup = e2.g("input-group").add(this.group), e2 = this.drawInput("min"), this.minDateBox = e2.dateBox, this.minLabel = e2.label, this.minInput = e2.input, e2 = this.drawInput("max"), this.maxDateBox = e2.dateBox, this.maxLabel = e2.label, this.maxInput = e2.input));
              if (f2 && (this.setInputValue("min", b3), this.setInputValue("max", c2), b3 = d2.scroller && d2.scroller.getUnionExtremes() || d2.xAxis[0] || {}, a(b3.dataMin) && a(b3.dataMax) && (d2 = d2.xAxis[0].minRange || 0, this.setInputExtremes("min", b3.dataMin, Math.min(b3.dataMax, this.getInputValue("max")) - d2), this.setInputExtremes("max", Math.max(b3.dataMin, this.getInputValue("min")) + d2, b3.dataMax)), this.inputGroup)) {
                let a2 = 0;
                [
                  this.minLabel,
                  this.minDateBox,
                  this.maxLabel,
                  this.maxDateBox
                ].forEach((b4) => {
                  if (b4) {
                    const { width: c3 } = b4.getBBox();
                    c3 && (b4.attr({ x: a2 }), a2 += c3 + g2.inputSpacing);
                  }
                });
              }
              this.alignElements();
              this.rendered = true;
            }
          }
          renderButtons() {
            const { buttons: a2, chart: b3, options: c2 } = this, d2 = z.lang, e2 = b3.renderer, g2 = B(c2.buttonTheme), w = g2 && g2.states, y2 = g2.width || 28;
            delete g2.width;
            delete g2.states;
            this.buttonGroup = e2.g("range-selector-buttons").add(this.group);
            const m2 = this.dropdown = k("select", void 0, {
              position: "absolute",
              width: "1px",
              height: "1px",
              padding: 0,
              border: 0,
              top: "-9999em",
              cursor: "pointer",
              opacity: 1e-4
            }, this.div);
            n(m2, "touchstart", () => {
              m2.style.fontSize = "16px";
            });
            [[q.isMS ? "mouseover" : "mouseenter"], [q.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(([b4, c3]) => {
              n(m2, b4, () => {
                const d3 = a2[this.currentButtonIndex()];
                d3 && f(d3.element, c3 || b4);
              });
            });
            this.zoomText = e2.label(d2 && d2.rangeSelectorZoom || "", 0).attr({ padding: c2.buttonTheme.padding, height: c2.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup);
            this.chart.styledMode || (this.zoomText.css(c2.labelStyle), g2["stroke-width"] = F(
              g2["stroke-width"],
              0
            ));
            k("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, m2);
            this.buttonOptions.forEach((b4, c3) => {
              k("option", { textContent: b4.title || b4.text }, void 0, m2);
              a2[c3] = e2.button(b4.text, 0, 0, (a3) => {
                const d3 = b4.events && b4.events.click;
                let e3;
                d3 && (e3 = d3.call(b4, a3));
                false !== e3 && this.clickButton(c3);
                this.isActive = true;
              }, g2, w && w.hover, w && w.select, w && w.disabled).attr({ "text-align": "center", width: y2 }).add(this.buttonGroup);
              b4.title && a2[c3].attr("title", b4.title);
            });
          }
          alignElements() {
            const {
              buttonGroup: a2,
              buttons: b3,
              chart: c2,
              group: d2,
              inputGroup: e2,
              options: f2,
              zoomText: g2
            } = this;
            var k2 = c2.options;
            const n2 = k2.exporting && false !== k2.exporting.enabled && k2.navigation && k2.navigation.buttonOptions, { buttonPosition: y2, inputPosition: m2, verticalAlign: A2 } = f2;
            k2 = (a3, b4) => n2 && this.titleCollision(c2) && "top" === A2 && "right" === b4.align && b4.y - a3.getBBox().height - 12 < (n2.y || 0) + (n2.height || 0) + c2.spacing[0] ? -40 : 0;
            var q2 = c2.plotLeft;
            if (d2 && y2 && m2) {
              var l2 = y2.x - c2.spacing[3];
              if (a2) {
                this.positionButtons();
                if (!this.initialButtonGroupWidth) {
                  let a3 = 0;
                  g2 && (a3 += g2.getBBox().width + 5);
                  b3.forEach((c3, d3) => {
                    a3 += c3.width;
                    d3 !== b3.length - 1 && (a3 += f2.buttonSpacing);
                  });
                  this.initialButtonGroupWidth = a3;
                }
                q2 -= c2.spacing[3];
                this.updateButtonStates();
                var r2 = k2(a2, y2);
                this.alignButtonGroup(r2);
                d2.placed = a2.placed = c2.hasLoaded;
              }
              r2 = 0;
              e2 && (r2 = k2(e2, m2), "left" === m2.align ? l2 = q2 : "right" === m2.align && (l2 = -Math.max(c2.axisOffset[1], -r2)), e2.align({ y: m2.y, width: e2.getBBox().width, align: m2.align, x: m2.x + l2 - 2 }, true, c2.spacingBox), e2.placed = c2.hasLoaded);
              this.handleCollision(r2);
              d2.align({ verticalAlign: A2 }, true, c2.spacingBox);
              k2 = d2.alignAttr.translateY;
              q2 = d2.getBBox().height + 20;
              l2 = 0;
              "bottom" === A2 && (l2 = (l2 = c2.legend && c2.legend.options) && "bottom" === l2.verticalAlign && l2.enabled && !l2.floating ? c2.legend.legendHeight + F(l2.margin, 10) : 0, q2 = q2 + l2 - 20, l2 = k2 - q2 - (f2.floating ? 0 : f2.y) - (c2.titleOffset ? c2.titleOffset[2] : 0) - 10);
              if ("top" === A2)
                f2.floating && (l2 = 0), c2.titleOffset && c2.titleOffset[0] && (l2 = c2.titleOffset[0]), l2 += c2.margin[0] - c2.spacing[0] || 0;
              else if ("middle" === A2) {
                if (m2.y === y2.y)
                  l2 = k2;
                else if (m2.y || y2.y)
                  l2 = 0 > m2.y || 0 > y2.y ? l2 - Math.min(m2.y, y2.y) : k2 - q2;
              }
              d2.translate(f2.x, f2.y + Math.floor(l2));
              const { minInput: h, maxInput: p, dropdown: t } = this;
              f2.inputEnabled && h && p && (h.style.marginTop = d2.translateY + "px", p.style.marginTop = d2.translateY + "px");
              t && (t.style.marginTop = d2.translateY + "px");
            }
          }
          alignButtonGroup(a2, b3) {
            const { chart: c2, options: d2, buttonGroup: e2 } = this, { buttonPosition: f2 } = d2, h = c2.plotLeft - c2.spacing[3];
            let g2 = f2.x - c2.spacing[3];
            "right" === f2.align ? g2 += a2 - h : "center" === f2.align && (g2 -= h / 2);
            e2 && e2.align({ y: f2.y, width: F(b3, this.initialButtonGroupWidth), align: f2.align, x: g2 }, true, c2.spacingBox);
          }
          positionButtons() {
            const { buttons: a2, chart: b3, options: c2, zoomText: d2 } = this, e2 = b3.hasLoaded ? "animate" : "attr", { buttonPosition: f2 } = c2, g2 = b3.plotLeft;
            let k2 = g2;
            d2 && "hidden" !== d2.visibility && (d2[e2]({ x: F(g2 + f2.x, g2) }), k2 += f2.x + d2.getBBox().width + 5);
            for (let b4 = 0, d3 = this.buttonOptions.length; b4 < d3; ++b4)
              if ("hidden" !== a2[b4].visibility)
                a2[b4][e2]({ x: k2 }), k2 += a2[b4].width + c2.buttonSpacing;
              else
                a2[b4][e2]({ x: g2 });
          }
          handleCollision(a2) {
            const { chart: b3, buttonGroup: c2, inputGroup: d2 } = this, { buttonPosition: e2, dropdown: f2, inputPosition: h } = this.options, g2 = () => {
              let a3 = 0;
              this.buttons.forEach((b4) => {
                b4 = b4.getBBox();
                b4.width > a3 && (a3 = b4.width);
              });
              return a3;
            }, k2 = (b4) => {
              if (d2 && c2) {
                const f3 = d2.alignAttr.translateX + d2.alignOptions.x - a2 + d2.getBBox().x + 2, g3 = d2.alignOptions.width, k3 = c2.alignAttr.translateX + c2.getBBox().x;
                return k3 + b4 > f3 && f3 + g3 > k3 && e2.y < h.y + d2.getBBox().height;
              }
              return false;
            }, n2 = () => {
              d2 && c2 && d2.attr({ translateX: d2.alignAttr.translateX + (b3.axisOffset[1] >= -a2 ? 0 : -a2), translateY: d2.alignAttr.translateY + c2.getBBox().height + 10 });
            };
            if (c2) {
              if ("always" === f2) {
                this.collapseButtons(a2);
                k2(g2()) && n2();
                return;
              }
              "never" === f2 && this.expandButtons();
            }
            d2 && c2 ? h.align === e2.align || k2(this.initialButtonGroupWidth + 20) ? "responsive" === f2 ? (this.collapseButtons(a2), k2(g2()) && n2()) : n2() : "responsive" === f2 && this.expandButtons() : c2 && "responsive" === f2 && (this.initialButtonGroupWidth > b3.plotWidth ? this.collapseButtons(a2) : this.expandButtons());
          }
          collapseButtons(a2) {
            const { buttons: b3, buttonOptions: c2, chart: d2, dropdown: e2, options: f2, zoomText: h } = this, g2 = d2.userOptions.rangeSelector && d2.userOptions.rangeSelector.buttonTheme || {}, k2 = (a3) => ({ text: a3 ? `${a3} ▾` : "▾", width: "auto", paddingLeft: F(f2.buttonTheme.paddingLeft, g2.padding, 8), paddingRight: F(f2.buttonTheme.paddingRight, g2.padding, 8) });
            h && h.hide();
            let n2 = false;
            c2.forEach((a3, c3) => {
              c3 = b3[c3];
              2 !== c3.state ? c3.hide() : (c3.show(), c3.attr(k2(a3.text)), n2 = true);
            });
            n2 || (e2 && (e2.selectedIndex = 0), b3[0].show(), b3[0].attr(k2(this.zoomText && this.zoomText.textStr)));
            const { align: m2 } = f2.buttonPosition;
            this.positionButtons();
            "right" !== m2 && "center" !== m2 || this.alignButtonGroup(a2, b3[this.currentButtonIndex()].getBBox().width);
            this.showDropdown();
          }
          expandButtons() {
            const { buttons: a2, buttonOptions: b3, options: c2, zoomText: d2 } = this;
            this.hideDropdown();
            d2 && d2.show();
            b3.forEach((b4, d3) => {
              d3 = a2[d3];
              d3.show();
              d3.attr({ text: b4.text, width: c2.buttonTheme.width || 28, paddingLeft: F(c2.buttonTheme.paddingLeft, "unset"), paddingRight: F(c2.buttonTheme.paddingRight, "unset") });
              2 > d3.state && d3.setState(0);
            });
            this.positionButtons();
          }
          currentButtonIndex() {
            const { dropdown: a2 } = this;
            return a2 && 0 < a2.selectedIndex ? a2.selectedIndex - 1 : 0;
          }
          showDropdown() {
            const { buttonGroup: a2, buttons: b3, chart: c2, dropdown: d2 } = this;
            if (a2 && d2) {
              const { translateX: e2, translateY: f2 } = a2, h = b3[this.currentButtonIndex()].getBBox();
              g(d2, { left: c2.plotLeft + e2 + "px", top: f2 + 0.5 + "px", width: h.width + "px", height: h.height + "px" });
              this.hasVisibleDropdown = true;
            }
          }
          hideDropdown() {
            const { dropdown: a2 } = this;
            a2 && (g(a2, { top: "-9999em", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
          }
          getHeight() {
            var a2 = this.options, b3 = this.group;
            const c2 = a2.y, d2 = a2.buttonPosition.y, e2 = a2.inputPosition.y;
            if (a2.height)
              return a2.height;
            this.alignElements();
            a2 = b3 ? b3.getBBox(true).height + 13 + c2 : 0;
            b3 = Math.min(e2, d2);
            if (0 > e2 && 0 > d2 || 0 < e2 && 0 < d2)
              a2 += Math.abs(b3);
            return a2;
          }
          titleCollision(a2) {
            return !(a2.options.title.text || a2.options.subtitle.text);
          }
          update(a2) {
            const b3 = this.chart;
            B(true, b3.options.rangeSelector, a2);
            this.destroy();
            this.init(b3);
            this.render();
          }
          destroy() {
            const a2 = this, b3 = a2.minInput, e2 = a2.maxInput;
            a2.eventsToUnbind && (a2.eventsToUnbind.forEach((a3) => a3()), a2.eventsToUnbind = void 0);
            c(a2.buttons);
            b3 && (b3.onfocus = b3.onblur = b3.onchange = null);
            e2 && (e2.onfocus = e2.onblur = e2.onchange = null);
            x2(a2, function(b4, c2) {
              b4 && "chart" !== c2 && (b4 instanceof m ? b4.destroy() : b4 instanceof window.HTMLElement && d(b4));
              b4 !== y.prototype[c2] && (a2[c2] = null);
            }, this);
          }
        }
        e(y.prototype, { defaultButtons: [{
          type: "month",
          count: 1,
          text: "1m",
          title: "View 1 month"
        }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } });
        "";
        return y;
      });
      x(b, "Accessibility/Components/RangeSelectorComponent.js", [
        b["Stock/RangeSelector/RangeSelector.js"],
        b["Accessibility/AccessibilityComponent.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Accessibility/Utils/Announcer.js"],
        b["Accessibility/KeyboardNavigationHandler.js"],
        b["Core/Utilities.js"]
      ], function(b2, r, q, l, m, u) {
        const { unhideChartElementFromAT: v, getAxisRangeDescription: z } = q, { addEvent: n, attr: k } = u;
        class g extends r {
          constructor() {
            super(...arguments);
            this.announcer = void 0;
          }
          init() {
            this.announcer = new l(this.chart, "polite");
          }
          onChartUpdate() {
            const a = this.chart, b3 = this, d = a.rangeSelector;
            d && (this.updateSelectorVisibility(), this.setDropdownAttrs(), d.buttons && d.buttons.length && d.buttons.forEach((a2) => {
              b3.setRangeButtonAttrs(a2);
            }), d.maxInput && d.minInput && ["minInput", "maxInput"].forEach(function(c, f) {
              if (c = d[c])
                v(a, c), b3.setRangeInputAttrs(c, "accessibility.rangeSelector." + (f ? "max" : "min") + "InputLabel");
            }));
          }
          updateSelectorVisibility() {
            const a = this.chart, b3 = a.rangeSelector, d = b3 && b3.dropdown, e = b3 && b3.buttons || [];
            b3 && b3.hasVisibleDropdown && d ? (v(a, d), e.forEach((a2) => a2.element.setAttribute("aria-hidden", true))) : (d && d.setAttribute("aria-hidden", true), e.forEach((b4) => v(a, b4.element)));
          }
          setDropdownAttrs() {
            var a = this.chart;
            const b3 = a.rangeSelector && a.rangeSelector.dropdown;
            b3 && (a = a.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: a.options.lang.rangeSelectorZoom }), b3.setAttribute("aria-label", a), b3.setAttribute("tabindex", -1));
          }
          setRangeButtonAttrs(a) {
            k(a.element, { tabindex: -1, role: "button" });
          }
          setRangeInputAttrs(a, b3) {
            const c = this.chart;
            k(a, { tabindex: -1, "aria-label": c.langFormat(b3, { chart: c }) });
          }
          onButtonNavKbdArrowKey(a, b3) {
            const c = a.response, e = this.keyCodes, f = this.chart, g2 = f.options.accessibility.keyboardNavigation.wrapAround;
            b3 = b3 === e.left || b3 === e.up ? -1 : 1;
            return f.highlightRangeSelectorButton(f.highlightedRangeSelectorItemIx + b3) ? c.success : g2 ? (a.init(b3), c.success) : c[0 < b3 ? "next" : "prev"];
          }
          onButtonNavKbdClick(a) {
            a = a.response;
            const b3 = this.chart;
            3 !== b3.oldRangeSelectorItemState && this.fakeClickEvent(b3.rangeSelector.buttons[b3.highlightedRangeSelectorItemIx].element);
            return a.success;
          }
          onAfterBtnClick() {
            var a = this.chart;
            const b3 = z(a.xAxis[0]);
            (a = a.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart: a, axisRangeDescription: b3 })) && this.announcer.announce(a);
          }
          onInputKbdMove(a) {
            const b3 = this.chart;
            var d = b3.rangeSelector;
            const e = b3.highlightedInputRangeIx = (b3.highlightedInputRangeIx || 0) + a;
            if (1 < e || 0 > e) {
              if (b3.accessibility)
                return b3.accessibility.keyboardNavigation.exiting = true, b3.accessibility.keyboardNavigation.tabindexContainer.focus(), b3.accessibility.keyboardNavigation.move(a);
            } else
              d && (a = d[e ? "maxDateBox" : "minDateBox"], d = d[e ? "maxInput" : "minInput"], a && d && b3.setFocusToElement(a, d));
            return true;
          }
          onInputNavInit(a) {
            const b3 = this;
            var d = this.chart;
            const e = 0 < a ? 0 : 1;
            var f = d.rangeSelector;
            const g2 = f && f[e ? "maxDateBox" : "minDateBox"];
            a = f && f.minInput;
            f = f && f.maxInput;
            d.highlightedInputRangeIx = e;
            if (g2 && a && f) {
              d.setFocusToElement(g2, e ? f : a);
              this.removeInputKeydownHandler && this.removeInputKeydownHandler();
              d = (a2) => {
                (a2.which || a2.keyCode) === this.keyCodes.tab && b3.onInputKbdMove(a2.shiftKey ? -1 : 1) && (a2.preventDefault(), a2.stopPropagation());
              };
              const c = n(a, "keydown", d), k2 = n(f, "keydown", d);
              this.removeInputKeydownHandler = () => {
                c();
                k2();
              };
            }
          }
          onInputNavTerminate() {
            const a = this.chart.rangeSelector || {};
            a.maxInput && a.hideInput("max");
            a.minInput && a.hideInput("min");
            this.removeInputKeydownHandler && (this.removeInputKeydownHandler(), delete this.removeInputKeydownHandler);
          }
          initDropdownNav() {
            const a = this.chart, b3 = a.rangeSelector, d = b3 && b3.dropdown;
            b3 && d && (a.setFocusToElement(b3.buttonGroup, d), this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler(), this.removeDropdownKeydownHandler = n(d, "keydown", (b4) => {
              const c = a.accessibility;
              (b4.which || b4.keyCode) === this.keyCodes.tab && (b4.preventDefault(), b4.stopPropagation(), c && (c.keyboardNavigation.tabindexContainer.focus(), c.keyboardNavigation.move(b4.shiftKey ? -1 : 1)));
            }));
          }
          getRangeSelectorButtonNavigation() {
            const a = this.chart, b3 = this.keyCodes, d = this;
            return new m(a, { keyCodeMap: [[[b3.left, b3.right, b3.up, b3.down], function(a2) {
              return d.onButtonNavKbdArrowKey(this, a2);
            }], [[b3.enter, b3.space], function() {
              return d.onButtonNavKbdClick(this);
            }]], validate: function() {
              return !!(a.rangeSelector && a.rangeSelector.buttons && a.rangeSelector.buttons.length);
            }, init: function(b4) {
              var c = a.rangeSelector;
              c && c.hasVisibleDropdown ? d.initDropdownNav() : c && (c = c.buttons.length - 1, a.highlightRangeSelectorButton(0 < b4 ? 0 : c));
            }, terminate: function() {
              d.removeDropdownKeydownHandler && (d.removeDropdownKeydownHandler(), delete d.removeDropdownKeydownHandler);
            } });
          }
          getRangeSelectorInputNavigation() {
            const a = this.chart, b3 = this;
            return new m(a, { keyCodeMap: [], validate: function() {
              return !!(a.rangeSelector && a.rangeSelector.inputGroup && "hidden" !== a.rangeSelector.inputGroup.element.style.visibility && false !== a.options.rangeSelector.inputEnabled && a.rangeSelector.minInput && a.rangeSelector.maxInput);
            }, init: function(a2) {
              b3.onInputNavInit(a2);
            }, terminate: function() {
              b3.onInputNavTerminate();
            } });
          }
          getKeyboardNavigation() {
            return [this.getRangeSelectorButtonNavigation(), this.getRangeSelectorInputNavigation()];
          }
          destroy() {
            this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler();
            this.removeInputKeydownHandler && this.removeInputKeydownHandler();
            this.announcer && this.announcer.destroy();
          }
        }
        (function(a) {
          function c(a2) {
            const b3 = this.rangeSelector && this.rangeSelector.buttons || [], c2 = this.highlightedRangeSelectorItemIx, d2 = this.rangeSelector && this.rangeSelector.selected;
            "undefined" !== typeof c2 && b3[c2] && c2 !== d2 && b3[c2].setState(this.oldRangeSelectorItemState || 0);
            this.highlightedRangeSelectorItemIx = a2;
            return b3[a2] ? (this.setFocusToElement(b3[a2].box, b3[a2].element), a2 !== d2 && (this.oldRangeSelectorItemState = b3[a2].state, b3[a2].setState(1)), true) : false;
          }
          function d() {
            const a2 = this.chart.accessibility;
            if (a2 && a2.components.rangeSelector)
              return a2.components.rangeSelector.onAfterBtnClick();
          }
          const e = [];
          a.compose = function(a2, g2) {
            u.pushUnique(e, a2) && (a2.prototype.highlightRangeSelectorButton = c);
            u.pushUnique(e, g2) && n(b2, "afterBtnClick", d);
          };
        })(g || (g = {}));
        return g;
      });
      x(b, "Accessibility/Components/SeriesComponent/ForcedMarkers.js", [b["Core/Utilities.js"]], function(b2) {
        const { addEvent: r, merge: q } = b2;
        var l;
        (function(m) {
          function l2(a) {
            q(true, a, { marker: { enabled: true, states: { normal: { opacity: 0 } } } });
          }
          function v(a) {
            return a.marker.states && a.marker.states.normal && a.marker.states.normal.opacity;
          }
          function z() {
            if (this.chart.styledMode) {
              if (this.markerGroup)
                this.markerGroup[this.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
              this._hasPointMarkers && this.points && this.points.length && this.points.forEach((a) => {
                a.graphic && (a.graphic[a.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden"), a.graphic[false === a.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible"));
              });
            }
          }
          function n(a) {
            this.resetA11yMarkerOptions = q(a.options.marker || {}, this.userOptions.marker || {});
          }
          function k() {
            var a = this.options, b3 = false !== (this.options.accessibility && this.options.accessibility.enabled);
            if (b3 = this.chart.options.accessibility.enabled && b3)
              b3 = this.chart.options.accessibility, b3 = this.points.length < b3.series.pointDescriptionEnabledThreshold || false === b3.series.pointDescriptionEnabledThreshold;
            if (b3) {
              if (a.marker && false === a.marker.enabled && (this.a11yMarkersForced = true, l2(this.options)), this._hasPointMarkers && this.points && this.points.length)
                for (a = this.points.length; a--; ) {
                  b3 = this.points[a];
                  const c = b3.options;
                  var d = b3.hasForcedA11yMarker;
                  delete b3.hasForcedA11yMarker;
                  c.marker && (d = d && 0 === v(c), c.marker.enabled && !d ? (q(true, c.marker, { states: { normal: { opacity: v(c) || 1 } } }), b3.hasForcedA11yMarker = false) : false === c.marker.enabled && (l2(c), b3.hasForcedA11yMarker = true));
                }
            } else
              this.a11yMarkersForced && (delete this.a11yMarkersForced, (a = this.resetA11yMarkerOptions) && this.update({ marker: { enabled: a.enabled, states: { normal: { opacity: a.states && a.states.normal && a.states.normal.opacity } } } }), delete this.resetA11yMarkerOptions);
          }
          const g = [];
          m.compose = function(a) {
            b2.pushUnique(g, a) && (r(a, "afterSetOptions", n), r(
              a,
              "render",
              k
            ), r(a, "afterRender", z));
          };
        })(l || (l = {}));
        return l;
      });
      x(b, "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js", [b["Core/Series/Point.js"], b["Core/Series/Series.js"], b["Core/Series/SeriesRegistry.js"], b["Core/Globals.js"], b["Core/Utilities.js"], b["Accessibility/KeyboardNavigationHandler.js"], b["Accessibility/Utils/EventProvider.js"], b["Accessibility/Utils/ChartUtilities.js"]], function(b2, r, q, l, m, u, x2, z) {
        function n(a2) {
          const b3 = a2.index, c2 = a2.series.points;
          let d2 = c2.length;
          if (c2[b3] !== a2)
            for (; d2--; ) {
              if (c2[d2] === a2)
                return d2;
            }
          else
            return b3;
        }
        function k(a2) {
          const b3 = a2.chart.options.accessibility.keyboardNavigation.seriesNavigation, c2 = a2.options.accessibility || {}, d2 = c2.keyboardNavigation;
          return d2 && false === d2.enabled || false === c2.enabled || false === a2.options.enableMouseTracking || !a2.visible || b3.pointNavigationEnabledThreshold && b3.pointNavigationEnabledThreshold <= a2.points.length;
        }
        function g(a2) {
          const b3 = a2.series.chart.options.accessibility, c2 = a2.options.accessibility && false === a2.options.accessibility.enabled;
          return a2.isNull && b3.keyboardNavigation.seriesNavigation.skipNullPoints || false === a2.visible || false === a2.isInside || c2 || k(a2.series);
        }
        function a(a2) {
          a2 = a2.series || [];
          const b3 = a2.length;
          for (let d2 = 0; d2 < b3; ++d2)
            if (!k(a2[d2])) {
              a: {
                var c2 = a2[d2].points || [];
                const b4 = c2.length;
                for (let a3 = 0; a3 < b4; ++a3)
                  if (!g(c2[a3])) {
                    c2 = c2[a3];
                    break a;
                  }
                c2 = null;
              }
              if (c2)
                return c2;
            }
          return null;
        }
        function c(a2) {
          let b3 = a2.series.length, c2 = false;
          for (; b3-- && !(a2.highlightedPoint = a2.series[b3].points[a2.series[b3].points.length - 1], c2 = a2.series[b3].highlightNextValidPoint()); )
            ;
          return c2;
        }
        function d(b3) {
          delete b3.highlightedPoint;
          return (b3 = a(b3)) ? b3.highlight() : false;
        }
        const { seriesTypes: e } = q, { doc: f } = l, { defined: v, fireEvent: B } = m, { getPointFromXY: L, getSeriesFromName: I, scrollToPoint: F } = z;
        class G {
          constructor(a2, b3) {
            this.keyCodes = b3;
            this.chart = a2;
          }
          init() {
            const c2 = this, d2 = this.chart, e2 = this.eventProvider = new x2();
            e2.addEvent(r, "destroy", function() {
              return c2.onSeriesDestroy(this);
            });
            e2.addEvent(d2, "afterApplyDrilldown", function() {
              {
                const b3 = a(this);
                b3 && b3.highlight(false);
              }
            });
            e2.addEvent(d2, "drilldown", function(a2) {
              a2 = a2.point;
              const b3 = a2.series;
              c2.lastDrilledDownPoint = { x: a2.x, y: a2.y, seriesName: b3 ? b3.name : "" };
            });
            e2.addEvent(
              d2,
              "drillupall",
              function() {
                setTimeout(function() {
                  c2.onDrillupAll();
                }, 10);
              }
            );
            e2.addEvent(b2, "afterSetState", function() {
              const a2 = this.graphic && this.graphic.element, b3 = f.activeElement;
              var c3 = b3 && b3.getAttribute("class");
              c3 = c3 && -1 < c3.indexOf("highcharts-a11y-proxy-button");
              d2.highlightedPoint === this && b3 !== a2 && !c3 && a2 && a2.focus && a2.focus();
            });
          }
          onDrillupAll() {
            const b3 = this.lastDrilledDownPoint, c2 = this.chart, d2 = b3 && I(c2, b3.seriesName);
            let e2;
            b3 && d2 && v(b3.x) && v(b3.y) && (e2 = L(d2, b3.x, b3.y));
            e2 = e2 || a(c2);
            c2.container && c2.container.focus();
            e2 && e2.highlight && e2.highlight(false);
          }
          getKeyboardNavigationHandler() {
            const b3 = this, e2 = this.keyCodes, f2 = this.chart, g2 = f2.inverted;
            return new u(f2, { keyCodeMap: [[g2 ? [e2.up, e2.down] : [e2.left, e2.right], function(a2) {
              return b3.onKbdSideways(this, a2);
            }], [g2 ? [e2.left, e2.right] : [e2.up, e2.down], function(a2) {
              return b3.onKbdVertical(this, a2);
            }], [[e2.enter, e2.space], function(a2, b4) {
              if (a2 = f2.highlightedPoint)
                b4.point = a2, B(a2.series, "click", b4), a2.firePointEvent("click");
              return this.response.success;
            }], [[e2.home], function() {
              d(f2);
              return this.response.success;
            }], [[e2.end], function() {
              c(f2);
              return this.response.success;
            }], [[
              e2.pageDown,
              e2.pageUp
            ], function(a2) {
              f2.highlightAdjacentSeries(a2 === e2.pageDown);
              return this.response.success;
            }]], init: function() {
              return b3.onHandlerInit(this);
            }, validate: function() {
              return !!a(f2);
            }, terminate: function() {
              return b3.onHandlerTerminate();
            } });
          }
          onKbdSideways(a2, b3) {
            const c2 = this.keyCodes;
            return this.attemptHighlightAdjacentPoint(a2, b3 === c2.right || b3 === c2.down);
          }
          onHandlerInit(a2) {
            const b3 = this.chart;
            b3.options.accessibility.keyboardNavigation.seriesNavigation.rememberPointFocus && b3.highlightedPoint ? b3.highlightedPoint.highlight() : d(b3);
            return a2.response.success;
          }
          onKbdVertical(a2, b3) {
            const c2 = this.chart;
            var d2 = this.keyCodes;
            b3 = b3 === d2.down || b3 === d2.right;
            d2 = c2.options.accessibility.keyboardNavigation.seriesNavigation;
            if (d2.mode && "serialize" === d2.mode)
              return this.attemptHighlightAdjacentPoint(a2, b3);
            c2[c2.highlightedPoint && c2.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries"](b3);
            return a2.response.success;
          }
          onHandlerTerminate() {
            const a2 = this.chart, b3 = a2.options.accessibility.keyboardNavigation;
            a2.tooltip && a2.tooltip.hide(0);
            const c2 = a2.highlightedPoint && a2.highlightedPoint.series;
            if (c2 && c2.onMouseOut)
              c2.onMouseOut();
            if (a2.highlightedPoint && a2.highlightedPoint.onMouseOut)
              a2.highlightedPoint.onMouseOut();
            b3.seriesNavigation.rememberPointFocus || delete a2.highlightedPoint;
          }
          attemptHighlightAdjacentPoint(a2, b3) {
            const e2 = this.chart, f2 = e2.options.accessibility.keyboardNavigation.wrapAround;
            return e2.highlightAdjacentPoint(b3) ? a2.response.success : f2 && (b3 ? d(e2) : c(e2)) ? a2.response.success : a2.response[b3 ? "next" : "prev"];
          }
          onSeriesDestroy(a2) {
            const b3 = this.chart;
            b3.highlightedPoint && b3.highlightedPoint.series === a2 && (delete b3.highlightedPoint, b3.focusElement && b3.focusElement.removeFocusBorder());
          }
          destroy() {
            this.eventProvider.removeAddedEvents();
          }
        }
        (function(a2) {
          function b3(a3) {
            var b4 = this.series;
            const c3 = this.highlightedPoint;
            var d3 = c3 && n(c3) || 0;
            const e2 = c3 && c3.series.points || [];
            var f3 = this.series && this.series[this.series.length - 1];
            f3 = f3 && f3.points && f3.points[f3.points.length - 1];
            if (!b4[0] || !b4[0].points)
              return false;
            if (c3) {
              if (b4 = b4[c3.series.index + (a3 ? 1 : -1)], d3 = e2[d3 + (a3 ? 1 : -1)], !d3 && b4 && (d3 = b4.points[a3 ? 0 : b4.points.length - 1]), !d3)
                return false;
            } else
              d3 = a3 ? b4[0].points[0] : f3;
            return g(d3) ? (b4 = d3.series, k(b4) ? this.highlightedPoint = a3 ? b4.points[b4.points.length - 1] : b4.points[0] : this.highlightedPoint = d3, this.highlightAdjacentPoint(a3)) : d3.highlight();
          }
          function c2(a3) {
            const b4 = this.highlightedPoint;
            let c3 = Infinity, d3;
            if (!v(b4.plotX) || !v(b4.plotY))
              return false;
            this.series.forEach((e2) => {
              k(e2) || e2.points.forEach((f3) => {
                if (v(f3.plotY) && v(f3.plotX) && f3 !== b4) {
                  var k2 = f3.plotY - b4.plotY, h = Math.abs(f3.plotX - b4.plotX);
                  h = Math.abs(k2) * Math.abs(k2) + h * h * 4;
                  e2.yAxis && e2.yAxis.reversed && (k2 *= -1);
                  !(0 >= k2 && a3 || 0 <= k2 && !a3 || 5 > h || g(f3)) && h < c3 && (c3 = h, d3 = f3);
                }
              });
            });
            return d3 ? d3.highlight() : false;
          }
          function d2(a3) {
            const b4 = this.highlightedPoint;
            var c3 = this.series && this.series[this.series.length - 1], d3 = c3 && c3.points && c3.points[c3.points.length - 1];
            if (!this.highlightedPoint)
              return c3 = a3 ? this.series && this.series[0] : c3, (d3 = a3 ? c3 && c3.points && c3.points[0] : d3) ? d3.highlight() : false;
            c3 = this.series[b4.series.index + (a3 ? -1 : 1)];
            if (!c3)
              return false;
            d3 = f2(b4, c3, 4);
            if (!d3)
              return false;
            if (k(c3))
              return d3.highlight(), a3 = this.highlightAdjacentSeries(a3), a3 ? a3 : (b4.highlight(), false);
            d3.highlight();
            return d3.series.highlightNextValidPoint();
          }
          function f2(a3, b4, c3, d3) {
            let e2 = Infinity;
            let f3, g2 = b4.points.length;
            const k2 = (a4) => !(v(a4.plotX) && v(a4.plotY));
            if (!k2(a3)) {
              for (; g2--; ) {
                var h = b4.points[g2];
                k2(h) || (h = (a3.plotX - h.plotX) * (a3.plotX - h.plotX) * (c3 || 1) + (a3.plotY - h.plotY) * (a3.plotY - h.plotY) * (d3 || 1), h < e2 && (e2 = h, f3 = g2));
              }
              return v(f3) ? b4.points[f3] : void 0;
            }
          }
          function l2(a3 = true) {
            const b4 = this.series.chart;
            if (!this.isNull && a3)
              this.onMouseOver();
            else
              b4.tooltip && b4.tooltip.hide(0);
            F(this);
            this.graphic && (b4.setFocusToElement(this.graphic), !a3 && b4.focusElement && b4.focusElement.removeFocusBorder());
            b4.highlightedPoint = this;
            return this;
          }
          function q2() {
            var a3 = this.chart.highlightedPoint, b4 = (a3 && a3.series) === this ? n(a3) : 0;
            a3 = this.points;
            const c3 = a3.length;
            if (a3 && c3) {
              for (let d3 = b4; d3 < c3; ++d3)
                if (!g(a3[d3]))
                  return a3[d3].highlight();
              for (; 0 <= b4; --b4)
                if (!g(a3[b4]))
                  return a3[b4].highlight();
            }
            return false;
          }
          const r2 = [];
          a2.compose = function(a3, f3, g2) {
            m.pushUnique(r2, a3) && (a3 = a3.prototype, a3.highlightAdjacentPoint = b3, a3.highlightAdjacentPointVertical = c2, a3.highlightAdjacentSeries = d2);
            m.pushUnique(
              r2,
              f3
            ) && (f3.prototype.highlight = l2);
            m.pushUnique(r2, g2) && (f3 = g2.prototype, f3.keyboardMoveVertical = true, ["column", "gantt", "pie"].forEach((a4) => {
              e[a4] && (e[a4].prototype.keyboardMoveVertical = false);
            }), f3.highlightNextValidPoint = q2);
          };
        })(G || (G = {}));
        return G;
      });
      x(b, "Accessibility/Components/SeriesComponent/SeriesComponent.js", [
        b["Accessibility/AccessibilityComponent.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Accessibility/Components/SeriesComponent/ForcedMarkers.js"],
        b["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
        b["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
        b["Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js"]
      ], function(b2, r, q, l, m, u) {
        const { hideSeriesFromAT: v } = r, { describeSeries: z } = m;
        class n extends b2 {
          static compose(b3, g, a) {
            l.compose(a);
            q.compose(a);
            u.compose(b3, g, a);
          }
          init() {
            this.newDataAnnouncer = new l(this.chart);
            this.newDataAnnouncer.init();
            this.keyboardNavigation = new u(this.chart, this.keyCodes);
            this.keyboardNavigation.init();
            this.hideTooltipFromATWhenShown();
            this.hideSeriesLabelsFromATWhenShown();
          }
          hideTooltipFromATWhenShown() {
            const b3 = this;
            this.chart.tooltip && this.addEvent(this.chart.tooltip.constructor, "refresh", function() {
              this.chart === b3.chart && this.label && this.label.element && this.label.element.setAttribute("aria-hidden", true);
            });
          }
          hideSeriesLabelsFromATWhenShown() {
            this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
              this.series.forEach(function(b3) {
                b3.labelBySeries && b3.labelBySeries.attr("aria-hidden", true);
              });
            });
          }
          onChartRender() {
            this.chart.series.forEach(function(b3) {
              false !== (b3.options.accessibility && b3.options.accessibility.enabled) && b3.visible ? z(b3) : v(b3);
            });
          }
          getKeyboardNavigation() {
            return this.keyboardNavigation.getKeyboardNavigationHandler();
          }
          destroy() {
            this.newDataAnnouncer.destroy();
            this.keyboardNavigation.destroy();
          }
        }
        return n;
      });
      x(b, "Accessibility/Components/ZoomComponent.js", [b["Accessibility/AccessibilityComponent.js"], b["Accessibility/Utils/ChartUtilities.js"], b["Accessibility/Utils/HTMLUtilities.js"], b["Accessibility/KeyboardNavigationHandler.js"], b["Core/Utilities.js"]], function(b2, r, q, l, m) {
        const { unhideChartElementFromAT: v } = r, { getFakeMouseEvent: x2 } = q, { attr: z, pick: n } = m;
        class k extends b2 {
          constructor() {
            super(...arguments);
            this.focusedMapNavButtonIx = -1;
          }
          init() {
            const b3 = this, a = this.chart;
            this.proxyProvider.addGroup("zoom", "div");
            ["afterShowResetZoom", "afterApplyDrilldown", "drillupall"].forEach((c) => {
              b3.addEvent(a, c, function() {
                b3.updateProxyOverlays();
              });
            });
          }
          onChartUpdate() {
            const b3 = this.chart, a = this;
            b3.mapNavigation && b3.mapNavigation.navButtons.forEach((c, d) => {
              v(b3, c.element);
              a.setMapNavButtonAttrs(c.element, "accessibility.zoom.mapZoom" + (d ? "Out" : "In"));
            });
          }
          setMapNavButtonAttrs(b3, a) {
            const c = this.chart;
            a = c.langFormat(a, { chart: c });
            z(b3, { tabindex: -1, role: "button", "aria-label": a });
          }
          onChartRender() {
            this.updateProxyOverlays();
          }
          updateProxyOverlays() {
            const b3 = this.chart;
            this.proxyProvider.clearGroup("zoom");
            b3.resetZoomButton && this.createZoomProxyButton(b3.resetZoomButton, "resetZoomProxyButton", b3.langFormat("accessibility.zoom.resetZoomButton", { chart: b3 }));
            b3.drillUpButton && b3.breadcrumbs && b3.breadcrumbs.list && this.createZoomProxyButton(
              b3.drillUpButton,
              "drillUpProxyButton",
              b3.langFormat("accessibility.drillUpButton", { chart: b3, buttonText: b3.breadcrumbs.getButtonText(b3.breadcrumbs.list[b3.breadcrumbs.list.length - 1]) })
            );
          }
          createZoomProxyButton(b3, a, c) {
            this[a] = this.proxyProvider.addProxyElement("zoom", { click: b3 }, { "aria-label": c, tabindex: -1 });
          }
          getMapZoomNavigation() {
            const b3 = this.keyCodes, a = this.chart, c = this;
            return new l(a, { keyCodeMap: [
              [[b3.up, b3.down, b3.left, b3.right], function(a2) {
                return c.onMapKbdArrow(this, a2);
              }],
              [[b3.tab], function(a2, b4) {
                return c.onMapKbdTab(this, b4);
              }],
              [[b3.space, b3.enter], function() {
                return c.onMapKbdClick(this);
              }]
            ], validate: function() {
              return !!(a.mapView && a.mapNavigation && a.mapNavigation.navButtons.length);
            }, init: function(a2) {
              return c.onMapNavInit(a2);
            } });
          }
          onMapKbdArrow(b3, a) {
            var c = this.chart, d = this.keyCodes;
            const e = c.container;
            var f = a === d.up || a === d.down;
            a = (f ? c.plotHeight : c.plotWidth) / 10 * (a === d.left || a === d.up ? 1 : -1);
            d = 10 * Math.random();
            c = { x: e.offsetLeft + c.plotLeft + c.plotWidth / 2 + d, y: e.offsetTop + c.plotTop + c.plotHeight / 2 + d };
            f = f ? { x: c.x, y: c.y + a } : { x: c.x + a, y: c.y };
            [x2("mousedown", c), x2("mousemove", f), x2("mouseup", f)].forEach((a2) => e.dispatchEvent(a2));
            return b3.response.success;
          }
          onMapKbdTab(b3, a) {
            const c = this.chart;
            b3 = b3.response;
            const d = (a = a.shiftKey) && !this.focusedMapNavButtonIx || !a && this.focusedMapNavButtonIx;
            c.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);
            if (d)
              return c.mapView && c.mapView.zoomBy(), b3[a ? "prev" : "next"];
            this.focusedMapNavButtonIx += a ? -1 : 1;
            a = c.mapNavigation.navButtons[this.focusedMapNavButtonIx];
            c.setFocusToElement(a.box, a.element);
            a.setState(2);
            return b3.success;
          }
          onMapKbdClick(b3) {
            this.fakeClickEvent(this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element);
            return b3.response.success;
          }
          onMapNavInit(b3) {
            const a = this.chart;
            var c = a.mapNavigation.navButtons[0];
            const d = a.mapNavigation.navButtons[1];
            c = 0 < b3 ? c : d;
            a.setFocusToElement(c.box, c.element);
            c.setState(2);
            this.focusedMapNavButtonIx = 0 < b3 ? 0 : 1;
          }
          simpleButtonNavigation(b3, a, c) {
            const d = this.keyCodes, e = this, f = this.chart;
            return new l(f, { keyCodeMap: [[[d.tab, d.up, d.down, d.left, d.right], function(a2, b4) {
              return this.response[a2 === d.tab && b4.shiftKey || a2 === d.left || a2 === d.up ? "prev" : "next"];
            }], [[d.space, d.enter], function() {
              const a2 = c(this, f);
              return n(a2, this.response.success);
            }]], validate: function() {
              return f[b3] && f[b3].box && e[a].buttonElement;
            }, init: function() {
              f.setFocusToElement(f[b3].box, e[a].buttonElement);
            } });
          }
          getKeyboardNavigation() {
            return [this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(b3, a) {
              a.zoomOut();
            }), this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(b3, a) {
              a.drillUp();
              return b3.response.prev;
            }), this.getMapZoomNavigation()];
          }
        }
        return k;
      });
      x(b, "Accessibility/HighContrastMode.js", [b["Core/Globals.js"]], function(b2) {
        const { doc: r, isMS: q, win: l } = b2;
        return { isHighContrastModeActive: function() {
          var b3 = /(Edg)/.test(l.navigator.userAgent);
          if (l.matchMedia && b3)
            return l.matchMedia("(-ms-high-contrast: active)").matches;
          if (q && l.getComputedStyle) {
            b3 = r.createElement("div");
            b3.style.backgroundImage = "url(data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)";
            r.body.appendChild(b3);
            const m = (b3.currentStyle || l.getComputedStyle(b3)).backgroundImage;
            r.body.removeChild(b3);
            return "none" === m;
          }
          return l.matchMedia && l.matchMedia("(forced-colors: active)").matches;
        }, setHighContrastTheme: function(b3) {
          b3.highContrastModeActive = true;
          const m = b3.options.accessibility.highContrastTheme;
          b3.update(m, false);
          b3.series.forEach(function(b4) {
            const l2 = m.plotOptions[b4.type] || {};
            b4.update({ color: l2.color || "windowText", colors: [l2.color || "windowText"], borderColor: l2.borderColor || "window" });
            b4.points.forEach(function(b5) {
              b5.options && b5.options.color && b5.update({ color: l2.color || "windowText", borderColor: l2.borderColor || "window" }, false);
            });
          });
          b3.redraw();
        } };
      });
      x(b, "Accessibility/HighContrastTheme.js", [], function() {
        return { chart: { backgroundColor: "window" }, title: { style: { color: "windowText" } }, subtitle: { style: { color: "windowText" } }, colorAxis: { minColor: "windowText", maxColor: "windowText", stops: [] }, colors: ["windowText"], xAxis: {
          gridLineColor: "windowText",
          labels: { style: { color: "windowText" } },
          lineColor: "windowText",
          minorGridLineColor: "windowText",
          tickColor: "windowText",
          title: { style: { color: "windowText" } }
        }, yAxis: { gridLineColor: "windowText", labels: { style: { color: "windowText" } }, lineColor: "windowText", minorGridLineColor: "windowText", tickColor: "windowText", title: { style: { color: "windowText" } } }, tooltip: { backgroundColor: "window", borderColor: "windowText", style: { color: "windowText" } }, plotOptions: { series: { lineColor: "windowText", fillColor: "window", borderColor: "windowText", edgeColor: "windowText", borderWidth: 1, dataLabels: { connectorColor: "windowText", color: "windowText", style: {
          color: "windowText",
          textOutline: "none"
        } }, marker: { lineColor: "windowText", fillColor: "windowText" } }, pie: { color: "window", colors: ["window"], borderColor: "windowText", borderWidth: 1 }, boxplot: { fillColor: "window" }, candlestick: { lineColor: "windowText", fillColor: "window" }, errorbar: { fillColor: "window" } }, legend: { backgroundColor: "window", itemStyle: { color: "windowText" }, itemHoverStyle: { color: "windowText" }, itemHiddenStyle: { color: "#555" }, title: { style: { color: "windowText" } } }, credits: { style: { color: "windowText" } }, drilldown: {
          activeAxisLabelStyle: { color: "windowText" },
          activeDataLabelStyle: { color: "windowText" }
        }, navigation: { buttonOptions: { symbolStroke: "windowText", theme: { fill: "window" } } }, rangeSelector: { buttonTheme: { fill: "window", stroke: "windowText", style: { color: "windowText" }, states: { hover: { fill: "window", stroke: "windowText", style: { color: "windowText" } }, select: { fill: "#444", stroke: "windowText", style: { color: "windowText" } } } }, inputBoxBorderColor: "windowText", inputStyle: { backgroundColor: "window", color: "windowText" }, labelStyle: { color: "windowText" } }, navigator: { handles: {
          backgroundColor: "window",
          borderColor: "windowText"
        }, outlineColor: "windowText", maskFill: "transparent", series: { color: "windowText", lineColor: "windowText" }, xAxis: { gridLineColor: "windowText" } }, scrollbar: { barBackgroundColor: "#444", barBorderColor: "windowText", buttonArrowColor: "windowText", buttonBackgroundColor: "window", buttonBorderColor: "windowText", rifleColor: "windowText", trackBackgroundColor: "window", trackBorderColor: "windowText" } };
      });
      x(b, "Accessibility/Options/A11yDefaults.js", [], function() {
        return { accessibility: { enabled: true, screenReaderSection: {
          beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
          afterChartFormat: "{endOfChartMarker}",
          axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
        }, series: { descriptionFormat: "{seriesDescription}{authorDescription}{axisDescription}", describeSingleSeries: false, pointDescriptionEnabledThreshold: 200 }, point: { valueDescriptionFormat: "{xDescription}{separator}{value}.", describeNull: true }, landmarkVerbosity: "all", linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description', keyboardNavigation: { enabled: true, focusBorder: { enabled: true, hideBrowserFocusOutline: true, style: {
          color: "#334eff",
          lineWidth: 2,
          borderRadius: 3
        }, margin: 2 }, order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"], wrapAround: true, seriesNavigation: { skipNullPoints: true, pointNavigationEnabledThreshold: false, rememberPointFocus: false } }, announceNewData: { enabled: false, minAnnounceInterval: 5e3, interruptUser: false } }, legend: { accessibility: { enabled: true, keyboardNavigation: { enabled: true } } }, exporting: { accessibility: { enabled: true } } };
      });
      x(b, "Accessibility/Options/LangDefaults.js", [], function() {
        return { accessibility: {
          defaultChartTitle: "Chart",
          chartContainerLabel: "{title}. Highcharts interactive chart.",
          svgContainerLabel: "Interactive chart",
          drillUpButton: "{buttonText}",
          credits: "Chart credits: {creditsStr}",
          thousandsSep: ",",
          svgContainerTitle: "",
          graphicContainerLabel: "",
          screenReaderSection: {
            beforeRegionLabel: "",
            afterRegionLabel: "",
            annotations: { heading: "Chart annotations summary", descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}", descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{#each additionalAnnotationPoints}, also related to {this}{/each}", descriptionNoPoints: "{annotationText}" },
            endOfChartMarker: "End of interactive chart."
          },
          sonification: { playAsSoundButtonText: "Play as sound, {chartTitle}", playAsSoundClickAnnouncement: "Play" },
          legend: { legendLabelNoTitle: "Toggle series visibility, {chartTitle}", legendLabel: "Chart legend: {legendTitle}", legendItem: "Show {itemName}" },
          zoom: { mapZoomIn: "Zoom chart", mapZoomOut: "Zoom out chart", resetZoomButton: "Reset zoom" },
          rangeSelector: { dropdownLabel: "{rangeTitle}", minInputLabel: "Select start date.", maxInputLabel: "Select end date.", clickButtonAnnouncement: "Viewing {axisRangeDescription}" },
          table: { viewAsDataTableButtonText: "View as data table, {chartTitle}", tableSummary: "Table representation of chart." },
          announceNewData: { newDataAnnounce: "Updated data for chart {chartTitle}", newSeriesAnnounceSingle: "New data series: {seriesDesc}", newPointAnnounceSingle: "New data point: {pointDesc}", newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}", newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}" },
          seriesTypeDescriptions: {
            boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
            arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
            areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
            bubble: "Bubble charts are scatter charts where each data point also has a size value.",
            columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
            errorbar: "Errorbar series are used to display the variability of the data.",
            funnel: "Funnel charts are used to display reduction of data in stages.",
            pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
            waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
          },
          chartTypes: {
            emptyChart: "Empty chart",
            mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
            unknownMap: "Map of unspecified region with {numSeries} data series.",
            combinationChart: "Combination chart with {numSeries} data series.",
            defaultSingle: "Chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
            defaultMultiple: "Chart with {numSeries} data series.",
            splineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
            splineMultiple: "Line chart with {numSeries} lines.",
            lineSingle: "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
            lineMultiple: "Line chart with {numSeries} lines.",
            columnSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
            columnMultiple: "Bar chart with {numSeries} data series.",
            barSingle: "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
            barMultiple: "Bar chart with {numSeries} data series.",
            pieSingle: "Pie chart with {numPoints} {#eq numPoints 1}slice{else}slices{/eq}.",
            pieMultiple: "Pie chart with {numSeries} pies.",
            scatterSingle: "Scatter chart with {numPoints} {#eq numPoints 1}point{else}points{/eq}.",
            scatterMultiple: "Scatter chart with {numSeries} data series.",
            boxplotSingle: "Boxplot with {numPoints} {#eq numPoints 1}box{else}boxes{/eq}.",
            boxplotMultiple: "Boxplot with {numSeries} data series.",
            bubbleSingle: "Bubble chart with {numPoints} {#eq numPoints 1}bubbles{else}bubble{/eq}.",
            bubbleMultiple: "Bubble chart with {numSeries} data series."
          },
          axis: {
            xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
            xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
            yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
            yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
            timeRangeDays: "Data range: {range} days.",
            timeRangeHours: "Data range: {range} hours.",
            timeRangeMinutes: "Data range: {range} minutes.",
            timeRangeSeconds: "Data range: {range} seconds.",
            rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.",
            rangeCategories: "Data range: {numCategories} categories."
          },
          exporting: { chartMenuLabel: "Chart menu", menuButtonLabel: "View chart menu, {chartTitle}" },
          series: {
            summary: {
              "default": "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              defaultCombination: "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              lineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              spline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              splineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              column: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
              columnCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
              bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
              barCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
              pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
              pieCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
              scatter: "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
              scatterCombination: "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
              boxplot: "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
              boxplotCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
              bubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
              bubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
              map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
              mapCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
              mapline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              maplineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
              mapbubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
              mapbubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}."
            },
            description: "{description}",
            xAxisDescription: "X axis, {name}",
            yAxisDescription: "Y axis, {name}",
            nullPointValue: "No value",
            pointAnnotationsDescription: "{#each annotations}Annotation: {this}{/each}"
          }
        } };
      });
      x(b, "Accessibility/Options/DeprecatedOptions.js", [b["Core/Utilities.js"]], function(b2) {
        function r(b3, k, g) {
          let a, c = 0;
          for (; c < k.length - 1; ++c)
            a = k[c], b3 = b3[a] = z(b3[a], {});
          b3[k[k.length - 1]] = g;
        }
        function q(b3, k, g, a) {
          function c(a2, b4) {
            return b4.reduce(function(a3, b5) {
              return a3[b5];
            }, a2);
          }
          const d = c(b3.options, k), e = c(
            b3.options,
            g
          );
          Object.keys(a).forEach(function(c2) {
            const f = d[c2];
            "undefined" !== typeof f && (r(e, a[c2], f), x2(32, false, b3, { [k.join(".") + "." + c2]: g.join(".") + "." + a[c2].join(".") }));
          });
        }
        function l(b3) {
          const k = b3.options.chart, g = b3.options.accessibility || {};
          ["description", "typeDescription"].forEach(function(a) {
            k[a] && (g[a] = k[a], x2(32, false, b3, { [`chart.${a}`]: `use accessibility.${a}` }));
          });
        }
        function m(b3) {
          b3.axes.forEach(function(k) {
            (k = k.options) && k.description && (k.accessibility = k.accessibility || {}, k.accessibility.description = k.description, x2(
              32,
              false,
              b3,
              { "axis.description": "use axis.accessibility.description" }
            ));
          });
        }
        function v(b3) {
          const k = { description: ["accessibility", "description"], exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"], pointDescriptionFormatter: ["accessibility", "point", "descriptionFormatter"], skipKeyboardNavigation: ["accessibility", "keyboardNavigation", "enabled"], "accessibility.pointDescriptionFormatter": ["accessibility", "point", "descriptionFormatter"] };
          b3.series.forEach(function(g) {
            Object.keys(k).forEach(function(a) {
              let c = g.options[a];
              "accessibility.pointDescriptionFormatter" === a && (c = g.options.accessibility && g.options.accessibility.pointDescriptionFormatter);
              "undefined" !== typeof c && (r(g.options, k[a], "skipKeyboardNavigation" === a ? !c : c), x2(32, false, b3, { [`series.${a}`]: "series." + k[a].join(".") }));
            });
          });
        }
        const { error: x2, pick: z } = b2;
        return function(b3) {
          l(b3);
          m(b3);
          b3.series && v(b3);
          q(b3, ["accessibility"], ["accessibility"], {
            pointDateFormat: ["point", "dateFormat"],
            pointDateFormatter: ["point", "dateFormatter"],
            pointDescriptionFormatter: [
              "point",
              "descriptionFormatter"
            ],
            pointDescriptionThreshold: ["series", "pointDescriptionEnabledThreshold"],
            pointNavigationThreshold: ["keyboardNavigation", "seriesNavigation", "pointNavigationEnabledThreshold"],
            pointValueDecimals: ["point", "valueDecimals"],
            pointValuePrefix: ["point", "valuePrefix"],
            pointValueSuffix: ["point", "valueSuffix"],
            screenReaderSectionFormatter: ["screenReaderSection", "beforeChartFormatter"],
            describeSingleSeries: ["series", "describeSingleSeries"],
            seriesDescriptionFormatter: ["series", "descriptionFormatter"],
            onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
            axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
          });
          q(b3, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], { skipNullPoints: ["skipNullPoints"], mode: ["mode"] });
          q(b3, ["lang", "accessibility"], ["lang", "accessibility"], { legendItem: ["legend", "legendItem"], legendLabel: ["legend", "legendLabel"], mapZoomIn: ["zoom", "mapZoomIn"], mapZoomOut: ["zoom", "mapZoomOut"], resetZoomButton: [
            "zoom",
            "resetZoomButton"
          ], screenReaderRegionLabel: ["screenReaderSection", "beforeRegionLabel"], rangeSelectorButton: ["rangeSelector", "buttonText"], rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"], rangeSelectorMinInput: ["rangeSelector", "minInputLabel"], svgContainerEnd: ["screenReaderSection", "endOfChartMarker"], viewAsDataTable: ["table", "viewAsDataTableButtonText"], tableSummary: ["table", "tableSummary"] });
        };
      });
      x(b, "Accessibility/Accessibility.js", [
        b["Core/Defaults.js"],
        b["Core/Globals.js"],
        b["Core/Utilities.js"],
        b["Accessibility/Utils/HTMLUtilities.js"],
        b["Accessibility/A11yI18n.js"],
        b["Accessibility/Components/ContainerComponent.js"],
        b["Accessibility/FocusBorder.js"],
        b["Accessibility/Components/InfoRegionsComponent.js"],
        b["Accessibility/KeyboardNavigation.js"],
        b["Accessibility/Components/LegendComponent.js"],
        b["Accessibility/Components/MenuComponent.js"],
        b["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
        b["Accessibility/ProxyProvider.js"],
        b["Accessibility/Components/RangeSelectorComponent.js"],
        b["Accessibility/Components/SeriesComponent/SeriesComponent.js"],
        b["Accessibility/Components/ZoomComponent.js"],
        b["Accessibility/HighContrastMode.js"],
        b["Accessibility/HighContrastTheme.js"],
        b["Accessibility/Options/A11yDefaults.js"],
        b["Accessibility/Options/LangDefaults.js"],
        b["Accessibility/Options/DeprecatedOptions.js"]
      ], function(b2, r, q, l, m, u, x2, z, n, k, g, a, c, d, e, f, E, B, J, I, F) {
        ({ defaultOptions: b2 } = b2);
        const { doc: v } = r, { addEvent: A, extend: y, fireEvent: h, merge: t } = q, { removeElement: p } = l;
        class C {
          constructor(a2) {
            this.proxyProvider = this.keyboardNavigation = this.components = this.chart = void 0;
            this.init(a2);
          }
          init(a2) {
            this.chart = a2;
            v.addEventListener ? (F(a2), this.proxyProvider = new c(this.chart), this.initComponents(), this.keyboardNavigation = new n(a2, this.components)) : (this.zombie = true, this.components = {}, a2.renderTo.setAttribute("aria-hidden", true));
          }
          initComponents() {
            const a2 = this.chart, b3 = this.proxyProvider, c2 = a2.options.accessibility;
            this.components = { container: new u(), infoRegions: new z(), legend: new k(), chartMenu: new g(), rangeSelector: new d(), series: new e(), zoom: new f() };
            c2.customComponents && y(this.components, c2.customComponents);
            const h2 = this.components;
            this.getComponentOrder().forEach(function(c3) {
              h2[c3].initBase(a2, b3);
              h2[c3].init();
            });
          }
          getComponentOrder() {
            if (!this.components)
              return [];
            if (!this.components.series)
              return Object.keys(this.components);
            const a2 = Object.keys(this.components).filter((a3) => "series" !== a3);
            return ["series"].concat(a2);
          }
          update() {
            const a2 = this.components, b3 = this.chart;
            var c2 = b3.options.accessibility;
            h(b3, "beforeA11yUpdate");
            b3.types = this.getChartTypes();
            c2 = c2.keyboardNavigation.order;
            this.proxyProvider.updateGroupOrder(c2);
            this.getComponentOrder().forEach(function(c3) {
              a2[c3].onChartUpdate();
              h(b3, "afterA11yComponentUpdate", { name: c3, component: a2[c3] });
            });
            this.keyboardNavigation.update(c2);
            !b3.highContrastModeActive && E.isHighContrastModeActive() && E.setHighContrastTheme(b3);
            h(b3, "afterA11yUpdate", { accessibility: this });
          }
          destroy() {
            const a2 = this.chart || {}, b3 = this.components;
            Object.keys(b3).forEach(function(a3) {
              b3[a3].destroy();
              b3[a3].destroyBase();
            });
            this.proxyProvider && this.proxyProvider.destroy();
            a2.announcerContainer && p(a2.announcerContainer);
            this.keyboardNavigation && this.keyboardNavigation.destroy();
            a2.renderTo && a2.renderTo.setAttribute("aria-hidden", true);
            a2.focusElement && a2.focusElement.removeFocusBorder();
          }
          getChartTypes() {
            const a2 = {};
            this.chart.series.forEach(function(b3) {
              a2[b3.type] = 1;
            });
            return Object.keys(a2);
          }
        }
        (function(b3) {
          function c2() {
            this.accessibility && this.accessibility.destroy();
          }
          function f2() {
            this.a11yDirty && this.renderTo && (delete this.a11yDirty, this.updateA11yEnabled());
            const a2 = this.accessibility;
            a2 && !a2.zombie && (a2.proxyProvider.updateProxyElementPositions(), a2.getComponentOrder().forEach(function(b4) {
              a2.components[b4].onChartRender();
            }));
          }
          function h2(a2) {
            if (a2 = a2.options.accessibility)
              a2.customComponents && (this.options.accessibility.customComponents = a2.customComponents, delete a2.customComponents), t(true, this.options.accessibility, a2), this.accessibility && this.accessibility.destroy && (this.accessibility.destroy(), delete this.accessibility);
            this.a11yDirty = true;
          }
          function l2() {
            let a2 = this.accessibility;
            const c3 = this.options.accessibility;
            c3 && c3.enabled ? a2 && !a2.zombie ? a2.update() : (this.accessibility = a2 = new b3(this), !a2.zombie) && a2.update() : a2 ? (a2.destroy && a2.destroy(), delete this.accessibility) : this.renderTo.setAttribute("aria-hidden", true);
          }
          function p2() {
            this.series.chart.accessibility && (this.series.chart.a11yDirty = true);
          }
          const r2 = [];
          b3.i18nFormat = m.i18nFormat;
          b3.compose = function(b4, v2, t2, u2, w, y2) {
            n.compose(b4);
            a.compose(u2);
            k.compose(b4, v2);
            g.compose(b4);
            e.compose(b4, t2, u2);
            m.compose(b4);
            x2.compose(b4, w);
            y2 && d.compose(b4, y2);
            q.pushUnique(r2, b4) && (b4.prototype.updateA11yEnabled = l2, A(b4, "destroy", c2), A(b4, "render", f2), A(b4, "update", h2), ["addSeries", "init"].forEach((a2) => {
              A(b4, a2, function() {
                this.a11yDirty = true;
              });
            }), ["afterApplyDrilldown", "drillupall"].forEach((a2) => {
              A(b4, a2, function() {
                const a3 = this.accessibility;
                a3 && !a3.zombie && a3.update();
              });
            }));
            q.pushUnique(r2, t2) && A(t2, "update", p2);
            q.pushUnique(r2, u2) && ["update", "updatedData", "remove"].forEach((a2) => {
              A(u2, a2, function() {
                this.chart.accessibility && (this.chart.a11yDirty = true);
              });
            });
          };
        })(C || (C = {}));
        t(true, b2, J, { accessibility: { highContrastTheme: B }, lang: I });
        return C;
      });
      x(b, "masters/modules/accessibility.src.js", [
        b["Core/Globals.js"],
        b["Accessibility/Accessibility.js"],
        b["Accessibility/AccessibilityComponent.js"],
        b["Accessibility/Utils/ChartUtilities.js"],
        b["Accessibility/Utils/HTMLUtilities.js"],
        b["Accessibility/KeyboardNavigationHandler.js"],
        b["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]
      ], function(b2, r, q, l, m, u, x2) {
        b2.i18nFormat = r.i18nFormat;
        b2.A11yChartUtilities = l;
        b2.A11yHTMLUtilities = m;
        b2.AccessibilityComponent = q;
        b2.KeyboardNavigationHandler = u;
        b2.SeriesAccessibilityDescriber = x2;
        r.compose(
          b2.Chart,
          b2.Legend,
          b2.Point,
          b2.Series,
          b2.SVGElement,
          b2.RangeSelector
        );
      });
    });
  }
});
export default require_accessibility();
//# sourceMappingURL=highcharts_modules_accessibility.js.map
