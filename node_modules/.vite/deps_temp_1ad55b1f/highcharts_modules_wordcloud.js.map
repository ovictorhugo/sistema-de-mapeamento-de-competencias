{
  "version": 3,
  "sources": ["../../highcharts/modules/wordcloud.src.js"],
  "sourcesContent": ["/**\n * @license Highcharts JS v11.1.0 (2023-06-05)\n *\n * (c) 2016-2021 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isNumber } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            const { animatableAttribs, onComplete, css, renderer } = params;\n            const animation = (point.series && point.series.chart.hasRendered) ?\n                // Chart-level animation on updates\n                void 0 :\n                // Series-level animation on new points\n                (point.series &&\n                    point.series.options.animation);\n            let graphic = point.graphic;\n            params.attribs = Object.assign(Object.assign({}, params.attribs), { 'class': point.getClassName() }) || {};\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    point.graphic = graphic = params.shapeType === 'text' ?\n                        renderer.text() :\n                        renderer[params.shapeType](params.shapeArgs || {});\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                const destroy = () => {\n                    point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, () => destroy());\n                }\n                else {\n                    destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const DrawPointUtilities = {\n            draw\n        };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { seriesTypes: { column: { prototype: { pointClass: ColumnPoint } } } } = SeriesRegistry;\n        const { extend } = U;\n        class WordcloudPoint extends ColumnPoint {\n            constructor() {\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                super(...arguments);\n                this.dimensions = void 0;\n                this.options = void 0;\n                this.polygon = void 0;\n                this.rect = void 0;\n                this.series = void 0;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            isValid() {\n                return true;\n            }\n        }\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { deg2rad } = H;\n        const { extend, find, isNumber, isObject, merge } = U;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            const dx = p2[0] - p1[0], // x2 - x1\n            dy = p2[1] - p1[1]; // y2 - y1\n            return [\n                [-dy, dx],\n                [dy, -dx]\n            ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            let points, axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce(function findAxis(p1, p2) {\n                    const normals = getNormals(p1, p2), axis = normals[0]; // Use the left normal as axis.\n                    // Check that the axis is unique.\n                    if (!find(axes, (existing) => existing[0] === axis[0] &&\n                        existing[1] === axis[1])) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            const products = polygon.map((point) => {\n                const ax = point[0], ay = point[1], bx = target[0], by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            const projection1 = project(polygon1, axis), projection2 = project(polygon2, axis), isOverlapping = !(projection2.min > projection1.max ||\n                projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            const axes1 = getAxesFromPolygon(polygon1), axes2 = getAxesFromPolygon(polygon2), axes = axes1.concat(axes2), overlappingOnAllAxes = !find(axes, (axis) => isPolygonsOverlappingOnAxis(axis, polygon1, polygon2));\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            let intersects = false, rect = point.rect, polygon = point.polygon, lastCollidedWith = point.lastCollidedWith, isIntersecting = function (p) {\n                let result = isRectanglesIntersecting(rect, p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    const result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            let field = params.field, result = false, maxDelta = (field.width * field.width) + (field.height * field.height), t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n            // Emergency brake. TODO make spiralling logic more foolproof.\n            if (attempt <= 10000) {\n                result = {\n                    x: t * Math.cos(t),\n                    y: t * Math.sin(t)\n                };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, params) {\n            let a = attempt * 4, k = Math.ceil((Math.sqrt(a) - 1) / 2), t = 2 * k + 1, m = Math.pow(t, 2), isBoolean = function (x) {\n                return typeof x === 'boolean';\n            }, result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            const result = squareSpiral(attempt, params), field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @param {Highcharts.Series} series\n         * Series object.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            const height = Math.max(Math.abs(field.top), Math.abs(field.bottom)) * 2, width = Math.max(Math.abs(field.left), Math.abs(field.right)) * 2, scaleX = width > 0 ? 1 / width * targetWidth : 1, scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            const info = data.reduce(function (obj, point) {\n                const dimensions = point.dimensions, x = Math.max(dimensions.width, dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            let result = false, // Default to false\n            range, intervals, orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            let length = 10000, i, arr = [];\n            for (i = 1; i < length; i++) {\n                // @todo unnecessary amount of precaclulation\n                arr.push(fn(i, params));\n            }\n            return function (attempt) {\n                return attempt <= length ? arr[attempt - 1] : false;\n            };\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            const playingField = {\n                left: -(field.width / 2),\n                right: field.width / 2,\n                top: -(field.height / 2),\n                bottom: field.height / 2\n            };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            let placed = options.placed, field = options.field, rectangle = options.rectangle, polygon = options.polygon, spiral = options.spiral, attempt = 1, delta = {\n                x: 0,\n                y: 0\n            }, \n            // Make a copy to update values during intersection testing.\n            rect = point.rect = extend({}, rectangle);\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* while w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            let height, width, ratioX, ratioY, x, extendWidth, extendHeight, result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            const p = isNumber(precision) ? precision : 14, magnitude = Math.pow(10, p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                const x = point[0], y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            const origin = [x, y], left = x - (width / 2), right = x + (width / 2), top = y - (height / 2), bottom = y + (height / 2), polygon = [\n                [left, top],\n                [right, top],\n                [right, bottom],\n                [left, bottom]\n            ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            const x = point[0], y = point[1], rad = deg2rad * -angle, cosAngle = Math.cos(rad), sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            const x = point[0] - origin[0], y = point[1] - origin[1], rotated = rotate2DToOrigin([x, y], angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         * Default export\n         *\n         * */\n        const WordcloudUtils = {\n            archimedeanSpiral,\n            extendPlayingField,\n            getBoundingBoxFromPolygon,\n            getPlayingField,\n            getPolygon,\n            getRandomPosition,\n            getRotation,\n            getScale,\n            getSpiral,\n            intersectionTesting,\n            isPolygonsColliding,\n            isRectanglesIntersecting,\n            rectangularSpiral,\n            rotate2DToOrigin,\n            rotate2DToPoint,\n            squareSpiral,\n            updateFieldBoundaries\n        };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, Series, SeriesRegistry, U, WordcloudPoint, WordcloudUtils) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { noop } = H;\n        const { seriesTypes: { column: ColumnSeries } } = SeriesRegistry;\n        const { extend, isArray, isNumber, isObject, merge } = U;\n        const { archimedeanSpiral, extendPlayingField, getBoundingBoxFromPolygon, getPlayingField, getPolygon, getRandomPosition, getRotation, getScale, getSpiral, intersectionTesting, isPolygonsColliding, rectangularSpiral, rotate2DToOrigin, rotate2DToPoint, squareSpiral, updateFieldBoundaries } = WordcloudUtils;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        class WordcloudSeries extends ColumnSeries {\n            constructor() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n            }\n            /**\n             *\n             * Functions\n             *\n             */\n            bindAxes() {\n                const wordcloudAxis = {\n                    endOnTick: false,\n                    gridLineWidth: 0,\n                    lineWidth: 0,\n                    maxPadding: 0,\n                    startOnTick: false,\n                    title: void 0,\n                    tickPositions: []\n                };\n                Series.prototype.bindAxes.call(this);\n                extend(this.yAxis.options, wordcloudAxis);\n                extend(this.xAxis.options, wordcloudAxis);\n            }\n            pointAttribs(point, state) {\n                const attribs = H.seriesTypes.column.prototype\n                    .pointAttribs.call(this, point, state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            }\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            deriveFontSize(relativeWeight, maxFontSize, minFontSize) {\n                const weight = isNumber(relativeWeight) ? relativeWeight : 0, max = isNumber(maxFontSize) ? maxFontSize : 1, min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            }\n            drawPoints() {\n                let series = this, hasRendered = series.hasRendered, xAxis = series.xAxis, yAxis = series.yAxis, chart = series.chart, group = series.group, options = series.options, animation = options.animation, allowExtendPlayingField = options.allowExtendPlayingField, renderer = chart.renderer, testElement = renderer.text().add(group), placed = [], placementStrategy = series.placementStrategy[options.placementStrategy], spiral, rotation = options.rotation, scale, weights = series.points.map(function (p) {\n                    return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // concat() prevents from sorting the original array.\n                data = series.points.concat().sort(function (a, b) {\n                    return b.weight - a.weight; // Sort descending\n                }), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                data.forEach(function (point) {\n                    let relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), bBox;\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                });\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, data);\n                spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                data.forEach(function (point) {\n                    let relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), placement = placementStrategy(point, {\n                        data: data,\n                        field: field,\n                        placed: placed,\n                        rotation: rotation\n                    }), attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                        align: 'center',\n                        'alignment-baseline': 'middle',\n                        'dominant-baseline': 'middle',\n                        x: placement.x,\n                        y: placement.y,\n                        text: point.name,\n                        rotation: isNumber(placement.rotation) ?\n                            placement.rotation :\n                            void 0\n                    }), polygon = getPolygon(placement.x, placement.y, point.dimensions.width, point.dimensions.height, placement.rotation), rectangle = getBoundingBoxFromPolygon(polygon), delta = intersectionTesting(point, {\n                        rectangle: rectangle,\n                        polygon: polygon,\n                        field: field,\n                        placed: placed,\n                        spiral: spiral,\n                        rotation: placement.rotation\n                    }), animate;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                });\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            }\n            hasData() {\n                const series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            }\n            getPlotBox() {\n                const series = this, chart = series.chart, inverted = chart.inverted, \n                // Swap axes for inverted (#2339)\n                xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            }\n        }\n        /**\n         * A word cloud is a visualization of a set of words, where the size and\n         * placement of a word is determined by how it is weighted.\n         *\n         * @sample highcharts/demo/wordcloud Word Cloud chart\n         *\n         * @extends      plotOptions.column\n         * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n         *               compareBase, crisp, cropThreshold, dataGrouping,\n         *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n         *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n         *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPadding, pointPlacement, pointRange, pointStart,\n         *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n         *               showInNavigator, softThreshold, stacking, threshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        6.0.0\n         * @requires     modules/wordcloud\n         * @optionparent plotOptions.wordcloud\n         */\n        WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n            /**\n             * If there is no space for a word on the playing field, then this\n             * option will allow the playing field to be extended to fit the word.\n             * If false then the word will be dropped from the visualization.\n             *\n             * NB! This option is currently not decided to be published in the API,\n             * and is therefore marked as private.\n             *\n             * @ignore-option\n             */\n            allowExtendPlayingField: true,\n            animation: {\n                /** @internal */\n                duration: 500\n            },\n            borderWidth: 0,\n            /**\n             * @ignore-option\n             */\n            clip: false,\n            colorByPoint: true,\n            cropThreshold: Infinity,\n            /**\n             * A threshold determining the minimum font size that can be applied to\n             * a word.\n             */\n            minFontSize: 1,\n            /**\n             * The word with the largest weight will have a font size equal to this\n             * value. The font size of a word is the ratio between its weight and\n             * the largest occuring weight, multiplied with the value of\n             * maxFontSize.\n             */\n            maxFontSize: 25,\n            /**\n             * This option decides which algorithm is used for placement, and\n             * rotation of a word. The choice of algorith is therefore a crucial\n             * part of the resulting layout of the wordcloud. It is possible for\n             * users to add their own custom placement strategies for use in word\n             * cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n             *\n             * @validvalue [\"center\", \"random\"]\n             */\n            placementStrategy: 'center',\n            /**\n             * Rotation options for the words in the wordcloud.\n             *\n             * @sample highcharts/plotoptions/wordcloud-rotation\n             *         Word cloud with rotation\n             */\n            rotation: {\n                /**\n                 * The smallest degree of rotation for a word.\n                 */\n                from: 0,\n                /**\n                 * The number of possible orientations for a word, within the range\n                 * of `rotation.from` and `rotation.to`. Must be a number larger\n                 * than 0.\n                 */\n                orientations: 2,\n                /**\n                 * The largest degree of rotation for a word.\n                 */\n                to: 90\n            },\n            showInLegend: false,\n            /**\n             * Spiral used for placing a word after the initial position\n             * experienced a collision with either another word or the borders.\n             * It is possible for users to add their own custom spiralling\n             * algorithms for use in word cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n             *\n             * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n             */\n            spiral: 'rectangular',\n            /**\n             * CSS styles for the words.\n             *\n             * @type    {Highcharts.CSSObject}\n             * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n             */\n            style: {\n                /** @ignore-option */\n                fontFamily: 'sans-serif',\n                /** @ignore-option */\n                fontWeight: '900',\n                /** @ignore-option */\n                whiteSpace: 'nowrap'\n            },\n            tooltip: {\n                followPointer: true,\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n            }\n        });\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    const field = options.field, r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    const r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         * Export Default\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // detach doclets above\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [], function () {\n\n\n    });\n}));"],
  "mappings": "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",
  "names": ["factory", "module", "exports", "define", "amd", "Highcharts", "undefined", "_registerModule", "obj", "path", "args", "fn", "hasOwnProperty", "apply", "CustomEvent", "window", "dispatchEvent", "detail", "_modules", "U", "DrawPointUtilities", "draw", "point", "params", "animatableAttribs", "onComplete", "css", "renderer", "animation", "series", "chart", "hasRendered", "options", "graphic", "attribs", "Object", "assign", "getClassName", "shouldDraw", "shapeType", "text", "shapeArgs", "add", "group", "attr", "animate", "isNew", "destroy", "keys", "length", "SeriesRegistry", "ColumnPoint", "extend", "WordcloudPoint", "arguments", "rect", "polygon", "dimensions", "prototype", "weight", "H", "isRectanglesIntersecting", "r1", "r2", "left", "right", "top", "bottom", "getNormals", "p1", "p2", "dx", "dy", "getAxesFromPolygon", "points", "axes", "concat", "reduce", "findAxis", "axis", "normals", "find", "existing", "push", "project", "target", "products", "map", "ax", "bx", "ay", "by", "min", "Math", "max", "isPolygonsColliding", "polygon1", "polygon2", "axes1", "axes2", "overlappingOnAllAxes", "projection1", "projection2", "h", "isOverlapping", "intersectsAnyWord", "intersects", "lastCollidedWith", "isIntersecting", "p", "result", "rotation", "squareSpiral", "attempt", "a", "k", "ceil", "sqrt", "t", "m", "pow", "x", "y", "outsidePlayingField", "field", "width", "height", "d", "movePolygon", "deltaX", "deltaY", "correctFloat", "number", "precision", "isNumber", "magnitude", "round", "rotate2DToOrigin", "angle", "rad", "deg2rad", "cosAngle", "cos", "sinAngle", "sin", "rotate2DToPoint", "origin", "rotated", "isObject", "merge", "WordcloudUtils", "archimedeanSpiral", "maxDelta", "abs", "extendPlayingField", "rectangle", "ratioY", "ratioX", "getBoundingBoxFromPolygon", "Number", "MAX_VALUE", "getPlayingField", "targetWidth", "targetHeight", "data", "info", "maxHeight", "maxWidth", "area", "getPolygon", "getRandomPosition", "size", "random", "getRotation", "orientations", "index", "from", "to", "getScale", "getSpiral", "i", "arr", "intersectionTesting", "placed", "spiral", "delta", "rectangularSpiral", "updateFieldBoundaries", "DPU", "Series", "noop", "ColumnSeries", "isArray", "WordcloudSeries", "wordcloudAxis", "endOnTick", "gridLineWidth", "lineWidth", "maxPadding", "startOnTick", "title", "tickPositions", "bindAxes", "call", "yAxis", "xAxis", "state", "seriesTypes", "column", "pointAttribs", "stroke", "relativeWeight", "maxFontSize", "minFontSize", "floor", "allowExtendPlayingField", "testElement", "placementStrategy", "weights", "maxWeight", "sort", "b", "scaleX", "scaleY", "forEach", "fontSize", "deriveFontSize", "style", "name", "bBox", "getBBox", "len", "spirals", "placement", "selected", "align", "isNull", "isInside", "scale", "visible", "inverted", "translateX", "plotLeft", "plotWidth", "translateY", "plotTop", "plotHeight", "defaultOptions", "duration", "borderWidth", "clip", "colorByPoint", "cropThreshold", "Infinity", "showInLegend", "fontFamily", "fontWeight", "whiteSpace", "tooltip", "followPointer", "pointFormat", "animateDrilldown", "animateDrillupFrom", "pointClass", "setClip", "r", "center", "pointArrayMap", "utils", "registerSeriesType"]
}
