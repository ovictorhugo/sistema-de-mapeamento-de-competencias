import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/modules/wordcloud.js
var require_wordcloud = __commonJS({
  "node_modules/highcharts/modules/wordcloud.js"(exports, module) {
    (function(d) {
      "object" === typeof module && module.exports ? (d["default"] = d, module.exports = d) : "function" === typeof define && define.amd ? define("highcharts/modules/wordcloud", ["highcharts"], function(f) {
        d(f);
        d.Highcharts = f;
        return d;
      }) : d("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(d) {
      function f(d2, e, g, y) {
        d2.hasOwnProperty(e) || (d2[e] = y.apply(null, g), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e, module: d2[e] } })));
      }
      d = d ? d._modules : {};
      f(d, "Series/DrawPointUtilities.js", [d["Core/Utilities.js"]], function(d2) {
        return { draw: function(d3, g) {
          const { animatableAttribs: e, onComplete: f2, css: r, renderer: m } = g, t = d3.series && d3.series.chart.hasRendered ? void 0 : d3.series && d3.series.options.animation;
          let n = d3.graphic;
          g.attribs = Object.assign(Object.assign({}, g.attribs), { "class": d3.getClassName() }) || {};
          if (d3.shouldDraw())
            n || (d3.graphic = n = "text" === g.shapeType ? m.text() : m[g.shapeType](g.shapeArgs || {}), n.add(g.group)), r && n.css(r), n.attr(g.attribs).animate(e, g.isNew ? false : t, f2);
          else if (n) {
            const g2 = () => {
              d3.graphic = n = n && n.destroy();
              "function" === typeof f2 && f2();
            };
            Object.keys(e).length ? n.animate(e, void 0, () => g2()) : g2();
          }
        } };
      });
      f(d, "Series/Wordcloud/WordcloudPoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(d2, e) {
        ({ seriesTypes: { column: { prototype: { pointClass: d2 } } } } = d2);
        ({ extend: e } = e);
        class g extends d2 {
          constructor() {
            super(...arguments);
            this.series = this.rect = this.polygon = this.options = this.dimensions = void 0;
          }
          isValid() {
            return true;
          }
        }
        e(g.prototype, { weight: 1 });
        return g;
      });
      f(d, "Series/Wordcloud/WordcloudUtils.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function(d2, e) {
        function g(a, b) {
          return !(b.left > a.right || b.right < a.left || b.top > a.bottom || b.bottom < a.top);
        }
        function f2(a, b) {
          const c = b[0] - a[0];
          a = b[1] - a[1];
          return [[-a, c], [a, -c]];
        }
        function r(a) {
          let b, c = a.axes || [];
          c.length || (c = [], b = b = a.concat([a[0]]), b.reduce(function(a2, b2) {
            const h = f2(a2, b2)[0];
            C(c, (a3) => a3[0] === h[0] && a3[1] === h[1]) || c.push(h);
            return b2;
          }), a.axes = c);
          return c;
        }
        function z(a, b) {
          a = a.map((a2) => a2[0] * b[0] + a2[1] * b[1]);
          return { min: Math.min.apply(
            this,
            a
          ), max: Math.max.apply(this, a) };
        }
        function m(a, b) {
          var c = r(a);
          const h = r(b);
          c = c.concat(h);
          return !C(c, (c2) => {
            var h2 = z(a, c2);
            c2 = z(b, c2);
            return h2 = !!(c2.min > h2.max || c2.max < h2.min);
          });
        }
        function t(a, b) {
          let c = false, h = a.rect, d3 = a.polygon, l = a.lastCollidedWith, e2 = function(b2) {
            let c2 = g(h, b2.rect);
            c2 && (a.rotation % 90 || b2.rotation % 90) && (c2 = m(d3, b2.polygon));
            return c2;
          };
          l && ((c = e2(l)) || delete a.lastCollidedWith);
          c || (c = !!C(b, function(b2) {
            const c2 = e2(b2);
            c2 && (a.lastCollidedWith = b2);
            return c2;
          }));
          return c;
        }
        function n(a, b) {
          b = 4 * a;
          let c = Math.ceil((Math.sqrt(b) - 1) / 2), h = 2 * c + 1, d3 = Math.pow(h, 2), l = false;
          --h;
          1e4 >= a && ("boolean" === typeof l && b >= d3 - h && (l = { x: c - (d3 - b), y: -c }), d3 -= h, "boolean" === typeof l && b >= d3 - h && (l = { x: -c, y: -c + (d3 - b) }), d3 -= h, "boolean" === typeof l && (l = b >= d3 - h ? { x: -c + (d3 - b), y: c } : { x: c, y: c - (d3 - b - h) }), l.x *= 5, l.y *= 5);
          return l;
        }
        function v(a, b) {
          var c = b.width / 2, h = -(b.height / 2), d3 = b.height / 2;
          return !(-(b.width / 2) < a.left && c > a.right && h < a.top && d3 > a.bottom);
        }
        function M(a, b, c) {
          return c.map(function(c2) {
            return [c2[0] + a, c2[1] + b];
          });
        }
        function x(a, b) {
          b = k(b) ? b : 14;
          b = Math.pow(10, b);
          return Math.round(a * b) / b;
        }
        function D(a, b) {
          const c = a[0];
          a = a[1];
          var d3 = H * -b;
          b = Math.cos(d3);
          d3 = Math.sin(d3);
          return [x(c * b - a * d3), x(c * d3 + a * b)];
        }
        function w(a, b, c) {
          a = D([a[0] - b[0], a[1] - b[1]], c);
          return [a[0] + b[0], a[1] + b[1]];
        }
        const { deg2rad: H } = d2, { extend: F, find: C, isNumber: k, isObject: E, merge: A } = e;
        return { archimedeanSpiral: function(a, b) {
          var c = b.field;
          b = false;
          c = c.width * c.width + c.height * c.height;
          let d3 = 0.8 * a;
          1e4 >= a && (b = { x: d3 * Math.cos(d3), y: d3 * Math.sin(d3) }, Math.min(Math.abs(b.x), Math.abs(b.y)) < c || (b = false));
          return b;
        }, extendPlayingField: function(a, b) {
          let c, d3;
          if (E(a) && E(b)) {
            var q = b.bottom - b.top;
            c = b.right - b.left;
            b = a.ratioX;
            d3 = a.ratioY;
            q = c * b > q * d3 ? c : q;
            a = A(a, { width: a.width + q * b * 2, height: a.height + q * d3 * 2 });
          }
          return a;
        }, getBoundingBoxFromPolygon: function(a) {
          return a.reduce(function(a2, c) {
            const b = c[0];
            c = c[1];
            a2.left = Math.min(b, a2.left);
            a2.right = Math.max(b, a2.right);
            a2.bottom = Math.max(c, a2.bottom);
            a2.top = Math.min(c, a2.top);
            return a2;
          }, { left: Number.MAX_VALUE, right: -Number.MAX_VALUE, bottom: -Number.MAX_VALUE, top: Number.MAX_VALUE });
        }, getPlayingField: function(a, b, c) {
          c = c.reduce(function(a2, b2) {
            b2 = b2.dimensions;
            const c2 = Math.max(b2.width, b2.height);
            a2.maxHeight = Math.max(a2.maxHeight, b2.height);
            a2.maxWidth = Math.max(a2.maxWidth, b2.width);
            a2.area += c2 * c2;
            return a2;
          }, { maxHeight: 0, maxWidth: 0, area: 0 });
          c = Math.max(c.maxHeight, c.maxWidth, 0.85 * Math.sqrt(c.area));
          const d3 = a > b ? a / b : 1;
          a = b > a ? b / a : 1;
          return { width: c * d3, height: c * a, ratioX: d3, ratioY: a };
        }, getPolygon: function(a, b, c, d3, g2) {
          const h = [a, b], e2 = a - c / 2;
          a += c / 2;
          c = b - d3 / 2;
          b += d3 / 2;
          return [[e2, c], [a, c], [a, b], [e2, b]].map(function(a2) {
            return w(a2, h, -g2);
          });
        }, getRandomPosition: function(a) {
          return Math.round(a * (Math.random() + 0.5) / 2);
        }, getRotation: function(a, b, c, d3) {
          let h = false;
          k(a) && k(b) && k(c) && k(d3) && 0 < a && -1 < b && d3 > c && (h = c + b % a * ((d3 - c) / (a - 1 || 1)));
          return h;
        }, getScale: function(a, b, c) {
          const d3 = 2 * Math.max(Math.abs(c.top), Math.abs(c.bottom));
          c = 2 * Math.max(Math.abs(c.left), Math.abs(c.right));
          return Math.min(0 < c ? 1 / c * a : 1, 0 < d3 ? 1 / d3 * b : 1);
        }, getSpiral: function(a, b) {
          let c, d3 = [];
          for (c = 1; 1e4 > c; c++)
            d3.push(a(c, b));
          return function(a2) {
            return 1e4 >= a2 ? d3[a2 - 1] : false;
          };
        }, intersectionTesting: function(a, b) {
          let c = b.placed, d3 = b.field, g2 = b.rectangle, e2 = b.polygon, n2 = b.spiral, f3 = 1, p = { x: 0, y: 0 }, k2 = a.rect = F({}, g2);
          a.polygon = e2;
          for (a.rotation = b.rotation; false !== p && (t(a, c) || v(k2, d3)); )
            p = n2(f3), E(p) && (k2.left = g2.left + p.x, k2.right = g2.right + p.x, k2.top = g2.top + p.y, k2.bottom = g2.bottom + p.y, a.polygon = M(p.x, p.y, e2)), f3++;
          return p;
        }, isPolygonsColliding: m, isRectanglesIntersecting: g, rectangularSpiral: function(a, b) {
          a = n(a, b);
          b = b.field;
          a && (a.x *= b.ratioX, a.y *= b.ratioY);
          return a;
        }, rotate2DToOrigin: D, rotate2DToPoint: w, squareSpiral: n, updateFieldBoundaries: function(a, b) {
          if (!k(a.left) || a.left > b.left)
            a.left = b.left;
          if (!k(a.right) || a.right < b.right)
            a.right = b.right;
          if (!k(a.top) || a.top > b.top)
            a.top = b.top;
          if (!k(a.bottom) || a.bottom < b.bottom)
            a.bottom = b.bottom;
          return a;
        } };
      });
      f(d, "Series/Wordcloud/WordcloudSeries.js", [d["Series/DrawPointUtilities.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"], d["Series/Wordcloud/WordcloudPoint.js"], d["Series/Wordcloud/WordcloudUtils.js"]], function(d2, e, g, f2, K, z, m) {
        const { noop: t } = e, { seriesTypes: { column: n } } = f2, {
          extend: v,
          isArray: r,
          isNumber: x,
          isObject: D,
          merge: w
        } = K, { archimedeanSpiral: H, extendPlayingField: F, getBoundingBoxFromPolygon: C, getPlayingField: k, getPolygon: E, getRandomPosition: A, getRotation: a, getScale: b, getSpiral: c, intersectionTesting: h, isPolygonsColliding: q, rectangularSpiral: l, rotate2DToOrigin: y, rotate2DToPoint: L, squareSpiral: p, updateFieldBoundaries: N } = m;
        class B extends n {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          bindAxes() {
            const a2 = {
              endOnTick: false,
              gridLineWidth: 0,
              lineWidth: 0,
              maxPadding: 0,
              startOnTick: false,
              title: void 0,
              tickPositions: []
            };
            g.prototype.bindAxes.call(this);
            v(this.yAxis.options, a2);
            v(this.xAxis.options, a2);
          }
          pointAttribs(a2, b2) {
            a2 = e.seriesTypes.column.prototype.pointAttribs.call(this, a2, b2);
            delete a2.stroke;
            delete a2["stroke-width"];
            return a2;
          }
          deriveFontSize(a2, b2, c2) {
            a2 = x(a2) ? a2 : 0;
            b2 = x(b2) ? b2 : 1;
            c2 = x(c2) ? c2 : 1;
            return Math.floor(Math.max(c2, a2 * b2));
          }
          drawPoints() {
            let a2 = this, g2 = a2.hasRendered;
            var e2 = a2.xAxis;
            let f3 = a2.yAxis, n2 = a2.group, l2 = a2.options, p2 = l2.animation, t2 = l2.allowExtendPlayingField, r2 = a2.chart.renderer, m2 = r2.text().add(n2), q2 = [], z2 = a2.placementStrategy[l2.placementStrategy], w2, A2 = l2.rotation, B2 = a2.points.map(function(a3) {
              return a3.weight;
            }), y2 = Math.max.apply(null, B2), G = a2.points.concat().sort(function(a3, b2) {
              return b2.weight - a3.weight;
            }), u;
            a2.group.attr({ scaleX: 1, scaleY: 1 });
            G.forEach(function(b2) {
              var c2 = a2.deriveFontSize(1 / y2 * b2.weight, l2.maxFontSize, l2.minFontSize);
              c2 = v({ fontSize: c2 + "px" }, l2.style);
              m2.css(c2).attr({ x: 0, y: 0, text: b2.name });
              c2 = m2.getBBox(true);
              b2.dimensions = { height: c2.height, width: c2.width };
            });
            u = k(e2.len, f3.len, G);
            w2 = c(a2.spirals[l2.spiral], { field: u });
            G.forEach(function(b2) {
              var c2 = a2.deriveFontSize(1 / y2 * b2.weight, l2.maxFontSize, l2.minFontSize);
              c2 = v({ fontSize: c2 + "px" }, l2.style);
              let e3 = z2(b2, { data: G, field: u, placed: q2, rotation: A2 }), f4 = v(a2.pointAttribs(b2, b2.selected && "select"), { align: "center", "alignment-baseline": "middle", "dominant-baseline": "middle", x: e3.x, y: e3.y, text: b2.name, rotation: x(e3.rotation) ? e3.rotation : void 0 }), I = E(e3.x, e3.y, b2.dimensions.width, b2.dimensions.height, e3.rotation), k2 = C(I), m3 = h(b2, { rectangle: k2, polygon: I, field: u, placed: q2, spiral: w2, rotation: e3.rotation }), J;
              !m3 && t2 && (u = F(u, k2), m3 = h(b2, { rectangle: k2, polygon: I, field: u, placed: q2, spiral: w2, rotation: e3.rotation }));
              D(m3) ? (f4.x = (f4.x || 0) + m3.x, f4.y = (f4.y || 0) + m3.y, k2.left += m3.x, k2.right += m3.x, k2.top += m3.y, k2.bottom += m3.y, u = N(u, k2), q2.push(b2), b2.isNull = false, b2.isInside = true) : b2.isNull = true;
              p2 && (J = { x: f4.x, y: f4.y }, g2 ? (delete f4.x, delete f4.y) : (f4.x = 0, f4.y = 0));
              d2.draw(b2, { animatableAttribs: J, attribs: f4, css: c2, group: n2, renderer: r2, shapeArgs: void 0, shapeType: "text" });
            });
            m2 = m2.destroy();
            e2 = b(e2.len, f3.len, u);
            a2.group.attr({ scaleX: e2, scaleY: e2 });
          }
          hasData() {
            return D(this) && true === this.visible && r(this.points) && 0 < this.points.length;
          }
          getPlotBox() {
            const a2 = this.chart;
            var b2 = a2.inverted;
            const c2 = this[b2 ? "yAxis" : "xAxis"];
            b2 = this[b2 ? "xAxis" : "yAxis"];
            return { translateX: (c2 ? c2.left : a2.plotLeft) + (c2 ? c2.len : a2.plotWidth) / 2, translateY: (b2 ? b2.top : a2.plotTop) + (b2 ? b2.len : a2.plotHeight) / 2, scaleX: 1, scaleY: 1 };
          }
        }
        B.defaultOptions = w(n.defaultOptions, {
          allowExtendPlayingField: true,
          animation: { duration: 500 },
          borderWidth: 0,
          clip: false,
          colorByPoint: true,
          cropThreshold: Infinity,
          minFontSize: 1,
          maxFontSize: 25,
          placementStrategy: "center",
          rotation: { from: 0, orientations: 2, to: 90 },
          showInLegend: false,
          spiral: "rectangular",
          style: { fontFamily: "sans-serif", fontWeight: "900", whiteSpace: "nowrap" },
          tooltip: { followPointer: true, pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.weight}</b><br/>' }
        });
        v(B.prototype, { animate: t, animateDrilldown: t, animateDrillupFrom: t, pointClass: z, setClip: t, placementStrategy: { random: function(b2, c2) {
          const d3 = c2.field;
          c2 = c2.rotation;
          return { x: A(d3.width) - d3.width / 2, y: A(d3.height) - d3.height / 2, rotation: a(
            c2.orientations,
            b2.index,
            c2.from,
            c2.to
          ) };
        }, center: function(b2, c2) {
          c2 = c2.rotation;
          return { x: 0, y: 0, rotation: a(c2.orientations, b2.index, c2.from, c2.to) };
        } }, pointArrayMap: ["weight"], spirals: { archimedean: H, rectangular: l, square: p }, utils: { extendPlayingField: F, getRotation: a, isPolygonsColliding: q, rotate2DToOrigin: y, rotate2DToPoint: L } });
        f2.registerSeriesType("wordcloud", B);
        "";
        return B;
      });
      f(d, "masters/modules/wordcloud.src.js", [], function() {
      });
    });
  }
});
export default require_wordcloud();
//# sourceMappingURL=highcharts_modules_wordcloud.js.map
